---
layout: post
title:  "[알고리즘] 문자열 알고리즘"
tags: algorithm
comments: true
---

문자열 알고리즘은 사실 코테에서 내장 함수를 사용하면 되기 때문에 그렇게 큰 비중이 있지는 않지만 면접에서 나올 수 있기 때문에 복습을 해보자

문자열 알고리즘은 여러가지 있지만 Naive algorithm, KMP, Boyer Moore, Trie, Rabin Karp algorithm 을 알아보도록 하자

# Naive algorithm
Naive algorithm 방식은 문자열의 각 글자를 비교하며 찾아야 하는 패턴을 찾는 식이다. 패턴의 첫 글자를 문자열에서 찾고, 첫 글자가 있으면 그 다음 글자를 찾는 식이다.

Best Case는 패턴의 첫 글자가 문자열에 없을 때 `O(n)` 비교를 하고 알고리즘이 끝난다. 

Worst Case는 패턴의 모든 글자 혹은 마지막 글자를 제외한 모든 글자가 문자열과 같다면 `O(m*(n - m + 1))` 만큼 비교를 하게 된다. 

#### 파이썬 구현
```python
import sys

def search(pattern, text):
    M = len(pattern)
    N = len(text)

    for i in range(N - M + 1):
        j = 0

        # 현재 i 와 패턴이 맞는지 확인
        while (j < M):
            if text[i + j] != pattern[j]:
                break
            j += 1
        
        if j == M:
            print("Pattern found at index: ", i)


def solution():
    # 입력값 읽기
    text = sys.stdin.readline().strip()
    pattern = sys.stdin.readline().strip()

    search(pattern, text)


if __name__ == "__main__":
    solution()

# AAAAAAAVAAVAVAVAVAVA
# VAVA
# Pattern found at index:  10
# Pattern found at index:  12
# Pattern found at index:  14
# Pattern found at index:  16
```
# Knuth Morris Pratt Algorithm
KMP 알고리즘은 찾고자 하는 패턴을 윈도우로 활용해서 문자열에서 결과 값을 찾는 방식이다. 핵심은 패턴의 모든 문자와 문자열의 모든 문자를 비교하는 방식이 아닌 필요한 부분만 비교하는 것이다. 

이를 위해 패턴의 어떤 글자에서 비교를 할 것인지 기록하는 새로운 배열이 필요하다.

KMP 알고리즘의 최악의 시간 복잡도는 `O(n)`이다.

###### 출처: [geeksforgeeks](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)

```
비교하는 문자를 소문자로 표현하겠다

txt[] = "AAAAABAAABA" 
pat[] = "AAAA"
lps[] = {0, 1, 2, 3} 

i = 0, j = 0
txt[] = "aAAAABAAABA" 
pat[] = "aAAA"
txt[i] and pat[j] match, do i++, j++

i = 1, j = 1
txt[] = "AaAAABAAABA" 
pat[] = "AaAA"
txt[i] and pat[j] match, do i++, j++

i = 2, j = 2
txt[] = "AAaAABAAABA" 
pat[] = "AAaA"
pat[i] and pat[j] match, do i++, j++

i = 3, j = 3
txt[] = "AAAaABAAABA" 
pat[] = "AAAa"
txt[i] and pat[j] match, do i++, j++

i = 4, j = 4
Since j == M, print pattern found and reset j,
j = lps[j-1] = lps[3] = 3

Here unlike Naive algorithm, we do not match first three 
characters of this window. Value of lps[j-1] (in above 
step) gave us index of next character to match.
i = 4, j = 3
txt[] = "AAAAaBAAABA" 
pat[] =  "AAAa"
txt[i] and pat[j] match, do i++, j++

i = 5, j = 4
Since j == M, print pattern found and reset j,
j = lps[j-1] = lps[3] = 3

Again unlike Naive algorithm, we do not match first three 
characters of this window. Value of lps[j-1] (in above 
step) gave us index of next character to match.
i = 5, j = 3
txt[] = "AAAAAbAAABA" 
pat[] =   "AAAa"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[2] = 2

i = 5, j = 2
txt[] = "AAAAAbAAABA" 
pat[] =    "AAaA"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[1] = 1 

i = 5, j = 1
txt[] = "AAAAAbAAABA" 
pat[] =     "AaAA"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[0] = 0

i = 5, j = 0
txt[] = "AAAAAbAAABA" 
pat[] =      "aAAA"
txt[i] and pat[j] do NOT match and j is 0, we do i++.

i = 6, j = 0
txt[] = "AAAAABaAABA" 
pat[] =       "aAAA"
txt[i] and pat[j] match, do i++ and j++

i = 7, j = 1
txt[] = "AAAAABAaABA" 
pat[] =       "AaAA"
txt[i] and pat[j] match, do i++ and j++

We continue this way...
```

#### 파이썬 구현
```python
import sys

def kmp_search(pattern, text):
    M = len(pattern)
    N = len(text)

    # 패턴의 가장 긴 prefix 와 suffix를 담을 
    # lps 배열을 만든다
    lps = [0] * M
    j = 0 # 패턴 index

    # pattern에서 lps 배열을 만든다
    compute_lps(pattern, M, lps)

    i = 0 # text index
    while i < N:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == M:
            print("Pattern found at index: ", str(i-j))
            j = lps[j-1]
        
        # mismatch after j matches
        elif i < N and pattern[j] != text[i]:
            # don't match lps characters,
            # they will match anyways
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

def compute_lps(pattern, M, lps):
    prev_long_len = 0 # length of previous longest prefix suffix
    lps[0] = 0 # lps[0] is always 0
    i = 1

    # loop from i to M - 1
    while i < M:
        if pattern[i] == pattern[prev_long_len]:
            prev_long_len += 1
            lps[i] = prev_long_len
            i += 1
        else:
            if prev_long_len != 0:
                prev_long_len = lps[prev_long_len-1]
            else:
                lps[i] = 0
                i += 1

def solution():
    # 입력값 읽기
    text = sys.stdin.readline().strip()
    pattern = sys.stdin.readline().strip()

    kmp_search(pattern, text)


if __name__ == "__main__":
    solution()

# AAAAAAAVAAVAVAVAVAVA
# VAVA
# Pattern found at index:  10
# Pattern found at index:  12
# Pattern found at index:  14
# Pattern found at index:  16
```

# Boyer Moore Algorithm
