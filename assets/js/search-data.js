var store = [{
        "title": "Hello there 👋",
        "excerpt":"I’m not really sure if I’ll maintain this dev blog in Eng or Kor, but this is my first post. Just to keep track of dev stuff I do. ","categories": [],
        "tags": ["devblog"],
        "url": "https://json9512.github.io/blog/first-post/"
      },{
        "title": "Python",
        "excerpt":"들어가며 . . . 애용하는 언어인 파이썬에 대해 좀 알아보고 복기하기 위한 포스트   파이썬은 원래 가독성이 좋은 프로그래밍 언어  가독성을 살려서 코드를 작성하게끔 pythonic 한 가이드라인이 있음  Python coding convention과 흔히 접하지 않는 것들에 대해 알아보자Python Code Styles 를 보며 내 마음대로 의역한 것 Content   General Rules  IdiomsGeneral Rules 1. Explicit code Bad def make_complex(*args):    x, y = args    return dict(**locals())Good def make_complex(x, y):    return {'x': x, 'y': y}딱 보면 무슨 코드인지 알 수 있도록 (self-explanatory) 2. One statement per line Bad print 'a'; print 'b'if x == 1: print 'a'if &lt;complex comparison&gt; and &lt;complex comparison&gt;:    # do some'inGood print 'a'print 'b'if x == 1:     print 'a'condition1 = &lt;complex comparison&gt;condition2 = &lt;complex comparison&gt;if condition1 and condition2:    # do some'in3. Function arguments 4 가지 방법이 있음   positional arguments - send(message, recipient) -&gt; send(\"Hello\", \"God\"), point(x, y) -&gt; point(0, 35) function 구동에 무조건 필요한 arguments  keyword arguments - send(message, to, cc=None) -&gt; send(\"Hello\", \"God\", \"Mom\") or send(\"Hello\", \"God\")기본값을 지정한 argument; function 구동에 필수적이지 않은 argument (cc)  arbitrary argument list - send(message, *args) -&gt; send(\"Hello\", \"God\", \"Mom\", \"Dad\" message argument 이후에 하나의 tuple로 입력 arguments를 저장함; tuple에 저장되는 값의 type이 다 다를 때 사용하는 것이 유용함  arbitrary keyword argument dictionary - send(message, **kwargs) -&gt; send(\"Hello\", to=God, cc=Mom)개발자의 판단에 따라 가장 적합한 방식으로 코드를 짜면 됨 4. Don’t use the magical wand 파이썬은 customizable하다. 하지만 기본적으로 작동되는 방식을 바꾸게 되면 가독성/효율이 떨어진다. 정말 필요할 때가 아니면 하지 말자 5. We are all responsible users 파이썬은 다른 언어에 있는 private 변수나 클래스 같은 것들이 기본적으로 사용되지 않는다. 이는 Java와 같이 방어적(?)인 언어들과 다르다. 이유는 python 개발자는 모두 책임감이 있다고 믿기 때문이다. 개발자로서 자신이 사용하면 안되는 코드/특성은 사용을 하지 않는 것이 좋다. 하지만 private 특성을 만들지 못하거나 encapsulation이 불가능 하다는 뜻이 아니다. __를 특성/함수 앞에다가 붙이면 된다. class Foo:    '''        __test = \"Ac\"    '''    def __init__(self):        self.__test = \"Ac\"    def __print_me(self):        print(self.__test)# outsideb = Foo()b.__print_me() # no attribute errorprint(b.__test) # no attribute error6. Returning Values       함수가 복잡할수록 여러 곳에서 return 을 할 때가 종종 있다. 하지만 가독성을 중요시하고 코드가 더 직관적이고자 한다면, 여러 곳에서 return을 하는 것은 좋지 않다     보통 2가지의 경우에 함수에서 return을 한다          로직을 따라 정상처리가 됐을 때      에러가 났을 때        Refactoring을 위해 하나의 return 포인트를 유지 하는 것이 좋다def complex_function(a, b):    if not a:        return None # raising an exception might be better        if not b:         return None # raising an exception might be better        # Some complex code to compute x from a, b    # Resist temptation to return when compute succeeds    if not x:        # some code to compute x as plan-b    return x # single exit point for maintainabilityIdioms   pythonic 한 코드를 작성하는 방법은 아래와 같다1. Unpacking values   리스트에서 아이템 추출 시 enumerate() 함수 사용     for index, item in enumerate(some_list):     # do some'in with index and item        변수끼리 swap 할 때     # common  temp = b b = a a = temp # pythonic a, b = b, a        Nested unpacking     a, (b, c) = 1, (2, 3) # python 3 (new feature) a, *rest = [1, 2, 3, 4] # a = 1, rest = [2, 3, 4] a, *mid, c = [1, 2, 3, 4] # a = 1, mid = [2, 3], c = 4      2. Creating an ignored variable filename = \"awesomefile.txt\"basename, __, ext = filename.rpartition(\".\")# basename = awesomefile, __ = ., ext = txt# use __ to ignore vals# using _ might conflict since it's an alias for # gettext(), and _ is used to store the last operation # at the interactive prompt3. Creating lists A list of length - N arr_four = [0] * 4A list of length - N of lists arr_four_nested = [[] for __ in range(4)]Create a string from list some_list = [\"a\", \"b\", \"c\"]stringified = ''.join(some_list)4. Searching items in iterables some_set = set([\"i\", \"t\", \"e\", \"m\"])some_list = [\"i\", \"t\", \"e\", \"m\"]cond1 = \"t\" in some_setcond2 = \"i\" in some_set# Set/Dict is a hash table# Much faster than lists/tuples when searching a large dataset# Sometimes using lists is better because creating the hash table requires more memory 5. Zen of Python &gt;&gt;&gt; import this'''The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!'''With example on github 6. PEP 8   defacto code style for python. Available here7. Some Conventions 1. Check if variable equals constant # Badif attr == True:    return \"True!\"if attr == None:    return \"None!\"# Goodif attr:    return \"True\"if not attr:    return \"False\"if attr is None:    return \"None\"2. Access a dictionary element # Badd = {\"hello\": \"there\"}# Don't use dict.has_key()if d.has_key(\"hello\"):    print(d[\"hello\"])else:    print(\"default_value\")# Goodd = {\"hello\": \"there\"}print(d.get('hello', 'default_value')) # prints 'there'print(d.get('somein', 'default_value')) # prints 'default_value'# Or:if 'hello' in d:    print(d['hello'])3. Short ways to manipulate lists # Bad - needlessly allocates a list of all (gpa, name) entries in memoryvaledictorian = max([(student.gpa, student.name) for student in graduates])# Goodvaledictorian = max((student.gpa, student.name) for student in graduates)# Good# Generator functions for more complex tasksdef make_batches(items, batch_size):    '''    &gt;&gt;&gt; list(make_batches([1, 2, 3, 4, 5], batch_size=3))    [[1, 2, 3], [4, 5]]    &gt;&gt;&gt; generator = make_batches([1, 2, 3, 4, 5], batch_size=3)    &gt;&gt;&gt; next(generator)    [1, 2, 3]    '''    current_batch = []    for item in items:        current_batch.append(item)        if len(current_batch) == batch_size:            yield current_batch            current_batch = []    yield current_batch # Bad - never use list comprehension for its side effects[print(x) for x in some_list]# Goodfor x in some_list:    print(x)4. Filtering a List # Bad - Don't delete items when iterating through the lista = [3, 4, 5]for i in a:    if i &gt; 4:        a.remove(i)# Don't make multiple passes through the listwhile i in a:    a.remove(i)# Good# comprehensions create a new list objectfiltered_values = [value for value in some_list if value &gt; 4]# generators don't create another list filtered_values = (value for value in some_list if value &gt; 4)5. Modifying the values in a list # Bada = [3, 4, 5]b = a # a,b refer to same list objectfor i in range(len(a)):    a[i] += 3 # changing a will also change b# Good - create a new list objecta = [3, 4, 5]b = aa = [i+3 for i in a] # does not change b6. Read from a file # Badf = open(\"file.txt\")a = f.read()print(a)f.close()# Good - with open automatically closes the filewith open(\"file.txt\") as f:    for line in f:        print(line)7. Line Continuations # Bad - using \"\\\" might break if there is space afterwards\"\\ \"some_string = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\    aaaaaaaaaaaaaaaaaaaa\"# Good - open (, [, { will indicate the python interpreter to read until ), ], } closessome_string = (    \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"    \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\")","categories": [],
        "tags": ["python"],
        "url": "https://json9512.github.io/blog/python/"
      },{
        "title": "Python Advanced Topic",
        "excerpt":"파이썬 개발자라면 알아야 할 고오급 정보들 ! 아래 출처에서 부분적으로 의역한 포스트 출처:   Real Python  Official Doc  Stackify  Programiz목차   Memory Management  Global Interpreter Lock  All is One, One is allMemory Management 출처: Real Python, Stackify 컴퓨터에서 프로그램이 실행될 때, OS에서 프로그램을 위해 할당하는 메모리는 fixed하다. 프로그램은 정해진 메모리 관리 알고리즘에 따라 주어진 메모리를 관리한다. CPython 파이썬은 CPython이 베이스이다. CPython은 C로 만들어졌다. CPython 외에도 다른 interpreter/compiler는 다음과 같다:   IronPython - .NET  Jython - JAVA  MicroPython - 마이크로 컨트롤러기본적으로 CPython이 하는 일은 다음과 같다.   .py에 적힌 코드를 bytecode로 compile 한다  .pyc (컴파일 된 코드)를 파이썬 가상 환경에서 실행한다파이썬의 object (int, list, etc)는 어떻게 관리가 될까? 파이썬에서는 모든 object가 PyObject로 표현된다. PyObject는 C struct 이고:   ob_refcnt: 이 object를 가르키고 있는 변수 갯수  ob_type: 이 object의 type (int, list, etc)와 같은 특성을 가지고 있다 PyObject의 ob_refcnt 특성이 0이 될 때, 가비지 콜렉터는 PyObject가 차지하고 있던 메모리를 다시 free 시킬 수 있다. 주의: 만약 object가 자기 자신을 reference 한다면? class Foo(object):    pass# 'Foo' will be allocated in some place in the memorya = Foo() # ob_refcnt of Foo = 1# This will increment the ob_refcnta.obj = a # ob_refcnt of Foo = 2# Will not deallocate the memory occupied by 'a' # because the ob_refcnt is never 0del a # ob_refcnt of Foo = 1# this is a 'reference cycle'위와 같이 reference cycle이 생길 경우, Foo 가 차지하고 있는 메모리는 절대 비워지지 않는다. 파이썬에서는 이것을 해결하고자 Generation garbage collection 도 같이 사용한다. Generation Garbage Collection 2 가지 특징이 있다:   가비지 콜렉터가 메모리 내에 모든 object를 track 한다. 이후 collection process에서 살아남은 object들은 다음 generation으로 넘어간다. 파이썬의 garbage collection process의 generation은 총 3번이다.  각 generation 마다 threshold 가 있다. 이 threshold는 가비지 콜렉터가 track하는 object의 최대 갯수이다. 만약이 threshold를 넘어서게 되면, collection process가 시작되고 살아남은 object만 다음 세대로 넘어간다. 이 threshold는 개발자가 직접 바꿀 수 있다. Instagram은 실제로 이 기능을 해제하여 서버를 10%가량 더 효율적으로 만들었다.Global Interpreter Lock (GIL) 메모리는 공유제이다. 메모리를 보호하는 알고리즘이 없다면 여러 프로세스가 같은 메모리 값을 읽고, 쓰고, 지우고 할 수 있다. 즉, race condition과 같은 문제점들이 발현한다. 이를 해결하는 방법은 여러가지인데 파이썬은 Global Interpreter Lock (GIL) 을 사용함으로써 메모리의 데이터를 보호한다. 파이썬의 GIL은 단일 Thread에게만 메모리 권한을 준다. CPython Memory Management  위 그림과 같이 OS가 할당한 메모리 중 Python은 메모리를 크게 Object를 위한 메모리와 그 외 메모리로 분할한다. 그리고 Object를 위한 메모리에 CPython의 object allocator가 할당된다. 이는 새 object 가 메모리에 할당되거나 삭제될 때마다 실행된다.  CPython 메모리 관리에는 크게 3 가지가 존재한다.   Arenas          가장 큰 메모리 덩어리      OS가 메모리를 읽을 때 사용하는 블록과 연결된다      Python은 Arena의 크기를 256 KB로 추정한다      eg. 256KB - 256KB - 256KB 단위로 OS가 읽는다      사실 뭔 소린지 잘 모르겠다 하하        Pool          가상 메모리      4 KB      더 작은 메모리 블록으로 이루어져 있다      Pool내에 모든 블록은 같은 “size class”다        Blocks          8 bit 단위로 나뉘어진 “size class” 가 있다      eg. 데이터가 7 bytes 면 “size class”는 8 (bytes) 이다, 데이터가 10 bytes 면 “size class”는 16 (bytes) 이다.      Pools   같은 size class의 블록들로 구성된다  같은 size class를 담고 있는 pool들과 double-linked list를 형성한다  3 가지의 상태를 가진다:          used - 데이터를 저장할 블록을 가지고 있을 때      full - 모든 블록이 데이터로 가득 차 있을 때      empty - 데이터가 존재하지 않고 , 아무 size class로 구성된 블록들을 만들 수 있을 때        usedpools 은 새로운 객체가 저장 될 수 있는 block이 있는 모든 pool 리스트다 (저장되는 객체의 size는 block의 size class가 수용 가능 해야한다). 수용 가능한 블록을 찾을때 usedpools 리스트에서 먼저 찾는다.  freepools 는 모든 empty 상태의 pool을 기록한 리스트다.  full에서 특정 블록을 free 할 경우, 그 pool의 상태는 used로 바뀐다. Blocks   3가지 상태가 있다:          untouched - 할당되지 않은 메모리      free - 할당 됐으나 CPython이 free 한 메모리      allocated - 할당 된 메모리        위 그림과 같이, 각 pool 에는 자기 pool 내에 free 블록을 가르키는 포인터가 있다  free 블록이 꼭 연속성을 가져야 하는 것은 아니다:    free 블록을 가르키는 포인터는 free 블록들을 탐색할 수 있는 single linked list다  만약 필요한 메모리의 사이즈가 free 블록의 사이즈보다 클 경우, untouched 블록들을 사용한다Arena   여러 개의 pool로 구성되어 있다  double-linked 리스트다  Arena내에 할당 가능한 pool의 갯수를 기준으로 정렬이 되어있다 (오름차순)  오름차순인 이유?          CPython이 특정 메모리를 free한다는 것은 OS에게 그 메모리를 돌려준다는 뜻이 아니다. CPython은 메모리를 free한 이후에도 그 메모리를 계속 사용한다.  즉 Arena를 더 적게 사용하는 것이 전체적인 프로그램의 메모리를 더 적게 사용하는 것이다.**      Global Interpreter Lock source: Real Python   간단히 말하면 mutex (lock) 이다. 단 하나의 thread만 Python Interpreter를 쓸 수 있게 하는 장치다  CPU를 이용한 multi threaded 앱에서는 bottleneck이 될 수 있다  아무리 내 코드가 multi threaded용으로 짜여졌다고 하더라도, 실제로는 single threaded 앱처럼 실행이 된다왜 도입 됐는가?   일단 Python GIL은 thread라는 개념이 존재하기 전에 도입됐다  파이썬 메모리 관리 특성 상 object에 대한 race condition이 생길 수 있는데, 이를 방지 하려면 일종의 lock이 필요했다  object 단위로 lock을 도입하기에는 deadlock 문제가 생기고 성능이 저하 될 수 있어서 GIL을 도입했다.  가장 간단하고 효과적이었기 때문이다Parallel program은 파이썬으로 불가능한가?   Multi-threaded 말고 multi-process 방법으로 접근하면 앱을 parallel하게 짤 수 있다  혹은 다른 python interpreter를 사용하면 된다. GIL은 CPython 에만 존재하기 때문이다 (CPython이 Python의 베이스다)All is One, One is all   전체는 하나, 하나는 전체 뜻하지 않게 생각난 불교의 무진연기다. 파이썬에서 모든 것은 객체다. 변수, 함수, 클래스 등등 다 객체다. PyObject라는 객체로 모든 것이 관리되기 때문에 이것을 이해하면 신기한 방법으로 코드를 짤 수 있다. 몇 가지만 알아보자면:   First class function: 파이썬은 변수, 클래스뿐만 아니라 함수를 다른 함수의 리턴 값 혹은 인자 (parameter) 로 쓸 수 있다. 이는 함수가 객체이기 때문.  Closure function: 함수(A) 내의 함수(B)가 함수(A)가 가진 변수를 저장하고 사용하는 함수(B)말로 표현하기 어렵다. 코드로 보자. First class function import sysinputs = sys.stdin.readlineK, V = map(int, input().split(' '))위 코드를 살펴보면 함수 sys.stdin.readline을 변수 inputs에 저장한 뒤, map 함수에서 inputs()로 실행 시키는 것을 볼 수 있다. 이런 방식으로 변수에 함수를 저장하는 것이 first class function의 특징이라고 볼 수 있다. 또 다른 예를 들면, map 함수에 인자로 int, input().split(' ') 이 있는 것을 볼 수 있다. 여기서 int 인자는 사실 함수다. 즉, 위의 코드를 실행하면 sys.stdin.readline 함수로 읽은 유저의 입력 값을 ' '로 나누어서 array화 시킨 뒤 map 함수를 이용해 array안에 모든 element를 int() 화 시켜주는 코드다. 이런식으로 함수를 변수처럼 인자로도 주고, 변수에도 저장하고, 다른 함수에서 리턴 값으로도 주고 할 수 있는 것이 바로 first class function인 것이다. 이 모든 것이 가능한 이유는? 파이썬에서 모든 것은 객체기 때문이다. Closure function def multiply_by(n):    def multiplier(x):        return x * n        return multipliertimes3 = multiply_by(3)print(times3(9)) # 27위 코드를 잘 보면 방금전에 배운 First class function의 특징을 잘 이용하고 있다. 일단 multiplier() 함수를 먼저 확인해 보자, 이 함수는 x 와 n을 곱한 값을 리턴해 주는 함수다. x는 이 함수의 인자 (parameter)로 받는다. 그럼 n은? n은 보다시피 multiplier 함수를 감싸고 있는 multiply_by 함수의 인자다. 즉, multiplier 함수는 본 함수의 인자 x 와 multiply_by 함수의 인자 n을 사용하는 함수다. 그리고 multiply_by 함수는 multiplier 함수를 리턴한다. first class function 특징이다. 밑에 코드를 보자. times3 = multiply_by(3) 이 코드가 실행이 되면 3 은 누구의 인자로 가게 될까? multiply_by의 인자가 3이 된다. 곧 n 은 3이 된다. 이후 times3(9) 이라는 코드가 있다. 이걸 풀어보면 multiplier(x=9)이라는 코드가 되는 것이다. 그러면 당연히 값은 n * x니까 3 * 9 = 27 가 된다. Closure 함수의 특징은 주어진 것을 기억할 수 있는 것이다. 심지어 multiply_by 함수를 지워도 times3 함수는 주어진 3의 값을 기억하고 쓸 수 있다. def multiply_by(n):    def multiplier(x):        return x * n        return multipliertimes3 = multiply_by(3)del multiply_byprint(times3(9)) # 27print(multiply_by(3)) # NameError: name 'multiply_by' is not defined정리   Closure 함수는 아래와 같은 특징이 있다:          함수(A)안에 함수(B)가 있고      함수(B)는 함수(A)가 쓸 수 있는 변수, 객체, 클라스를 사용하고      함수(A)가 함수(B)를 리턴해야한다        언제 쓰는 것 일까?          OOP를 구현하기 위해 사용하기도 하고      특정 함수의 구조를 숨기기 위해서도 사용하며      Python Decorator 함수에서도 사용된다        무조건적으로 함수(A)에 주어진 값을 숨길 수 있나?          아니다                &gt;&gt;&gt; times3.__closure__[0].cell_contents  3                    위와 같이 보고자 하면 closure 함수가 무엇을 기억하고 있는지 볼 수는 있다.      ","categories": [],
        "tags": ["python"],
        "url": "https://json9512.github.io/blog/python-advanced/"
      },{
        "title": "취준 로그 - 1",
        "excerpt":"취준은 어렵다. 너무 심심하기도 하고 할 것도 많기도 해서 어렵다. 대학교 다닐 때 분명 열심히 했는데 왜 알고리즘만 제대로 공부를 안 했을까 . . . 현재까지 대략 6번 지원한거 같다.   호주 구글 인턴: 이땐 코테가 뭔지도 몰라서 코테 문제 입출력 받는 것만 짜는데 30분 걸렸다  카카오 공채, 쿠팡 공채, 토스 공채, 네이버 공채: 막 학기 중에 한국은 어떻게 나오나 하고 지원했다. 물론 다 코테 탈락  네이버 상시: 요건 진행형앞으로 아직은 객관적으로 난 실력이 부족해서 공부를 좀 더 해야한다. 도전하는 기업마다 포스트를 작성해 보려고 한다. ","categories": [],
        "tags": ["취준"],
        "url": "https://json9512.github.io/blog/%EC%B7%A8%EC%A4%80-1/"
      },{
        "title": "호주 스타트업 캡스톤 후기",
        "excerpt":"이 글은 학과 마지막 1년 동안 호주 스타트업 Bidhive 와 CV builder 프로젝트를 한 후기다. Bidhive는 호주 B2B 시장에서 기업들의 입찰 매니지먼트 서비스를 제공하는 기업이다. 기업들이 입찰하는 과정을 좀 더 효율적으로 관리할 수 있게 도와주는 플랫폼을 서비스하고 있고 실제로 호주를 비롯해 유럽권과 미국권에서 펀딩을 추진하고 있다.알만한 고객으로는 세계 최대 해운회사 덴마크의 머스크 라인이 있다. Bidhive 측에서 요구한 것은 간단히 말하면 이력서 매니지먼트 플랫폼이었다. 과정 시작부터 코로나 19와 겹치면서 모든 미팅이 줌을 통해 진행되었다. 실제로 프로젝트가 끝날 때까지 단 한 번도 Bidhive 팀을 만나지 못 했다. 처음 Bidhive가 제시한 요구사항은 상당히 high-level에서의 플랫폼을 이야기 하고 있었고 첫 미팅을 하고 나서 Bidhive 역시 정확히 무엇을 원하는지 모른다는 것을 파악했다. 이후 나를 포함한 학생 4인의 개발팀과 Bidhive의 CEO, CXO와 매주 줌 미팅을 진행하며 서비스의 기능이 무엇인지부터 시작해 버튼의 모양까지 하나씩 다 이야기 해 나가면서 brainstorming을 했다.첫 2주 정도는 기업간의 입찰 시스템에 대해서 무지했던 우리 개발팀이 입찰 시스템에 대해 공부하고, Bidhive 플랫폼을 직접 local development 버전으로 실행 해 보는데 할애했다. 그 후로는 계속된 줌 미팅으로 생각들을 정리하기 시작했으며, 정리한 내용을 Slack, Mirro, Asana, Trello, Google Drive 등에 저장하기 시작했다. 전반적인 분위기는 상당히 좋았다. 시간이 지날수록 1년안에 개발하지 못하는 수준의 기능들에 대해 이야기 하기 시작했으며, 최소한의 서비스 기능들을 user story화 시켜서 엑셀로 정리를 하기 시작했다. 개발 스택   프론트: Reacth with TypeScript  백엔드: Django (Python)  DB: PostgreSQL사실 이때까지만 해도 CI/CD나 Docker, AWS, 분산 클라우드 서비스 등 전반적으로 웹 앱을 설계하는 능력이 많이 부족했다. (물론 지금도 부족하다.) 더군다나 이런 내가 팀 내 리드 개발자였다. 너무 부족했던 나 자신을 돌아보는 계기가 되기도 했다. 아무튼, 위 기술스택은 기존 Bidhive 플랫폼과 똑같았고 이유는 Bidhive 측이 UI 적으로나 기능적으로나 자기들의 기존 플랫폼과 연동되고 일관성있게 만들고 싶다고 했기 때문이다. (지금 와서 생각해보면 사실 언어/프레임워크는 상관이 없었다.) 개발 스택 정하고, 기본 뼈대를 구축하고, 전체 팀이 개발을 시작한지 2~3주만에 1학기가 끝났다. 이 시점에 우리는 아무것도 없는 백엔드와 DB, 그리고 프론트엔드는 Navbar만 있는 페이지 4개가 끝이었다. 방학 1달 동안에는 캡스톤 미팅을 하지 않았고 그 기간동안 머신러닝을 이용해 기업이 원했던 이력서 추천 기능의 개념을 증명하는 간단한 모델을 만들었다. 짧은 프레젠테이션으로 만들어서 발표를 5분 가량 했는데 Bidhive가 마음에 들어했고 이 발표를 했던게 추후에 영입 제의를 한 결정적 이유이지 않을까 생각한다. 이후 2학기가 시작되자마자 개발을 재개했고 이때까지도 MVP에 정확히 어떤 기능들을 집어 넣을지에 대한 의견을 조율하고 있었다. 이때부터 리드 개발자로서 시간이 없다는 것을 인지하고 매일 적어도 2 시간씩 개발에 매진했다. 2학기를 3주 정도 남기고서야 Bidhive와 MVP를 조율할 수 있었고 이전까지 부분적으로 구현 시켜놨던 몇 몇개의 기능들을 지우고 수정하는 시행착오를 겪었다. 이때 테스트 코드의 중요성과 초반 설계 작업이 얼마나 중요한지 깨달았다. 지속된 에러로 밤을 새는 것은 기본이고 코드 역시 날이 갈수록 난장판이 되어가고 있었다. 설상가상으로 학기 말 여러 과제들이 겹쳐서 팀원들이 다른 과제를 하느라 미팅을 이탈하는 빈도가 늘어났고 개발이 더뎌지게 되었다. 하지만 리드 개발자로서 MVP의 요구사항을 꼭 성공 시키겠다는 마음을 먹었고 팀원에게 앞으로 구현해야 할 기능들을 할당해주고 나 역시 Refactoring과 MVP에 핵심이 되는 기능을 구현하기 시작했다. 결과 결과적으로 MVP에서 약속한 기능들을 모두 개발 할 수 있었다. 하지만 1학기 초창기에 서비스에 대한 구축을 시작했을 때 의논했던, 인공지능과 본 플랫폼과의 호환 같은 핵심 기능들은 빠져 있는 상태였다. Bidhive가 실질적으로 만들고자 한 플랫폼은 이것 (Demo)이지만, 우리가 1년 동안 개발 했던 것은 저 프로젝트의 뼈대라고 볼 수 있는 CV를 직접적으로 만드는 기능이었다. 이하 개발한 MVP의 스크린 샷: 유저 이력서 페이지  기업 이력서 페이지  검색 페이지  결론 1년 동안 고생한 만큼 성적도 성과도 좋았지만 개발자로서 만족 할 만한 수준의 서비스는 아니었다. 일단 초기 설계 과정부터 제대로 된 개발 디자인:   서버는 RESTful 할 건지          완벽한 RESTful 모델이 아님        유저 인증/인가는 어떻게 할 건지          django의 기본 유저 인증/인가 사용 (인가에 버그가 있어서 완벽하지 않음)        Database indexing은 어떤 방식으로 시도 할 건지          고려하지 않음        프론트엔드의 state 관리는 어떻게 할 건지          jotai 사용        코드 Quality는 어떤 방식으로 관리 할 건지          개인에게 맡기고 전체적인 것은 고려하지 않음      등을 하지 못 했던 것과 테스트 코드의 부재 및 CI/CD pipeline의 부재가 아쉽다. 또한 개발 막바지에 기능 개발을 분담했는데 이 과정에서 개발을 많이 안해본 팀원에게 비교적 중요한 유저 인증을 맡긴다던지, 조금 더 꼼꼼하게 팀원들의 코드를 리뷰하지 않았던 것이 리드 개발자로서 아쉬움이 많이 남는다. 코로나19와 너무 늦게 확립된 MVP 기능들과 개개인의 여러가지 악재들이 겹친 상황에서도 끝까지 개발을 완수한 것이 의미가 있었던 프로젝트였다. 여담   B2B 시장도 일반인들이 쉽게 접하기 어렵지만 상당히 규모가 크고 도전해 볼 만한 시장이라는 것을 알게 되었다.  원격 근무, 개발, 미팅 만으로 이런 프로젝트가 가능하다.  스타트업은 아무나 하는 것이 아니다  방학기간 동안 만든 추천 모델은 NLP를 기반으로 search keyword를 통해 유저의 이력서를 추천해 주는 시스템이다. 기능적으로는 특정 입찰에서 추진하는 프로젝트에 알맞는 인원을 찾고자 할 때, 가장 잘 어울리는 인원의 이력서를 결과 창 가장 먼저 배치하기 위함이었다.","categories": [],
        "tags": ["캡스톤","호주","스타트업"],
        "url": "https://json9512.github.io/blog/%EC%BA%A1%EC%8A%A4%ED%86%A4/"
      },{
        "title": "[알고리즘] Dijkstra's Shortest Path",
        "excerpt":"출처: GeeksforGeeks, Baeldung, cppsecrets 유명한 다익스트라의 최단 거리 찾기 알고리즘 Prim’s Minimum Spanning Tree 알고리즘과 유사하다. 그리디 알고리즘이다. 다른점:   다익스트라 알고리즘은 최단거리를, 프림의 알고리즘은 Minimum Spanning Tree를 찾는 알고리즘이다  다익스트라 알고리즘은 undirected, directed graph 모두 적용이 되지만 프림의 알고리즘은 undirected graph에만 적용된다  다익스트라 알고리즘은 edge의 weight가 단 하나라도 음수(negative)면 최단 거리를 찾지 못 할수도 있다간단한 예를 들자면, 다익스트라 알고리즘은 가장 적은 시간/연료로 A 포인트에서 B 포인트까지 길을 찾는 것이고 프림의 알고리즘은 가장 적은 시간/재료로 여러개의 포인트가 서로 연결 되도록 (사이클 없이) 도로를 까는 것이다. 방법   최단 거리 경로를 저장하는 set를 만든다. (empty set)  모든 vertices 간의 거리 값을 지정한다. 시작점을 제외한 모든 vertices 거리 값은 무한대가 된다. 시작점은 0으로 만든다  모든 vertices가 최단 거리 경로를 저장하는 set에 들어올때까지 이하 반복 한다:          set에 포함되지 않는 vertices 중 최단 거리를 가지고 있는 vertex u를 고른다      set에 포함 시킨다      vertex u 와 인접한 모든 vertices의 거리 값을 갱신한다.      Python def createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = createGraph()# set starting pointinitial = 'D'# keeps track of pathspath = {}adj_node = {}# keeps track of nodes yet to visitqueue = []# create adjacency graph with distance values # intialized as infinity # except the initial (starting) node for node in graph:    path[node] = float('inf')    adj_node[node] = None    queue.append(node)path[initial] = 0# while queuewhile queue:    # for visualization    '''    print(\"Graph: \\n\", graph)    print(\"Path: \\n\", path)    print(\"Adj_nodes: \\n\", adj_node)    print(\"Queue (nodes to visit): \\n\", queue)    '''    # find the node with the     # minimum distance value    min_key = queue[0]    min_val = path[min_key]    for n in range(1, len(queue)):        if path[queue[n]] &lt; min_val:            min_key = queue[n]            min_val = path[min_key]    # update the current node as the node with the    # minimum distance    current = min_key    # remove the node from 'to visit' queue    queue.remove(min_key)    # iterate through the nodes    # Update the distance value using the current node    for i in graph[current]:        alternate = graph[current][i] + path[current]                if path[i] &gt; alternate:            path[i] = alternate            adj_node[i] = currentdestination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')# prints:# H &lt;- J &lt;- E &lt;- B &lt;- A &lt;- D &lt;-자세히 위의 코드를 조금 더 자세히 살펴보자 def create_graph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = create_graph()이 코드를 실행 하면 아래와 같은 그래프가 형성된다  우리의 목적은 ‘D’ 에서 ‘H’ 까지 최단 거리를 찾는 것 이다. # set starting pointinitial = 'D'# keeps track of pathspath = {}adj_node = {}# keeps track of nodes yet to visitqueue = []# create adjacency graph with distance values # intialized as infinity # except the initial (starting) node for node in graph:    path[node] = float('inf')    adj_node[node] = None    queue.append(node)path[initial] = 0시작 노드 initial을 지정 해주고 추후에 사용할 path 와 adj_node를 선언해준다 path는 시작 노드에서 특정 노드까지 최단 거리 값을 저장 시키기 위한 것이고 adj_node는 특정 노드의 최단 거리 값을 계산했을때 사용한 인접한 노드를 저장해 주는 것이다. queue는 현재 최단 거리 값을 계산 해야 할 노드들을 저장한 리스트다. 이후 for 문에서 그래프 속 각 노드들의 최단 거리 값을 inf로 선언해주고 adj_node 값도 초기화 시켜준 뒤 queue에 저장한다 path[initial] = 0 로 시작 노드를 지정해준다 # while queuewhile queue:    # find the node with the     # minimum distance value    min_key = queue[0]    min_val = path[min_key]    for n in range(1, len(queue)):        if path[queue[n]] &lt; min_val:            min_key = queue[n]            min_val = path[min_key]    # update the current node as the node with the    # minimum distance    current = min_key    # remove the node from 'to visit' queue    queue.remove(min_key)이후 queue에 노드가 없어질때가지 while문을 돌린다. min_key - 최단 거리 값을 가지고 있는 노드 min_val - 최단 거리 값 min_key 와 min_val을 queue의 첫 번째 노드로 선언해준 뒤 queue에 남아 있는 나머지 노드들과 비교를 하며 가장 거리 값이 낮은 노드를 찾는다 이후 찾은 노드를 current에 저장해주고 queue에서 해당 노드를 지운다     # iterate through the nodes    # Update the distance value using the current node    for i in graph[current]:        alternate = graph[current][i] + path[current]                if path[i] &gt; alternate:            path[i] = alternate            adj_node[i] = current이후 현 노드 (최단 거리 값을 가진)의 인접 노드들을 for문을 돌린다 alternate - 현재 노드와 인접한 노드의 거리 값 + 현재 노드까지의 최단 거리 예를 들자면, current가 A면 인접 노드는 B, C, D 가 되고, 위에 for문이 각각의 인접 노드의 거리 값을 현재 노드 A의 최단 거리 값과 더 한다 (alternate). 즉 A를 이용해서 각 인접 노드로 가는 거리 값이다 이 alternate 값과 현재 인접 노드의 거리값 path[i]를 비교해서 alternate가 더 작을 경우, 인접노드의 최단 거리 값(path[i])을 alternate로 바꾸고 adj_node에 현재 노드 (current)를 저장해 준다. 예를 들면 A의 인접노드 B를 A를 통해서 가게 됐을때 그 값이 현재 B의 최단 거리 값 보다 작으면, B의 값을 바꿔주고 A를 사용했다고 adj_node에 명시해 준다 여기까지만 코드를 실행 시키면 다익스트라 알고리즘을 이용해 시작 노드 D에서 나머지 노드들까지 가는 최단 거리가 계산된다. destination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')위의 코드를 실행 시키면 destination에 저장된 목적지 노드까지의 경로가 나온다. 위 코드는 while 문만 간단히 설명하자면 destination = adj_node[destination] 로 while문이 돌때마다 현재 노드(destination)를 현재 노드의 최단 거리 값을 계산 할 때 사용했던 인접 노드(adj_node[destination])로 바꿔준다 이후 if문으로 destination 이 None일때 while문을 종료시키면 시작 노드 initial에서 목적지 노드 destination까지의 최단 경로를 알 수 있다. 실제로 확인을 해보면 D에서 A를 통해 H를 가는 경로와 F를 통해 H로 가는 경로 값을 비교해보면 A가는 경로가 최단 경로인 것을 알 수 있다. A를 통할 경우: 10 + 1 + 5 + 7 + 2 = 25 F를 통할 경우: 7 + 9 + 4 + 7 + 2 = 29 위 알고리즘의 Time Complexity는 O(V^2)이다. 하지만 우선 순위 큐를 사용하면 시간 복잡도를 O(V + E log V) 까지 줄일 수 있다. 관련 포스트 Dijkstra 최단 경로 알고리즘을 사용한 문제 백준 다익스트라로 분류된 문제 [프로그래머스] 배달 [프로그래머스] 가장 먼 노드 요런 문제들을 풀려면 O(V^2)의 시간 복잡도로는 풀 수가 없다. ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dijkstra-shortest-path/"
      },{
        "title": "Sonar to Image 연구 프로젝트 후기",
        "excerpt":"2019년 11월부터 2020년 2월까지 호주 QUT 대학교에서 진행한 10주 연구 프로젝트 ‘Sonar to Image’에 관한 후기다. 깃허브 대학교 2학년 마치고 여름 방학 동안 10주 연구 프로젝트를 한 적이 있다. 연구 팀은 지도 교수 2명 학생 2명 이렇게 4인이었고 사실상 연구 경험을 ‘맛 보기’ 하는 프로젝트였다. 연구 내용 연구의 핵심은 가상 공간 (VR)에 해저 환경을 딥러닝을 이용해 구현하는 것이었다. 임의의 환경을 만드는 것이 아닌 실존하는 해저 지형을 딥러닝이 만들어내는 것이었다. 궁극적인 목표는 잠수함이 해저를 탐험 할 때 sonar로 지형 지물의 존재여부를 알게 되는데, 이때 가상의 스크린에 바로 지형이 펄쳐지도록 하는 것이 이 연구의 마지막 단계라고 했다. 이 부분은 크게 2가지로 나뉘어졌었다.   수집된 sonar와 제한적인 image를 가지고 딥러닝 모델을 구현하는 것  딥러닝이 생성한 데이터를 (Unity나 Unreal) VR 환경에 구축하는 것여기서 나는 1번을 하게 되었다. 지도 교수님의 도움으로 어떤 모델을 만들어야 할지 알아보다가 GAN 모델로 정하게 되었다. GAN 이란 Generative Adversarial Network의 약자인데, 쉽게 말하면 두 개의 딥러닝 네트워크가 서로 상호작용하며 주어진 학습 데이터를 바탕으로 새로운 데이터를 만들어 낼 수 있는 모델이다. 구체적인 내용은 모델 학습에서 설명하겠다. 연구 일지 딥러닝, 머신러닝으로 모델을 만들 때 크게 3 가지가 중요하다고 볼 수 있는데:   Data preprocessing 데이터 전처리  Model training 모델 학습  Model evaluation 모델 평가이 중 데이터 전처리 과정이 모델의 능력을 결정한다고 볼 수 있다. 아무리 모델이 뛰어나도 쓰레기 데이터가 들어가면 쓰레기 데이터가 나온다. 데이터 전처리 과정 일단 데이터는 ROS 형식으로 저장이 되어 있었고, 거기서 유용한 데이터를 찾고 엑셀화 시키는 것에만 1주~2주 정도 소모됐다. 내게 주어진 데이터는:   기계가 전 방위 1~2초 단위로 수집한 sonar 데이터와  기계 하단부 카메라에서 수집한 해저 땅? 사진들 300백 장 정도가 다였다.일단 사진 데이터가 하단부 밖에 촬영을 못했기 때문에 실제로 모델을 학습 시킬 때 사용할 수 있었던 데이터는 sonar가 하단부 카메라 각 안에 들어올때 밖에 없었다. 이후 카메라 각 안에 들어오는 sonar 수치를 binary map으로 찍어서 이미지화 시켰다. 그리고 기존 사진 300백 장도 살펴보니 Spotlight effect (사진 중앙만 밝은 현상)이 심해서 이걸 없애는 알고리즘을 찾느라 또 시간을 많이 보냈다. CLAHE라는 알고리즘으로 Spotlight effect를 지운 후 마침내 모델 학습을 위한 [sonar binary map, 카메라가 수집한 사진] 을 만들었다. 모델 학습 GAN 은 Generator, Discriminator라는 2개의 네트워크가 서로 상호작용한다. 간단히 설명하면 Generator는 주어진 X 정보를 활용해 Y 정보를 제작한다, 이후 Discriminator는 제작된 Y가 실제 Y인지 분별하는 역할을 한다. Generator는 궁극적으로 Discriminator를 속일 수 있을 만한 데이터를 만들게 되고, Generator가 만든 Y 데이터가 모델이 만들어낸 데이터라고 보면 된다. 즉 이 연구에서는 Generator 에게 sonar binary map을 주고 카메라가 수집한 사진 같은 데이터를 만들어내라고 하는 것이다. 그러면 Discriminator는 실제 카메라가 수집한 사진과 Generator가 만든 카메라가 수집한 사진을 비교하며 유사도 점수를 준다. 모델 자체는 pix2pix 모델을 조금 더 경량화 시켜서 사용했고 완성도는 딥러닝에 대한 지식이 없을 때 만든거라 뛰어나지 않다. 모델 평가 확실히 처음 딥러닝을 접할 때여서 Overfitting이 뭔지 어떻게 해결하는지 잘 몰랐다. 즉, 모델 자체의 완성도는 좋지 않다. 그냥 이런 모델을 시도해 봤다 정도로 보면 되겠다. 결과 사진 한장을 보고 어떤 사진이 모델이 만들어낸 것인지 분별을 해보자.  실제 사진과 모델이 만든 사진에 차이가 보이긴 보인다.처음 모델이 사진을 만들어 냈을 때 상당히 신기했다.  주어진 sonar binary map 이 제일 윗 줄 Generator가 만들어낸 카메라가 수집한 사진이 중간 줄 실제 카메라가 수집한 사진이 마지막 줄이다. 위 사진은 대조할 카메라가 수집한 사진이 있는 sonar 각에 대한 학습 결과고 실제로 저 모델을 사용해서 카메라가 수집한 사진이 없는 sonar 각 까지 모델로 만들어서 이어보면 상당히 흥미로운 결과를 볼 수 있다. 궁금하면 여기 에 있다 처음 도전한 딥러닝이었고 데이터 전처리, 모델 학습 및 평가 과정이 상당히 부족한 프로젝트였지만 이 계기를 통해 나는 인공지능에 대해 좀 더 관심을 가지게 되었다. 그리고 이후 머신러닝/딥러닝 과목을 이수하게 되었다. ","categories": [],
        "tags": ["호주","GAN","연구"],
        "url": "https://json9512.github.io/blog/Sonar-to-Image-%EC%97%B0%EA%B5%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0/"
      },{
        "title": "[네트워크] OSI 7 Layers",
        "excerpt":"출처: 위키피디아, 양햄찌님의 블로그 Open Systems Interconnection model (OSI) 7 계층에 대해 알아보자       OSI 7 계층은 참조 모델이다. 컴퓨터 또는 전자 통신 장비끼리의 통신 과정을 위한 모델이다.         OSI 7 계층이 만들어진 이유는 장비에 상관없이 모든 컴퓨터/전자기기 간 통신 과정에 기준을 세우기 위함이다.         국제표준화 기구 (ISO) 에서 1984년에 만들었다.         통신이 일어나는 과정을 단계 별로 볼 수 있다.         각 Layer는 독립적이다. 즉 Physical Layer에서 문제가 생기면 Physical Layer와 연관 있는 장비만 손보면 된다.         상하구조를 가지고 있다. Layer 7 이 작동하려면 Layer 1 ~ 6 까지 문제가 없어야 한다.         유지관리가 수월하고, 범용적이다   7 Layer (밑에서부터 위로):   Physical Layer  Data Link Layer  Network Layer  Transport Layer  Session Layer  Presentation Layer  Application Layer앞 글자만 따면 P - D - N - T - S - P - A   People Don’t Spa 로 외웠다 Physical Layer   하위층  Protocol Data Unit = bit  물리적 매체 (Wire)등을 통해 bit를 전송한다  물리적 장치와 인터페이스가 전송을 위해 필요한 기능과 처리절차를 규정하고 있다출처: studytonight 하는 것   Representation of Bits - 0 과 1로 이루어진 비트가 어떻게 encoding (시그널로 변환) 될 건지를 정함  Data rate - 보내는 데이터 레이트를 정함. 보통 bits per second 단위  Synchronization - 비트 단위로 transmitter (보내는 쪽)와 receiver (받는 쪽)의 동기화 시킴  Interface - 기기와 전송 매체간 전송 인터페이스를 정함. (Ethernet, Radio waves)  Line configuration - 기기와 전송매체를 연결 시킴: point-to-point configuration, multi point configuration  Topologies - 기기는 다음과 같은 구성으로 연결이 돼야한다: Mesh, Star, ring, bus  Transmission Modes - 기기간 전송 방향성을 정함: Simplex(one signal is transmitted in one direction), Half-Duplex (data is transmitted in both direction, not at the same time), Full-Duplex (data is transmitted both direction simultaneously)  Broadband, Baseband 전송을 담당함Data Link Layer   하위층  PDU = Frame  노드와 노드 사이의 데이터 전달  단순히 bit를 전하는 물리 계층에 신뢰성을 더하기 위한 흐름제어 및 오류제어 기능  LLC, MAC 두 개의 sub layer로 구성Network Layer   하위층  PDU = Packet  송신 측에서 최종 목적지까지 packet 전달  송수신 측의 논리주소 지정 및 패킷이 최종 목적지에 도달하도록 경로를 배정하는 라우팅 기능  데이터 링크의 물리주소는 패킷이 시스템으로 이동할 때마다 변경하지만, 네트워크 주소는 목적지까지 변하지 않음Transport Layer   하위층  PDU = Segment  네트워크 계층에서 패킷을 종단까지 전달한다면 (네트워크 주소), Transport Layer는 종단 내에서 최종 수신 프로세스로의 전달 (포트 주소)을 담당  분할/재조립, 연결/흐름제어, 오류제어Session Layer   상위층  PDU = message  통신하는 프로세스 사이의 대화제어 및 동기화를 담당Presentation Layer   상위층  PDU = message  데이터의 변환, 압축, 암호화를 담당Application Layer   상위층  PDU = message  사용자에게 서비스 제공 역할. SMTP, FTP, HTTP등 사용자가 원하는 최종 목표에 해당","categories": [],
        "tags": ["Network"],
        "url": "https://json9512.github.io/blog/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI-7-Layer/"
      },{
        "title": "[알고리즘] Dijkstra's Shortest Path 2",
        "excerpt":"출처: greenhelix 푸푸릇님의 post, HackerEarth 전 포스트에서 시간 복잡도 O(V^2)의 알고리즘을 살펴보았다. 이번 포스트에서는 시간 복잡도 O(V + E log V)를 가진 다익스트라 최단 거리 알고리즘을 살펴보자 방법   모든 거리 값을 INF로 지정 해주고 시작 노드의 거리 값만 0으로 지정해준다.  (거리, 노드) 형식으로 노드들을 min-우선 순위 큐에 저장한다. 우선 순위 큐는 거리를 기준으로 한다  가장 적은 거리 값을 가진 노드를 우선 순위 큐에서 꺼낸다.  꺼낸 노드와 연결 된 노드들의 거리 값을 계산 한다. 계산 방식은 현재 노드까지 거리값 + 현재 노드에서 다음 노드까지 거리값 &lt; 다음 노드의 현재 거리 값을 사용한다. 거리 값이 갱신된 새로운 노드를 우선 순위 큐에 저장한다  만약 꺼낸 노드가 이전에 사용한 노드라면, 무시하고 다음 노드를 꺼낸다  우선 순위 큐가 비워질때가지 반복한다Python 부분적으로 먼저 살펴 본 후, 마지막에 전체 코드를 보도록 하자 def createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = createGraph()전과 같이 이걸 실행하면 아래와 같은 그래프가 graph에 저장된다.  def dijkstra(graph, start):    # set adj_node     adj_node = {}    for node in graph:        adj_node[node] = None        # set all distance to INF    distance_matrix = {node: float('inf') for node in graph}    # starting position is 0    distance_matrix[start] = 0    # create min-priority-queue    heap = []    # add the starting point to priority queue    heapq.heappush(heap, [distance_matrix[start], start])위의 코드는 다익스트라 알고리즘에 쓸 변수들을 만들고 초기화 시켜주는 코드다 adj_node - 노드들이 최단 거리 값을 계산 할 때 사용했던 인접 노드 정보를 담고 있다 distance_matrix - 노드의 최단 거리 값을 가지고 있다 heap - 최단 거리 값을 기준으로 만들어진 우선 순위 큐 초기화 작업 시 adj_node는 다 None으로 해주고 distance_matrix도 모든 노드들이 inf 값을 가지게 선언 해준다. 시작 노드만 distance_matrix에서 거리값을 0으로 선언하고 시작 노드를 heap에 [거리값, 노드] 형식으로 넣어준다 이후 while문으로 heap에 노드들이 다 없어질때까지 아래의 작업을 반복한다.   우선순위 큐에서 노드를 꺼낸 뒤 거리값을 distance, 노드 이름을 node에 저장한다    while heap: # Take out an item from the priority queue distance, node = heapq.heappop(heap)        distance_matrix에서 현 node의 거리 값이 distance보다 낮으면, 다음 iteration으로 넘어간다     # If this node was used before and has lesser # distance value than the new distance # skip this node if distance_matrix[node] &lt; distance:     continue         현 node와 연결된 모든 노드들을 for 문을 돌린다     # Iterate through all the next nodes connected to  # the current node for next_node, next_node_distance in graph[node].items():        for 문에서 이하 반복한다          현재 노드의 최단 거리 값이랑 다음 노드로 가는 거리 값을 더한다         # Calculate the new distance using current node # to get to the next node new_distance = distance + next_node_distance                    next_node를 위해 갱신된 거리 값 new_distance가 distance_matrix에 저장 된 거리 값 보다 적으면, distance_matrix 값을 갱신해준다.   이후 [갱신된 거리값, 다음 노드] 를 우선 순위 큐 heap에 넣어준다  adj_node에도 현재 node를 사용 했다고 저장해준다         # change the distance if new_distance is lesser if new_distance &lt; distance_matrix[next_node]:     distance_matrix[next_node] = new_distance     # add the updated node to the priority queue     heapq.heappush(heap, [new_distance, next_node])                 # update adj_node that next_node used current node     adj_node[next_node] = node                    전체 코드 import heapqdef createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }def dijkstra(graph, start):    # set adj_node     adj_node = {}    for node in graph:        adj_node[node] = None        # set all distance to INF    distance_matrix = {node: float('inf') for node in graph}    # starting position is 0    distance_matrix[start] = 0    # create min-priority-queue    heap = []    # add the starting point to priority queue    heapq.heappush(heap, [distance_matrix[start], start])    # if there are nodes in heap    while heap:        # Take out an item from the priority queue        distance, node = heapq.heappop(heap)        # If this node was used before and has lesser        # distance value than the new distance        # skip this node        if distance_matrix[node] &lt; distance:            continue                # Iterate through all the next nodes connected to         # the current node        for next_node, next_node_distance in graph[node].items():                        # Calculate the new distance using current node            # to get to the next node            new_distance = distance + next_node_distance            # change the distance if new_distance is lesser            if new_distance &lt; distance_matrix[next_node]:                distance_matrix[next_node] = new_distance                # add the updated node to the priority queue                heapq.heappush(heap, [new_distance, next_node])                                # update adj_node that next_node used current node                adj_node[next_node] = node    return distance_matrix, adj_nodegraph = createGraph()initial = 'D'distance_matrix, adj_node = dijkstra(graph, initial)print(distance_matrix)print(adj_node)# Show shortest path from 'D' to 'H'destination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')# prints: H &lt;- J &lt;- E &lt;- B &lt;- A &lt;- D &lt;-dijkstra 함수는 거리 값 distance_matrix랑 사용한 인접 노드 정보 adj_node만 주고 실질적으로 최단거리를 계산하려면 adj_node 사용해야 한다 코딩 테스트에서는 대부분 위와 같이 우선 순위 큐로 구현하지 않으면 효율성 테스트에서 실패 할 수도 있다 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dijkstra-shortest-path-2/"
      },{
        "title": "[알고리즘] Bubble Sort",
        "excerpt":"출처: GeeksforGeeks 버블 정렬에 대해 알아보자.   가장 간단한 정렬 알고리즘  모든 item을 짝지어서 비교한다  이미 정렬된 array를 마지막에 다시 한 번 훑어야 하는 단점이 있다  Inplace하고 Stable한 알고리즘이다Time Complexity:   Worst: O(n^2) [array 가 reverse 정렬 됐을 시]  Best: O(n) [array 가 정렬이 됐을 시]Auxiliary Space Complexity:   O(1)Bubble sort visualization   Python def bubbleSort(arr):  n = len(arr)   # loop through the entire array  for i in range(n):    # inner loop    # n-i-1: elements found above here are already sorted    for j in range(0, n-i-1):      # Swap if the element found is greater than the next element      if arr[j] &gt; arr[j+1]:        arr[j], arr[j+1] = arr[j+1], arr[j]array = [51, 23, 41, 22, 1, 5]bubbleSort(array)'''outer loop iteration[51, 23, 41, 22, 1, 5] initial[23, 41, 22, 1, 5, 51][23, 22, 1, 5, 41, 51][22, 1, 5, 23, 41, 51][1, 5, 22, 23, 41, 51][1, 5, 22, 23, 41, 51] sortedinner loop operation for first outer loop iterationouter loop: [51, 23, 41, 22, 1, 5] initialinner loop: [51, 23, 41, 22, 1, 5] initialinner loop: [23, 51, 41, 22, 1, 5]inner loop: [23, 41, 51, 22, 1, 5]inner loop: [23, 41, 22, 51, 1, 5]inner loop: [23, 41, 22, 1, 51, 5]inner loop: [23, 41, 22, 1, 5, 51] after j loop finished'''","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Bubble-Sort/"
      },{
        "title": "[알고리즘] Counting Sort",
        "excerpt":"출처: GeeksforGeeks Counting 정렬에 대해 알아보자   특정 범위에 있는 아이템을 정렬 할 때 사용한다  각 아이템의 카운트를 구한 뒤  수학적 방식으로 접근해서 정렬된 array를 만든다  Inplace 하지 않다  Stable 하다알고리즘   arr 내에 모든 아이템의 개수를 counter array에 저장한다  counter array를 (1, n) 으로 for loop을 돌면서, counter[i] += counter[i - 1] 로 바꾼다  arr를 뒤에서부터 돌면서          각 아이템 (i)의 counter[i] - 1 값을 index로 사용한다      아이템 i를 output array에 index 위치에 저장한다        arr를 다시 한번 돌면서 각 item을 output array에 있는 값으로 바꾼다Time Complexity:   Worst: O(n+k) [n 이 아이템의 수, k가 아이템의 범위]Space Complexity:   O(n+k)Counting sort visualization   Python def countingSort(arr):    # extract max and min value    max_val = int(max(arr))    min_val = int(min(arr))    range_of_val = max_val - min_val + 1    # final sorted array    output = [0 for i in range(len(arr))]    # counter array    counter = [0 for i in range(range_of_val)]    # Count the items in the array    for i in range(len(arr)):        idx = arr[i] - min_val        counter[idx] += 1        # Modify counter array to keep the index position of the items    # in the sorted array    for i in range(1, len(counter)):        # add the previous item's counter value        counter[i] += counter[i-1]        # Create the sorted array    for i in range(len(arr) - 1, -1, -1):        # find the index value for the item arr[i]        idx = arr[i] - min_val        counter_val = counter[idx]                # place it in the final array        output[counter_val - 1] = arr[i]        # decrease the value in the counter array        counter[idx] -= 1        # update the values in array     for i in range(len(arr)):        arr[i] = output[i]arr = [5, 2, 3, 1, 16, 4, 7]countingSort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Counting-Sort/"
      },{
        "title": "[알고리즘] Heap Sort",
        "excerpt":"출처: GeeksforGeeks 힙 정렬에 대해 알아보자.   binary heap 데이터 구조를 사용한다  binary heap은 max-heap 구조를 가진다  Inplace 하다  Stable 하지 않다알고리즘   주어진 array로 max-heap을 만든다  가장 큰 값을 가진 root 노드와 binary heap의 마지막 노드의 자리를 바꾼다  heap의 크기를 1 줄인다  root 자리에 위치한 마지막 아이템에 대하여 heapify를 진행한다  heap의 크기가 1 이상이면 반복한다Time Complexity:   Worst: O(n log n)Auxiliary Space Complexity:   O(1)Heap sort visualization   Python def heapify(arr, length, root):    # initialize largest as root    largest = root    print(arr)    # children nodes    left = 2 * root + 1     right = 2 * root + 2    # see if left child of root exists and is greater than root    if left &lt; length and arr[left] &gt; arr[largest]:        largest = left    # see if right child of root exists and is greater than root    if right &lt; length and arr[right] &gt; arr[largest]:        largest = right    # change root if needed    if largest != root:        # swap        arr[root], arr[largest] = arr[largest], arr[root]         # heapify (check again for largest value to head to the root)        heapify(arr ,length, largest)    # sortdef heapSort(arr):    length = len(arr)    # build max heap    for i in range(length//2 -1, -1, -1):        heapify(arr, length, i)    # extract elements    for i in range(length-1, 0, -1):        # swap        arr[i], arr[0] = arr[0], arr[i]        heapify(arr, i, 0)    arr = [12, 15, 13, 5, 6, 7]heapSort(arr)'''[12, 15, 13, 5, 6, 7] # initial[12, 15, 13, 5, 6, 7][12, 15, 13, 5, 6, 7][15, 12, 13, 5, 6, 7][7, 12, 13, 5, 6, 15][13, 12, 7, 5, 6, 15][6, 12, 7, 5, 13, 15][12, 6, 7, 5, 13, 15][5, 6, 7, 12, 13, 15][7, 6, 5, 12, 13, 15][5, 6, 7, 12, 13, 15][6, 5, 7, 12, 13, 15][5, 6, 7, 12, 13, 15] # final'''Iterative version def buildMaxHeap(arr, length):    for i in range(length):        # if child is greater than parent        if arr[i] &gt; arr[(i-1)//2]:            j = i            # swap parent and child until parent is smaller            while arr[j] &gt; arr[int((j-1)/2)]:                arr[j], arr[int((j-1)/2)] = arr[int((j-1)/2)], arr[j]                j = int((j-1)/2)              def heapsort(arr, length):    buildMaxHeap(arr, length)    for i in range(length-1, 0, -1):        print(arr)        # Swap value of first indexed value with the last indexed value        arr[0], arr[i] = arr[i], arr[0]        # maintaining heap property after swapping        root_idx = 0        index = 0        while True:            # initially 'index' is the left child index in the max heap array            #        15      root            #    10     13   left = 10, right = 13            #  4   8  11  12            #            # as array= [15, 10, 13, 4, 8, 11, 12]            # root idx = 0            # left idx (index) = 1            # right idx (index+1) = 2            index = 2 * root_idx + 1            # if left is smaller than right,             # point index to right            if index &lt; i-1 and arr[index] &lt; arr[index +1]:                index += 1                        # if parent is smaller than child,             # swap            if index &lt; i and arr[root_idx] &lt; arr[index]:                arr[root_idx], arr[index] = arr[index], arr[root_idx]                        root_idx = index            if index &gt;= i:                breakarr = [ 10, 20, 15, 17, 9, 21]heapsort(arr, len(arr))print(arr)'''[21, 17, 20, 10, 9, 15] # after max heap[20, 17, 15, 10, 9, 21][17, 10, 15, 9, 20, 21][15, 10, 9, 17, 20, 21][10, 9, 15, 17, 20, 21][9, 10, 15, 17, 20, 21] # final'''","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Heap-Sort/"
      },{
        "title": "[알고리즘] Insertion Sort",
        "excerpt":"출처: GeeksforGeeks 삽입 정렬에 대해 알아보자.   내 손에 쥔 카드를 정렬 할 때와 비슷하다  선택한 카드를 알맞는 위치에 삽입하면 된다  Inplace하고 Stable 하다알고리즘   arr[1] 부터 arr[n] 까지 loop을 돌린다  현재 아이템을 그 전 아이템들과 비교한다  현재 아이템보다 큰 아이템들을 한칸씩 위로 올려주고  현재 아이템을 찾은 위치에 넣어준다Time Complexity:   Worst: O(n^2)Auxiliary Space Complexity:   O(1)Insertion sort visualization   Python def insertionSort(arr):  for i in range(1, len(arr)):    print(\"outer\", array)    key = arr[i]        # move elements of arr[0 ... i-1], that are    # greater than key, to one position ahead of their current position    j = i-1    while j &gt;= 0 and key &lt; arr[j]:      arr[j+1] = arr[j]      j -= 1      print(\"inner\", array)          arr[j+1] = keyarray = [43, 32, 3, 21, 15, 4, 2]insertionSort(array)print(array) # [[2, 3, 4, 15, 21, 32, 43]]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Insertion-Sort/"
      },{
        "title": "[알고리즘] Merge Sort",
        "excerpt":"출처: GeeksforGeeks Merge 정렬에 대해 알아보자.   분할 정복 알고리즘이다  주어진 array를 반으로 나눈다  나뉜 반쪽들을 각각 sort해주고 합친다  Inplace 하지 않다  Stable 하다  external sorting에 유용한 알고리즘이다Time Complexity:   Worst: O(n log n)Auxiliary Space Complexity:   O(n)Merge sort visualization   Python def mergeSort(arr):    if len(arr) &gt; 1:        # find the mid point        mid = len(arr) // 2        # divide into two sub arrays        left = arr[:mid]        right = arr[mid:]        # Sort the left half        mergeSort(left)                # Sort the right half        mergeSort(right)                # create index counter for left, right, original array        i = j = k = 0        while i &lt; len(left) and j &lt; len(right):            if left[i] &lt; right[j]:                arr[k] = left[i]                i+=1            else:                arr[k] = right[j]                j+= 1            k += 1                # add remaining elements        while i &lt; len(left):            arr[k] = left[i]            i += 1            k += 1        while j &lt; len(right):            arr[k] = right[j]            j += 1            k += 1array = [1, 5, 32, 2, 42, 3, 55]mergeSort(array)print(array) # [1, 2, 3, 5, 32, 42, 55]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Merge-Sort/"
      },{
        "title": "[알고리즘] Quick Sort",
        "excerpt":"출처: GeeksforGeeks Quick 정렬에 대해 알아보자.   분할 정복 알고리즘이다  pivot을 사용해 주어진 array를 partition한다  pivot 보다 작은 것은 왼쪽에, 보다 큰 것은 오른쪽에 놓는 작업이다  pivot의 위치에 따라 알고리즘의 효율성이 달라진다  Stable하지 않다  Inplace 하다  Inplace 알고리즘이기 때문에 merge sort보다 선호 될 때가 있다Time Complexity:   Worst: O(n^2) [array에서 가장 큰 수 혹은 작은 수가 pivot인데 array가 이미 정렬이 됐을 때]  Best: O(n log n)Auxiliary Space Complexity:   O(1)Quick sort visualization   Python def partition(arr, low, high):    # partition the array    # place the pivot on the right position     # start i (all the numbers less than pivot) from low -1    i = low-1    # pivot will be the rightmost element    pivot = arr[high]    # iterate through the array    for j in range(low, high):                # if the current element is less than the pivot        if arr[j] &lt; pivot:            # print for visuals            print(arr)            # increment the lower bound index            i+=1            # swap the current element with the element right after the lower bound index            arr[i], arr[j] = arr[j], arr[i]            # swap the pivot with the element at lower bound index + 1    arr[i+1], arr[high] = arr[high], arr[i+1]    # return the position of the pivot    return i + 1def quickSort(arr, low, high):    # only partition when lower bound is lower than higher bound    if low &lt; high:        partitioned = partition(arr, low, high)        # quick sort the left sub array of pivot        quickSort(arr, low, partitioned-1)        # quick sort the right sub array of pivot        quickSort(arr, partitioned+1, high)arr = [0, 10, 7, 3, 8, 9, 1, 5] n = len(arr) quickSort(arr,0,n-1) print(arr)'''[0, 10, 7, 3, 8, 9, 1, 5] # j = 0[0, 10, 7, 3, 8, 9, 1, 5] # swap j, i = 0, 0[0, 3, 7, 10, 8, 9, 1, 5] # swap j = 3, i = 1 + 1 = 2; arr[j] &lt;-&gt; arr[i][0, 3, 1, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 7, 8, 9, 10] # final'''Iterative def partition(arr, low, high):    # partition the array    # place the pivot on the right position     # start i (all the numbers less than pivot) from low -1    i = low-1    # pivot will be the rightmost element    pivot = arr[high]    # iterate through the array    for j in range(low, high):                # if the current element is less than the pivot        if arr[j] &lt; pivot:            # print for visuals            print(arr)            # increment the lower bound index            i+=1            # swap the current element with the element right after the lower bound index            arr[i], arr[j] = arr[j], arr[i]            # swap the pivot with the element at lower bound index + 1    arr[i+1], arr[high] = arr[high], arr[i+1]    # return the position of the pivot    return i + 1def quickSort(arr, low, high):    # create supplementary stack    size = high - low + 1    stack = [0] * size    # push initial values to stack    top = 0    stack[top] = low    top += 1    stack[top] = high    # keep popping while stack is not empty    while top &gt;= 0:        # pop low, high        high = stack[top]        top -= 1        low = stack[top]        top -=1        # set pivot in its correct position        pivot = partition(arr, low, high)        # if there are elements on left side of pivot,        # push it to stack        if pivot-1 &gt; low:            top += 1            stack[top] = low            top += 1            stack[top] = pivot - 1                # if there are elements on right side of pivot,        # push it to the stack        if pivot+1 &lt; high:            top += 1            stack[top] = pivot + 1            top += 1            stack[top] = higharr = [4, 3, 5, 2, 1, 3, 2, 3] n = len(arr) quickSort(arr, 0, n-1) print(arr)'''[4, 3, 5, 2, 1, 3, 2, 3][2, 3, 5, 4, 1, 3, 2, 3][2, 1, 5, 4, 3, 3, 2, 3][2, 1, 2, 3, 3, 3, 5, 4][2, 1, 2, 3, 3, 3, 5, 4][2, 1, 2, 3, 3, 3, 4, 5][1, 2, 2, 3, 3, 3, 4, 5]'''Pivot을 Mid로 할 때 출처: BogoToBogo def quickSort2(arr):    def sort(arr, low, high):        if low &gt;= high:            return                left = low        right = high        # pivot selection        mid = (left + right) // 2        pivot = arr[mid]        # Partition        while left &lt;= right:            # find the element from left             # that is greater than pivot            while arr[left] &lt; pivot:                left += 1                        # find the element from right            # that is less than pivot            while arr[right] &gt; pivot:                right -= 1                        # swap the left and right items            # if left &lt;= right            if left &lt;= right:                arr[left], arr[right] = arr[right], arr[left]                left += 1                right -= 1                # recursion        sort(arr, low, right)        sort(arr, left, high)    sort(arr, 0, len(arr) - 1)","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Quick-Sort/"
      },{
        "title": "[알고리즘] Selection Sort",
        "excerpt":"출처: GeeksforGeeks 선택 정렬에 대해 알아보자.   가장 작은 수를 가장 앞단에 놓는 알고리즘이다  Inplace 하다  Stable 하지 않다Time Complexity:   Worst: O(n^2)Auxiliary Space Complexity:   O(1)Selection sort visualization   Python def selectionSort(arr):  # loop through the entire array  for i in range(len(arr)):    # idx position to store minimum value    min_idx = i        # loop through the to-sort array (i+1, end)    for j in range(i+1, len(arr)):            # Update idx with the minimum value      if arr[j] &lt; arr[min_idx]:        min_idx = j        # swap positions after j loop is finished    arr[i], arr[min_idx] = arr[min_idx], arr[i]array = [64 ,32, 52, 1, 31, 36, 31]selectionSort(array)print(array) # [1, 31, 31, 32, 36, 52, 64]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Selection-Sort/"
      },{
        "title": "[알고리즘] Prim's Minimum Spanning Tree",
        "excerpt":"출처: GeeksforGeeks, cppsecrets, bradfieldcs Prim의 Minimum Spanning Tree 알고리즘에 대해 알아보자   그리디 알고리즘이다.  가장 작은 weight로 MST를 구현하는 것  Naive하게 구현 하면 Time complexity O(|V|^2) 이나 다익스트라와 같이 priority queue를 사용하면 O(E log V)로 만들 수 있다방법   MST에 포함된 vertex를 저장할 set를 만든다 (empty set)  모든 vertices 간의 weight 값을 지정한다. 시작점을 제외한 모든 vertices weight 값은 무한대가 된다. 시작점은 0으로 만든다  모든 vertices가 MST에 포함된 vertex를 저장하는 set에 들어올때까지 이하 반복 한다:          set에 포함되지 않는 vertices 중 최단 거리를 가지고 있는 vertex u를 고른다      set에 포함 시킨다      vertex u 와 인접한 모든 vertices의 거리 값을 갱신한다.      Python def createAdjMatrix(V, G):    # Create empty adjacent matrix    adjMatrix = [[0 for row in range(V)] for col in range(V)]    # populate adjacency matrix with correct weights    for i in range(0, len(G)):        # G[i][0] is index of one vertex (node)        # G[i][1] is index of the other vertex        adjMatrix[G[i][0]][G[i][1]] = G[i][2]        adjMatrix[G[i][1]][G[i][0]] = G[i][2]        return adjMatrixdef primsMST(V, G):    # create adjacency matrix from graph    adjMatrix = createAdjMatrix(V, G)    # choose initial vertex from graph    vertex = 0    # initialize empty edges array and empty MST    MST = []    edges = []    visited = []    # keep track of min Edge    # [from, to, weight]    minEdge = [None, None, float('inf')]    # run prim's algorithm until the MST    # has all the vertices    while len(MST) != V - 1:                # mark the vertex as visited        visited.append(vertex)        # add each edge to the list of potential edges        for i in range(0, V):            if adjMatrix[vertex][i] != 0:                edges.append([vertex, i, adjMatrix[vertex][i]])                # find the edge with the smallest weight to a vertex        # that has not yet visited        for edge in range(0, len(edges)):            if edges[edge][2] &lt; minEdge[2] and edges[edge][1] not in visited:                minEdge = edges[edge]                # remove min weighted edge from the list of edges        edges.remove(minEdge)        # push min edge to MST        MST.append(minEdge)        # update vertex and rest minEdge        vertex = minEdge[1]        minEdge = [None, None, float('inf')]        return MSTif __name__ == \"__main__\":    # create graph nodes (vertices)    a, b, c, d, e, f = 0, 1, 2, 3, 4, 5    # create graph edges with weights    graph = [[a, b, 2],        [a, c, 3],        [b, d, 3],        [b, c, 5],        [b, e, 4],        [c, e, 4],        [d, e, 2],        [d, f, 3],        [e, f, 5]]    print(primsMST(6, graph))    # prints [[0, 1, 2], [0, 2, 3], [1, 3, 3], [3, 4, 2], [3, 5, 3]]    # Which is a MST of:    #     1(b) - 3(d) - 4(e)    #     |      |    #     0(a)   5(f)    #     |    #     2(c)우선 순위 큐를 사용한 Prim’s MST import heapqfrom collections import defaultdictdef createSpanningTree(graph, start):    mst = defaultdict(set)    visited = set([start])    edges = [        (cost, start, to) for to, cost in graph[start].items()    ]    heapq.heapify(edges)    # Find the mst    while edges:        cost, frm, to = heapq.heappop(edges)        if to not in visited:            visited.add(to)            mst[frm].add(to)            for to_next, cost in graph[to].items():                if to_next not in visited:                    heapq.heappush(edges, (cost, to, to_next))        return mstexample = {    'A': {'B': 2, 'C': 3},    'B': {'A': 2, 'C': 1, 'D': 1, 'E': 4},    'C': {'A': 3, 'B': 1, 'F': 5},    'D': {'B': 1, 'E': 1},    'E': {'B': 4, 'D': 1, 'F': 1},    'F': {'C': 5, 'E': 1, 'G': 1},    'G': {'F': 1},}mst = dict(createSpanningTree(example, 'A'))print(mst)# {'A': {'B'}, 'B': {'D', 'C'}, 'D': {'E'}, 'E': {'F'}, 'F': {'G'}}##  Original#     #       2 -- A ---- 3#       |           |#       B -- 1 ---- C#       | \\         |#       1   4       5#       |    \\      |#       D -1- E -1- F -1- G##  MST:#       2 -- A #       |           #       B -- 1 ---- C#       |           #       1           #       |           #       D --1-- E --1-- F --1-- GPrim’s MST 알고리즘을 사용한 문제 Leetcode 1584 Min cost to connect all points [프로그래머스] 섬 연결하기 백준 1197번 최소 스패닝 트리 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prim's-minimum-spanning-tree/"
      },{
        "title": "[알고리즘] Radix Sort",
        "excerpt":"출처: GeeksforGeeks 라딕스 정렬에 대해 알아보자   제일 큰 숫자의 자릿수를 구하고  자릿수를 기준으로 정렬을 한다  내부에서는 카운팅 정렬이 사용된다Time complexity   O(d*n) - d는 가장 큰 수의 자릿수, n은 element 개수Space complexity   O(n + 2^d) - 2^d 인 이유는 각 key를 저장하기위한 비트 수Radix sort visualization   Python def radixSort(arr):    def helperFunc(arr, expo):        # implement counting sort        N = len(arr)        output = [0] * N        # initialize counter array as 10        counter = [0] * 10        # store frequency in count        for i in range(N):            idx = arr[i] / expo            counter[int(idx % 10)] += 1                # change counter i        for i in range(1, 10):            counter[i] += counter[i-1]                # build output array        i = N - 1        while i &gt;= 0:            idx = arr[i] / expo            output[counter[int(idx % 10)] - 1] = arr[i]            counter[int(idx % 10)] -= 1            i -= 1                # copy result to array        for i in range(N):            arr[i] = output[i]    # find the max number to know the number of digits    max_val = max(arr)    # Do counting sort for every digit    # Instead of passing the digit number,    # exp is 10^i where i is the current digit    exp = 1    while max_val / exp &gt; 0:        helperFunc(arr, exp)        exp *= 10","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Radix-Sort/"
      },{
        "title": "[프로젝트] Medium 클론 백엔드를 만들어보자 -1장",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1장  Medium 클론 백엔드를 만들어보자 -2장  Medium 클론 백엔드를 만들어보자 -3장  Medium 클론 백엔드를 만들어보자 -4장  Medium 클론 백엔드를 만들어보자 -5장이 포스트는 . . . 얼마 전 막 학기가 끝나고 취준을 위해 2주동안 Medium 클론을 만들어 봤다. 이 프로젝트를 새롭게 해보려고 한다. 그리고 그 과정을 포스트 형식으로 기록하려고 한다. 이번 포스트는 이 프로젝트를 다시 해보는 이유와 2주 동안 개발했던 미디엄 클론의 기술 스택을 살펴보자 다시 하는 이유 일단 처음 미디엄 클론 프로젝트를 했을 때는 단기간에 빠르게 개발 할 수 있는가? 가 목표였고, 이를 충족 시키기 위해 서비스의 MVP를 개발 한다는 느낌으로 매일 5~8시간 정도 개발했었다. 이렇게 빠르게만 하다보니 퀄리티 자체는 높지 않다고 생각한다. 그래서 이번에는 새로운 언어도 배워 볼 겸, 조금 더 제대로 백엔드 디자인 가이드에 준수 하면서 만들어 보려고 한다. 왜 같은 프로젝트를 또 하는가? 한번 해봤던 프로젝트이기 때문에 서비스의 기능들을 구상해야되는 시간이 0에 가깝기 때문이다. 현재 아직 취준 중이기 때문에 새로운 프로젝트를 구상하고 만들어보기에는 준비해야 할 것들이 많기 때문이다. 또한 이번 프로젝트의 목적은 새로운 언어 습득과 백엔드 설계 및 자동화에 중점을 두고 할 것이기 때문에 그 외 불필요한 것들은 생략하는 것이다. 나름 선택과 집중이라고 볼 수 있다. 기존 미디엄 클론의 기술 스택 일단 서버에서 프론트를 렌더해주는 웹 앱이고 사용한 스택은 다음과 같다. Frontend:   Pug  JSBackend:   Nodejs (Express)  Mocha-chai (Test library)DB:   PostgresqlCI/CD:   Travis CI  Appveyor  Code Climate  Coveralls  HerokuCode storage/maintenance:   Git/Github부족했던 점 2 주만에 만든 것 치고는 나름 이것저것 많이 써봤지만 아쉬운 점이 많다. 일단 첫번째로는 SSR을 도전해본다고 frontend의 복잡함을 간과했던 것 두번째는 백엔드 코드가 디자인 가이드 없이 만들어졌다는 점과 백엔드 문서화 작업이 이루어지지 않았다는 점이다. 이번에는 뭐가 다른가? 이번에는 Go lang을 배우기 위해 다시 만들어 보는 것이 가장 큰 이유다. 일단 Frontend와 Backend를 확실히 나눈 뒤, Backend를 먼저 개발하는 것에 집중 할 것이다. 그리고 완벽한 REST API를 만들지는 못하지만 (이유는 PlanB님의 블로그에 잘 서술 돼있으니 참고하면 된다.) REST 기준을 최대한 준수하며 HTTP API로 만들 계획이다. 여기에 TEST 코드와 CI/CD까지 붙이고 Docker로 이미지화까지 도전해 볼 계획이다. 마무리 정리를 하자면:   Frontend와 Backend를 나눈다  Backend 언어는 Go lang  Backend 디자인은 REST에 최대한 준수하는 HTTP API  Test 코드 및 CI/CD와 Docker 이미지화뭔가 많아 보인다. 괜찮다. 백엔드는 자동화만 잘 해주면 문제없다. 아마도. 다음 포스트에서는 개발 및 테스트를 어떻게 할지, 어떤 라이브러리를 사용할지 살펴보도록 하자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-1%EC%9E%A5/"
      },{
        "title": "[프로젝트] Medium 클론 백엔드를 만들어보자 -2장",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1장  Medium 클론 백엔드를 만들어보자 -2장  Medium 클론 백엔드를 만들어보자 -3장  Medium 클론 백엔드를 만들어보자 -4장  Medium 클론 백엔드를 만들어보자 -5장이전 포스트에서 . . .   왜 다시 이 프로젝트를 하는지  어떤 언어를 사용할 것인지이 포스트는 . . .   어떤 프레임워크/툴들을 사용 할 것인지에 대해 알아보자.백엔드 설계 일단 저번 포스트에서도 언급했듯이 언어는 Go로 정해졌다. 이유는 내가 Go 언어를 공부해보고 싶기 때문이다. 그리고 디자인 방식도 REST에 최대한 준수하는 API를 만들어 보겠다고 했다. 그러면 현재 언어와 설계 방식은 정해져있다. 그러면 이에 맞는 프레임워크와 개발 방식 그리고 개발 방식에 따른 테스트 라이브러리을 정해보자. 프레임워크 Go에서 REST한 API를 만들때 쓰는 프레임워크 중 대략 7가지를 보고 하나를 정하려고 한다. 7개의 프레임워크는 이 영문 포스트에 있다   Revel - “out of the box” 프레임워크  Gin - “lean”, 미니멀리스틱한 프레임워크  Martini - Gin의 베이스가 되는 라이브러리  Web.go - 트리 라우팅을 사용하는 미니멀한 라이브러리  Gorilla - package관리가 쉬운 프레임워크  Goji - 정말 최소한의 기능만 구현된 프레임워크  Beego - Revel 같은 out of the box 프레임워크일단 Revel, Beego 같은 경우는 너무 많은 것들이 이미 구현이 돼있어서 배우는게 없을 것 같아서 제외시키겠다. Web.go, Goji 같은 경우는 너무 미니멀한 것들이라 제외시키겠다. 너무 미니멀하면 구현을 해야하는 것들이 너무 많아져서 시간이 또 오래걸린다. Gorilla 같은 경우는 package 단위로 더하고 빼고 할 수 있어서 좋지만, 설정이 까다롭다는 점에서 Go를 처음 접하는 내가 효율적으로 사용할 수 있을까라는 의문이 있을뿐더러 package 설정에 쏟는 시간을 차라리 테스트나 자동화에 쏟는게 더 바람직하다고 생각하니까 빼도록 하겠다. 그러면 Gin과 Martini가 남게 되는데, 사용사례도 Gin이 더 많은 것 같고 Gin이 Martini보다 40배 빠르다고 하니까 이번 프로젝트는 Gin으로 백엔드를 개발 할 것이다. 개발 방식 개발 프레임워크를 정했으니 어떤 식으로 개발을 할지 정해보자. 기본적으로 개발은 그냥 해도 된다. 하지만 그냥 개발하면 서비스도 그냥 나온다.   쓰레기 input -&gt; Computer -&gt; 쓰레기 output 즉, 제대로 된 코드를 짜려면 개발 방식도 고려를 해야한다. 하지만 내가 대학교에서 배운, 아니 배우지도 않았다, 듣기만한 TDD (Test driven development)뿐 이다. 3년 가량 학교에서 개발을 배웠지만, 실제로 TDD를 적용한건 2주 미디엄클론을 했을 때 뿐이다. 어떤 개발 방식이 있는지 알아보자   TDD - 최소한의 개발 -&gt; 테스트 케이스를 먼저 작성 -&gt; 기능구현을 하면서 테스트를 통과하는지 검증  BDD - TDD와 비슷하게, 최소한의 개발 -&gt; 유저 시나리오에 맞는 테스트 케이스 작성 -&gt; 기능구현을 하면서 테스트를 통과하는지 검증  DDD - 도메인을 중점으로 개발을 함. Business logic에 맞게 변수/클래스 명을 작성하는 등, 비개발자도 개발자와 코드를 보면서 협업할 수 있도록 하는 것이 포인트.  ATDD - TDD의 업그레이드 버전, 기존 TDD는 코드가 잘 작동하는냐가 중점이라면 ATDD는 Acceptance 기준이 있어서 이 코드가 왜 필요한가? 도 따지게 되는 것  FDD - 기능 중점 개발여기서 알아야 할 것은 개발 방식은 하나를 정해서 하는 것이 아니라 여러 개가 얽혀있는 방식이다. 가령 BDD 같은 경우 TDD 와 DDD를 섞은 방식이라고 볼 수 있다. 아무튼, 나는 BDD 방식으로 접근을 할 것이다. TDD 방식으로 테스트케이스 -&gt; 개발 -&gt; 검증 으로 코드의 안정성을 유지하고 DDD 방식으로 비개발자가 테스트 코드를 보아도 의도된 행동양식을 통과한다는 것을 알 수 있게끔 API endpoint나 변수/클래스 같은 것들을 알기 쉽게 작성할 계획이다. 테스트 라이브러리 자, 이제 테스트 라이브러리만 정하면 된다. Go는 기본 Testing 라이브러리가 잘 되어 있어서 굳이 다른 라이브러리를 사용할 필요가 없지만, 개발자 편의를 위해 만들어 놓은 제 3 라이브러리를 사용 안 할 이유 또한 없다. BDD에 걸맞는 라이브러리가 어떤 것들이 있는지 알아보자. 출처는 이 영문 포스트다 포스트에는 여러 가지 테스트 라이브러리가 있는데 BDD에 특화된 라이브러리를 나열하면:   Ginkgo and Gomega  Goblin  GoConvey  기본 Go Testing 라이브러리가 있다. 일단 Ginkgo 와 Gomega 조합은 사용자도 많고 BDD에 최적화 되어 있고 기능들도 많다. 하지만 기능이 많다는 것은 내가 직접 구현해야 할 것들이 줄어들어서 배움의 장이 좁아진 다는 것이기 때문에 패스하도록 하겠다. GoConvey 같은 경우 UI로 볼 수 있는 서버가 띄워지고 쓰기 편해보이지만 개인적으로 web에 띄워지는 UI로 테스트 코드 결과를 보는 것보다 terminal에 바로 보여지는 것을 선호하기 때문에 패스하겠다. 기본 Go testing 라이브러리는 BDD 로 테스트 케이스를 작성하면 코드 자체가 상당히 지저분해 질 것 같아서 패스하도록 하겠다. 결론은 Ginkgo보다 기능들이 더 적게 구현되어 있지만 있을 건 다 있는 Goblin으로 하곘다. 마무리 정리 하자면 이번 포스트에서 정한 것은   개발 프레임워크 - Gin  개발 방식 - BDD  테스트 라이브러리 - Goblin이 되겠다. 다음 포스트에서는 프로젝트 관리는 무엇으로 할 것인지와 어떤 CI/CD 툴을 사용할 것 인지에 대해 알아보자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-2%EC%9E%A5/"
      },{
        "title": "[프로젝트] Medium 클론 백엔드를 만들어보자 -3장",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1장  Medium 클론 백엔드를 만들어보자 -2장  Medium 클론 백엔드를 만들어보자 -3장  Medium 클론 백엔드를 만들어보자 -4장  Medium 클론 백엔드를 만들어보자 -5장이전 포스트에서 . . .   어떤 개발 방식, 프레임워크, 테스트 라이브러리를 사용 할 건지이 포스트는 . . .   어떤 CI/CD 툴을 사용할 건지  어떤 project 관리 툴을 사용할 건지 알아보자CI/CD 툴 CI/CD도 테스트 방식 만큼이나 학교에서 듣기만 했지 써본 적은 없는 미지의 기술이었다. 처음 써 본게 역시나 2주 미디엄 클론 코딩을 하면서 Travis CI랑 Appveyor를 썼을 때다. CI/CD를 간략히 설명하자면, Continuous Integration / Continuous Delivery의 약자다. CI 는 여러 사람들이 작성한 코드를 지속적으로 하나의 코드로 통합시키고 검증하는 방식이다. 기본적으로는:   로컬 환경에서 테스트 코드로 코드를 검증한다  CI 환경에서 코드를 컴파일 한다  CI 환경에서 코드를 테스트해서 검증한다  CI 에서 서비스가 배포 될 수 있도록 한다 (Continuous Delivery)마지막 4번이 자동화가 되어있다면 continuous deployment라고 볼 수 있다. 이 모든 과정이 자동화가 되어 있어야 개발자들이 이상한 곳에서 시간을 낭비하지 않는다. 백엔드 엔지니어도 처음 만드는 서비스의 서버 환경을 구성해야되는 상황이면 CI/CD pipepline을 구축할 줄 알아야한다. DevOps가 구축하기도 한다. 이번에는 어떤 CI/CD 툴이 있고, 이 프로젝트에서 어떤 것을 쓸 것인지 알아보자. 출처는 2020년 당신이 알아야 할 탑 7 CI/CD 툴 (미디엄 영문)이다   Travis CI - 이미 사용했으니까 제외  Appveyor - 이미 사용했으니까 제외  Jenkins - 오픈소스 CI/CD 툴, 많은 개발자들이 애용한다  CircleCI - 유료지만 무료 플랜이 나쁘지 않은 서비스  Bamboo - 유료 Atlassian 제품, Bitbucket, Jira 만든 곳  TeamCity - Jetbrains에서 만든 CI 툴  Github Actions - 깃허브 지원 CI/CD 툴외에도 많지만 요정도에서 정해보겠다 일단 Travis CI 와 Appveyor는 사용한 경험이 있어서 패스하고 Bamboo와 CircleCi는 유료라서 제외하겠다. TeamCity는 여러 기능들이 좀 매력적이지만 이 프로젝트에 적용 시키기에는 너무 오버스펙 같아서 패스하겠다. 결국 Jenkins와 Github Actions가 남는데, 개인적으로 Git repository를 이미 Github로 사용하고 있으니 Github Actions로 일관성을 유지하겠다. 물론 위에 나열한 CI/CD 툴은 다 훌륭하다고 생각한다. 사용 방식도 하나만 알면 나머지도 비슷한 느낌이라 쉽게 배울 수 있다고 생각한다. 프로젝트 관리 툴 CI/CD 툴을 정했으니 프로젝트 관리 툴도 정해보자.   Jira  Trello  Asana  Github Projects이미 짐작했겠지만 Github Projects를 사용할 것이다. 이유는 일관성있게 모든 것을 Github내에서 볼 수 있도록 하기 위함이다. 새삼 Github가 정말 개발자 친화적이라고 느낀다. 역시 MS의 힘이란. 마무리 정리를 하자면:   CI/CD 툴 - Github Actions  프로젝트 관리 툴 - Github Projects다음 포스트에서는 앱 설계와 데이터베이스를 정해보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-3%EC%9E%A5/"
      },{
        "title": "[프로젝트] Medium 클론 백엔드를 만들어보자 -4장",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1장  Medium 클론 백엔드를 만들어보자 -2장  Medium 클론 백엔드를 만들어보자 -3장  Medium 클론 백엔드를 만들어보자 -4장  Medium 클론 백엔드를 만들어보자 -5장이전 포스트에서 . . .   어떤 CI/CD 툴을 사용할 지  어떤 프로젝트 관리 툴을 사용할 지이 포스트는 . . .   앱 설계  어떤 데이터베이스를 사용할지앱 설계 사실 이 “앱 설계”만 적어도 10 포스트는 넘게 작성 할 수 있다. 그만큼 고려해야하는 것이 많기 때문이다. 여태까지 해 왔던 것들도 나름 앱 설계에 들어간다고 볼 수 있다. 0년차 개발자로서 개발지식은 많지 않다. 하지만 새로운 앱을 만들 때 고려해야 하는 것들을 좀 나열해 본다면:   앱은 웹을 위한 앱인지, 안드로이드/iOS를 위한 앱인지, 아니면 둘 다를 위한 앱인지  설계 방식은 Monolithic 인지, SOA인지, MSA 인지  유저 인증/인가는 어디서, 어떻게 할건지, 따로 서버를 둘 건지  Scale이 가능한 앱인지, 어느 부분에서 어떤 metric을 기준으로 Scale out할 건지  백엔드는 stateful 한지 stateless한지  저장소는 어떻게 운영할 건지, 캐시는 활용 할 것인지  어떤 디자인 원칙을 준수할 것인지  버전 관리는 어떻게 할 것인지  테스트는 어떻게 할 것인지, 배포는 어떻게 할 것인지  load balancing은 어떻게 할 것인지  분산된 아키텍쳐면 로그는 어떻게 관리할 것인지  데이터베이스는 scale 할 것인지  방화벽은 어디에 어떻게 적용이 될 것인지등등 끝도 없다. 이 것외에도 엄청 많겠지만 현재 나의 지식으로는 이정도 밖에 생각을 못하겠다. ㅠㅠ 0년차인데 이런 것들을 알아야 하나 싶겠지만, 세상이 새로운 개발자에게 요구하는 지식은 갈 수록 늘어날 수 밖에 없다. 없는 것은 몰라도 되지만 있는 것은 알아야 한다. 아무튼, 이 프로젝트의 앱 설계를 위의 9번까지 기준으로 작성을 해보자면 :   이 앱은 웹을 위한 것이다.  설계 방식은 Monolithic 한 방식을 쓰겠다. 이유는 기능별로 서버를 나눌 필요가 없기 때문이다  유저 인증/인가는 다른 포스트에서 다루도록 하겠다  scale은 가능하게끔 만들겠지만 scale 하지는 않을 것 같다  stateless한 서버를 만들겠다 RESTful 하기 위해  캐시는 없고, 데이터베이스는 추후에 서술하겠다  디자인 원칙은 백엔드는 REST에 최대한 준수한 HTTP API  버전 관리는 gvm을 통해서 하겠다  테스트는 전 포스트에서 언급한 것 처럼 BDD를 준수하며 테스트 케이스를 만들고 Github Actions로 자동화 시키겠다자, high-level 이지만 대략적인 앱 설계는 끝났다. 설계한 대로 코드를 짤 수 있도록 잘 기억하도록 하자. 데이터베이스 이제 데이터베이스를 정해보자. 이것 또한 여러가지 방법이 있고 상황에 따라 적절한 데이터베이스를 정하는 것이 중요하다. 일단 제일 큰 축인, 관계형을 쓸 것인지 NoSql을 쓸 것인지부터 정하도록 하겠다. 저번 프로젝트에서는 관계형 데이터베이스인 Postgresql을 사용했다. 이번 프로젝트도 기능을 생각해 봤을 때 유저가 있고, 유저마다 포스트를 작성할 수 있고, 포스트에 좋아요를 표시할 수 있고, 코멘트 역시 달 수 있다는 점에서 관계형 RDBMS가 좋은 것 같다. 그러면 RDBMS 중에 사용 할 만한 툴을 찾아보자:   Postgresql  MySQL  SQLite등이 있다. 이번 프로젝트도 Postgresql을 사용하도록 하겠다. 이유는 현재 컴퓨터에 설치되어 있고 바로 구동 가능하기 때문이다. 프로젝트의 목표는 새 언어를 배우고 백엔드를 설계/자동화 하는 것이기 때문에 새로운 데이터베이스를 설치하고 설정하는 것에 시간을 투자하는 것은 비효율적이라고 판단했기 때문이다. SQL은 하나만 쓸 줄 알면 나머지도 언어 자체는 똑같기 때문에 사용하는데 무리가 없다. 마무리 정리를 하자면:   앱 설계를 Monolithic, stateless, scale 가능하게 했고  데이터베이스는 Postgresql이고 캐시는 없다.다음 포스트에서는 백엔드 API를 endpoint들을 설계해보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-4%EC%9E%A5/"
      },{
        "title": "[프로젝트] Medium 클론 백엔드를 만들어보자 -5장",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1장  Medium 클론 백엔드를 만들어보자 -2장  Medium 클론 백엔드를 만들어보자 -3장  Medium 클론 백엔드를 만들어보자 -4장  Medium 클론 백엔드를 만들어보자 -5장이전 포스트에서 . . .   앱 설계를 어떻게 할 것인지  데이터베이스 어떤 것을 쓸건지이 포스트는 . . .   백엔드 endpoint 설계백엔드 Endpoint 설계 우선 설계에 앞서 기억을 해야 할 것이 있다.   REST에 최대한 준하는 HTTP API이제 Endpoint들을 하나씩 뜯어보자. 일단 이전 프로젝트에서 서버가 지니고 있던 endpoint들을 살펴보면:   / GET - 홈페이지  /login GET - Auth0랑 passport.js 위한 것  /callback GET - Auth0랑 passport.js 위한 것  /logout GET - Auth0랑 passport.js 위한 것  /editor GET - 에디터를 보여주는 것  /editor POST - 에디터를 데이터베이스에 추가하는 것  /editor/update PUT - 에디터를 업데이트 하는 것  /editor/delete DELETE - 에디터를 지우는 것  /like PATCH - 포스트에 라이크를 더 하는 것  /list GET - 모든 포스트를 나열하는 것  /list/tags GET - 모든 포스트를 태그로 나열하는 것  /list/author GET - 모든 포스트를 작성자로 나열하는 것  /myposts GET - 유저가 작성한 포스트를 나열하는 페이지  /post GET - 포스트 정보를 보여주는 페이지  /post/id POST - 포스트를 아이디로 가져와서 보여주는 페이지  /post/tag POST - 포스트들을 태그로 가져와서 보여주는 페이지  /post/list POST - 포스트들을 가져오는 페이지  /users GET - 유저 정보를 가져오는 페이지정도가 있다. 보다시피 전혀 RESTful하지 않고 endpoint와 같이 적힌 설명문을 봤을 때 “응?”하는 것들이 많다. 예를 들면 /like. 중복되는 것도 있고 여러모로 정리가 되어있지 않다. 실제로 정리를 하지 않고 개발했기 때문이다. 이것들을 RESTful하게 정리를 해보자. RESTful 하게 바꾸자 ! 일단 바꾸기에 앞서서 RESTful한 endpoint가 뭔지 알아야 한다. RESTful 시스템이 뭔지는 다른 포스트에서 보도록하자. 위키피디아. REST API의 URI 디자인 가이드만 간략히 나열해보면 출처: resfulapi:   REST에서 primary 데이터는 resource라고 한다.  resource는 단일 (singleton) 혹은 컬렉션 (collection)이 될 수 있다.          /customers - collection      /customer - singleton        resource는 다른 resource의 sub-collection을 포함할 수 있다          /customers/{customer_id}/accounts - accounts sub-collection을 customer_id로 찾을 수 있다.      /customers/{cuustomer_id}/accounts/{account_id} - 마찬가지로 {account_id}를 이용해 accounts 컬렉션에서 단일 데이터를 가져올 수 있다.        resource를 표현 할 때 noun (명사)를 써라  resource를 좀 더 세분화하면 document, collection, store, controller 로 나눌 수 있다.  document는 데이터베이스에 저장되거나 하나의 객체를 뜻하는 단일 데이터다. REST에선 컬렉션안을 구성하는 것이 document라고 생각하면 된다          /customers/{customer_id} - customer_id가 document        collection - 서버가 관리하는 리소스의 집합체다. 클라이언트는 새로운 리소스를 collection에 추가하도록 요구 할 수 있지만, 결정권은 서버에 있다. 복수명을 사용하도록 하자          http://api.example.com/user-management/users        store - 클라이언트가 관리하는 리소스의 집합체다. 클라이언트는 새로운 URI를 생성하지는 않지만, 리소스를 더하거나 빼거나 지우거나 자유롭게 할 수 있다. 복수명을 사용하도록 하자          http://api.example.com/song-management/users/{id}/playlists      클라이언트가 관리한다고 해서 헷갈리지 말자. 다 서버에서 구현하는 것이다.        controller - 리소스의 행위를 뜻한다. 인자와 리턴 값이 있는 함수명이라고 생각하면 된다. 동사를 쓰도록하자          http://api.example.com/song-management/users/{id}/playlist/play        /를 사용해 리소스간 연관성을 표현하자          /electronics      /electronics/computers      /electronics/computers/cpus      /electronics/computers/cpus/{model_id}        마지막에 /는 생략하자          http://api.example.com/electronics/ X      http://api.example.com/electronics O        - 를 이용해 가독성을 챙기자          http://api.example.com/electronics/micro-controllers/ O        _ 는 사용하지 말자          http://api.example.com/electronics/micro_controllers/ X        소문자를 쓰자          http://api.example.com/electronics/CPUS/ X      http://api.example.com/electronics/cpus/ O        파일 확장명은 쓰지 말자          http://api.example.com/some-file.xml X      http://api.example.com/some-file O        CRUD 동사를 URI에 쓰지 말자. HTTP Method로 설명은 충분하다          http://api.example.com/electronics/get/CPUS/ X        URI collection은 query component를 활용하자          http://api.example.com/device-management/managed-devices?region=USA&amp;brand=XYZ&amp;sort=installation-date O      자 이 목록을 기준으로 다시 endpoint들을 작성해보자. 여기서 중요한 것은 editor 와 post 리소스에 있다. 잠시 샘플을 보자. 아래가 /editor를 이용해 페이지를 렌더 했을 때고  다음 이미지는 /post/id를 이용해 페이지를 렌더 했을 때다. 얼핏 보기에 다른 것이 없지 않나? 나도 그렇게 생각한다. 만약 이 두개의 endpoint를 합칠 수 있으면 이상적이다. 그러기 위해서 코드를 좀 살펴보자. 일단 /post/id에 핵심이 되는 코드다.  간단히 설명하면, HTTP POST 방식의 Body에서 id를 이용해 데이터베이스의 post 데이터를 추출 후 결과값을 주는 코드다. 전혀 RESTful 하지 않다. 자 그러면 /editor 를 살펴보자.  ?????? 당황스럽네. 백엔드 코드에서는 연관성을 찾을 수 없어서 프론트엔드 코드를 찾아봤더니 /editor 페이지에서 /post/id를 호출한 뒤 페이지의 나머지 구성 요소를 채우는 방식이었다. 이렇게 의미 없는 endpoint가 많아서 불필요한 것은 없애는 것이 좋다. 자 그러면 새로운 API의 endpoint들을 만들어 보자 HTTP GET   / - API 홈페이지 (보통 가능한 api endpoint들을 나열한다)  /posts - 모든 post들을 나열한다  /posts/{id} - 하나의 포스트를 id로 찾아서 준다  /posts/{id}/like - 하나의 포스트를 id로 찾아서 like만 준다  /posts?userid=xxx - 유저가 작성한 모든 포스트를 찾아준다  /posts?tags=xxx - 포스트를 주어진 tags를 기준으로 필터링해서 준다  /users - 모든 유저들을 나열한다  /users/{id} - 유저를 id로 찾아서 준다HTTP POST   /posts - 새로운 post를 만든다, body에는 id와 payload가 있을 예정  /users - 새로운 user를, body에는 유저 정보가 있을 예정HTTP PUT   /posts/{id} - 기존의 post를 업데이트 한다, body에는 payload가 있을 예정  /users/{id} - 기존의 user를 업데이트 한다, body에는 payload가 있을 예정HTTP DELETE   /posts/{id} - 기존의 post를 삭제한다  /users/{id} - 기존의 user를 삭제한다정리하고 보니까 깔끔해졌다. 이제 이것을 개발할 때 참고하면 된다. 유저 인증관련 endpoint는 잠시 보류해뒀다. 어떤 인증/인가 방식을 쓸 것인지 생각을 해야하기 때문이다. 마무리 정리하면:   백엔드의 endpoint를 RESTful하게 작성했다.다음 포스트에서는 인증/인가 방식을 정한 뒤 개발 환경을 셋업하는 것에 대해 알아보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-5%EC%9E%A5/"
      }]
