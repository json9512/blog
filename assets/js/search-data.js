var store = [{
        "title": "Hello there 👋",
        "excerpt":"I’m not really sure if I’ll maintain this dev blog in Eng or Kor, but this is my first post. Just to keep track of dev stuff I do. ","categories": [],
        "tags": ["devblog"],
        "url": "https://json9512.github.io/blog/first-post/"
      },{
        "title": "Python Code style",
        "excerpt":"애용하는 언어인 파이썬에 대해 좀 알아보고 복기하기 위한 포스트   파이썬은 원래 가독성이 좋은 프로그래밍 언어  가독성을 살려서 코드를 작성하게끔 pythonic 한 가이드라인이 있음  Python coding convention과 흔히 접하지 않는 것들에 대해 알아보자Python Code Styles 를 보며 내 마음대로 의역한 것 Content   General Rules  IdiomsGeneral Rules 1. Explicit code Bad def make_complex(*args):    x, y = args    return dict(**locals())Good def make_complex(x, y):    return {'x': x, 'y': y}딱 보면 무슨 코드인지 알 수 있도록 (self-explanatory) 2. One statement per line Bad print 'a'; print 'b'if x == 1: print 'a'if &lt;complex comparison&gt; and &lt;complex comparison&gt;:    # do some'inGood print 'a'print 'b'if x == 1:     print 'a'condition1 = &lt;complex comparison&gt;condition2 = &lt;complex comparison&gt;if condition1 and condition2:    # do some'in3. Function arguments 4 가지 방법이 있음   positional arguments - send(message, recipient) -&gt; send(\"Hello\", \"God\"), point(x, y) -&gt; point(0, 35) function 구동에 무조건 필요한 arguments  keyword arguments - send(message, to, cc=None) -&gt; send(\"Hello\", \"God\", \"Mom\") or send(\"Hello\", \"God\")기본값을 지정한 argument; function 구동에 필수적이지 않은 argument (cc)  arbitrary argument list - send(message, *args) -&gt; send(\"Hello\", \"God\", \"Mom\", \"Dad\" message argument 이후에 하나의 tuple로 입력 arguments를 저장함; tuple에 저장되는 값의 type이 다 다를 때 사용하는 것이 유용함  arbitrary keyword argument dictionary - send(message, **kwargs) -&gt; send(\"Hello\", to=God, cc=Mom)개발자의 판단에 따라 가장 적합한 방식으로 코드를 짜면 됨 4. Don’t use the magical wand 파이썬은 customizable하다. 하지만 기본적으로 작동되는 방식을 바꾸게 되면 가독성/효율이 떨어진다. 정말 필요할 때가 아니면 하지 말자 5. We are all responsible users 파이썬은 다른 언어에 있는 private 변수나 클래스 같은 것들이 기본적으로 사용되지 않는다. 이는 Java와 같이 보호적인 언어들과 다르다. 이유는 python 개발자는 모두 책임감이 있다고 믿기 때문이다. 개발자로서 자신이 사용하면 안되는 코드/특성은 사용을 하지 않는 것이 좋다. 하지만 private 특성을 만들지 못하거나 encapsulation이 불가능 하다는 뜻이 아니다. __를 특성/함수 앞에다가 붙이면 된다. class Foo:    '''        __test = \"Ac\"    '''    def __init__(self):        self.__test = \"Ac\"    def __print_me(self):        print(self.__test)# outsideb = Foo()b.__print_me() # no attribute errorprint(b.__test) # no attribute error6. Returning Values       함수가 복잡할수록 여러 곳에서 return 을 할 때가 종종 있다. 하지만 가독성을 중요시하고 코드가 더 직관적이고자 한다면, 여러 곳에서 return을 하는 것은 좋지 않다     보통 2가지의 경우에 함수에서 return을 한다          로직을 따라 정상처리가 됐을 때      에러가 났을 때        Refactoring을 위해 하나의 return 포인트를 유지 하는 것이 좋다def complex_function(a, b):    if not a:        return None # raising an exception might be better        if not b:         return None # raising an exception might be better        # Some complex code to compute x from a, b    # Resist temptation to return when compute succeeds    if not x:        # some code to compute x as plan-b    return x # single exit point for maintainabilityIdioms   pythonic 한 코드를 작성하는 방법은 아래와 같다1. Unpacking values   리스트에서 아이템 추출 시 enumerate() 함수 사용     for index, item in enumerate(some_list):     # do some'in with index and item        변수끼리 swap 할 때     # common  temp = b b = a a = temp # pythonic a, b = b, a        Nested unpacking     a, (b, c) = 1, (2, 3) # python 3 (new feature) a, *rest = [1, 2, 3, 4] # a = 1, rest = [2, 3, 4] a, *mid, c = [1, 2, 3, 4] # a = 1, mid = [2, 3], c = 4      2. Creating an ignored variable filename = \"awesomefile.txt\"basename, __, ext = filename.rpartition(\".\")# basename = awesomefile, __ = ., ext = txt# use __ to ignore vals# using _ might conflict since it's an alias for # gettext(), and _ is used to store the last operation # at the interactive prompt3. Creating lists A list of length - N arr_four = [0] * 4A list of length - N of lists arr_four_nested = [[] for __ in range(4)]Create a string from list some_list = [\"a\", \"b\", \"c\"]stringified = ''.join(some_list)4. Searching items in iterables some_set = set([\"i\", \"t\", \"e\", \"m\"])some_list = [\"i\", \"t\", \"e\", \"m\"]cond1 = \"t\" in some_setcond2 = \"i\" in some_set# Set/Dict is a hash table# Much faster than lists/tuples when searching a large dataset# Sometimes using lists is better because creating the hash table requires more memory 5. Zen of Python &gt;&gt;&gt; import this'''The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!'''With example on github 6. PEP 8   defacto code style for python. Available here7. Some Conventions 1. Check if variable equals constant # Badif attr == True:    return \"True!\"if attr == None:    return \"None!\"# Goodif attr:    return \"True\"if not attr:    return \"False\"if attr is None:    return \"None\"2. Access a dictionary element # Badd = {\"hello\": \"there\"}# Don't use dict.has_key()if d.has_key(\"hello\"):    print(d[\"hello\"])else:    print(\"default_value\")# Goodd = {\"hello\": \"there\"}print(d.get('hello', 'default_value')) # prints 'there'print(d.get('somein', 'default_value')) # prints 'default_value'# Or:if 'hello' in d:    print(d['hello'])3. Short ways to manipulate lists # Bad - needlessly allocates a list of all (gpa, name) entries in memoryvaledictorian = max([(student.gpa, student.name) for student in graduates])# Goodvaledictorian = max((student.gpa, student.name) for student in graduates)# Good# Generator functions for more complex tasksdef make_batches(items, batch_size):    '''    &gt;&gt;&gt; list(make_batches([1, 2, 3, 4, 5], batch_size=3))    [[1, 2, 3], [4, 5]]    &gt;&gt;&gt; generator = make_batches([1, 2, 3, 4, 5], batch_size=3)    &gt;&gt;&gt; next(generator)    [1, 2, 3]    '''    current_batch = []    for item in items:        current_batch.append(item)        if len(current_batch) == batch_size:            yield current_batch            current_batch = []    yield current_batch # Bad - never use list comprehension for its side effects[print(x) for x in some_list]# Goodfor x in some_list:    print(x)4. Filtering a List # Bad - Don't delete items when iterating through the lista = [3, 4, 5]for i in a:    if i &gt; 4:        a.remove(i)# Don't make multiple passes through the listwhile i in a:    a.remove(i)# Good# comprehensions create a new list objectfiltered_values = [value for value in some_list if value &gt; 4]# generators don't create another list filtered_values = (value for value in some_list if value &gt; 4)5. Modifying the values in a list # Bada = [3, 4, 5]b = a # a,b refer to same list objectfor i in range(len(a)):    a[i] += 3 # changing a will also change b# Good - create a new list objecta = [3, 4, 5]b = aa = [i+3 for i in a] # does not change b6. Read from a file # Badf = open(\"file.txt\")a = f.read()print(a)f.close()# Good - with open automatically closes the filewith open(\"file.txt\") as f:    for line in f:        print(line)7. Line Continuations # Bad - using \"\\\" might break if there is space afterwards\"\\ \"some_string = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\    aaaaaaaaaaaaaaaaaaaa\"# Good - open (, [, { will indicate the python interpreter to read until ), ], } closessome_string = (    \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"    \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\")","categories": [],
        "tags": ["python"],
        "url": "https://json9512.github.io/blog/python-code-style/"
      },{
        "title": "파이썬 고오급 정보 모음",
        "excerpt":"파이썬 개발자라면 알아야 할 고오급 정보들 ! 아래 출처에서 부분적으로 의역한 포스트 출처:   Real Python  Official Doc  Stackify  Programiz  Python Course목차   Garbage Collector  Memory Management  Global Interpreter Lock  All is One, One is all  Decorators  Decorators 2  Decorators 3Garbage Collector 출처: Real Python, Stackify, rushter Garbage Collector란? 메모리를 효율적으로 관리하기 위한 메커니즘이다. 장점은 메모리를 효율적으로 활용할 수 있는 것과 잔버그를 없앨수 있는 것. 단점은 GC를 구동하기위한 overhead가 생긴다. 파이썬의 GC는? 파이썬은 기존의 GC 방식과 다른 방식으로 GC를 구현했다고 한다. 참고 기존의 방식은 사용 가능한 objects를 찾는 방식이다:   root objects와 스택에 있는 objects를 찾고  이 objects에 연결되는 다른 objects를 찾으면, 찾은 objects들은 alive 한 것이다  나머지 objects를 free 해주면 된다하지만 파이썬에서는 위와 같은 방식이 불가능하다고 말한다. 이유는 파이썬 extension module의 작동 방식 상 root objects를 찾는 것이 어렵다는 것이다. 파이썬의 GC는 다음과 같다.   모든 것을 Object로 관리하고 reference counting을 한다  generational gc도 같이 사용한다위의 2가지를 활용해서 파이썬의 GC는 사용 불가능 한 objects를 찾는 방식이다. Reference Counting CPython 파이썬은 CPython이 베이스다. CPython은 C로 만들어졌다. CPython 외에도 다른 interpreter/compiler는 다음과 같다:   IronPython - .NET  Jython - JAVA  MicroPython - 마이크로 컨트롤러기본적으로 CPython이 하는 일은 다음과 같다.   .py에 적힌 코드를 bytecode로 compile 한다  .pyc (컴파일 된 코드)를 파이썬 가상 환경에서 실행한다파이썬의 object (int, list, etc)는 어떻게 관리가 될까? 파이썬에서는 모든 object가 PyObject로 표현된다. PyObject는 C struct 이고:   ob_refcnt: 이 object를 가르키고 있는 변수 개수  ob_type: 이 object의 type (int, list, etc)와 같은 특성을 가지고 있다 PyObject의 ob_refcnt 특성이 0이 될 때, 가비지 콜렉터는 PyObject가 차지하고 있던 메모리를 다시 free 시킬 수 있다. 주의: 만약 object가 자기 자신을 reference 한다면? class Foo(object):    pass# 'Foo' will be allocated in some place in the memorya = Foo() # ob_refcnt of Foo = 1# This will increment the ob_refcnta.obj = a # ob_refcnt of Foo = 2# Will not deallocate the memory occupied by 'a' # because the ob_refcnt is never 0del a # ob_refcnt of Foo = 1# this is a 'reference cycle'위와 같이 reference cycle이 생길 경우, Foo 가 차지하고 있는 메모리는 절대 비워지지 않는다. 파이썬에서는 이것을 해결하고자 Generation garbage collection 도 같이 사용한다. Generation Garbage CollectionGeneration garbage collection은 ref count 처럼 항상 돌아가는 것이 아니다. Cycle이 발생할 수 있는 컨테이너 형식 데이터 타입 (list, dictionaries, instances, classes, tuples)들만 확인한다. 2 가지 특징이 있다:   가비지 콜렉터가 메모리 내에 모든 object를 track 한다. collection process에서 살아남은 object들은 다음 generation으로 넘어간다. 파이썬의 garbage collection process의 generation은 총 3 개다.  각 generation 마다 threshold 가 있다. 이 threshold는 가비지 콜렉터가 track하는 object의 최대 개수이다. 만약 threshold를 넘어서게 되면, collection process가 시작되고 살아남은 object만 다음 세대로 넘어간다. 이 threshold는 개발자가 직접 바꿀 수 있다. Instagram은 실제로 이 기능을 해제하여 서버를 10%가량 더 효율적으로 만들었다.Generational GC가 reference cycle을 어떻게 감지하는지 알고 싶다면 이 글과 이 PEP-442을 읽도록 하자. PEP-442는 원글에서 말한 finalizers관련 문제를 해결한 방법을 서술하고 있다. Memory Management 컴퓨터에서 프로그램이 실행될 때, OS에서 프로그램을 위해 할당하는 메모리는 fixed하다. 프로그램은 정해진 메모리 관리 알고리즘에 따라 주어진 메모리를 관리한다. CPython Memory Management  위 그림과 같이 OS가 할당한 메모리 중 Python은 메모리를 크게 Object를 위한 메모리와 그 외 메모리로 분할한다. 그리고 Object를 위한 메모리에 CPython의 object allocator가 할당된다. 이는 새 object 가 메모리에 할당되거나 삭제될 때마다 실행된다.  CPython 메모리 관리에는 크게 3 가지가 존재한다.   Arenas          가장 큰 메모리 덩어리      OS가 메모리를 읽을 때 사용하는 블록과 연결된다      Python은 Arena의 크기를 256 KB로 추정한다      eg. 256KB - 256KB - 256KB 단위로 OS가 읽는다      사실 뭔 소린지 잘 모르겠다 하하        Pool          가상 메모리      4 KB      더 작은 메모리 블록으로 이루어져 있다      Pool내에 모든 블록은 같은 “size class”다        Blocks          8 bit 단위로 나뉘어진 “size class” 가 있다      eg. 데이터가 7 bytes 면 “size class”는 8 (bytes) 이다, 데이터가 10 bytes 면 “size class”는 16 (bytes) 이다.      Pools   같은 size class의 블록들로 구성된다  같은 size class를 담고 있는 pool들과 double-linked list를 형성한다  3 가지의 상태를 가진다:          used - 데이터를 저장할 블록을 가지고 있을 때      full - 모든 블록이 데이터로 가득 차 있을 때      empty - 데이터가 존재하지 않고 , 아무 size class로 구성된 블록들을 만들 수 있을 때        usedpools 은 새로운 객체가 저장 될 수 있는 block이 있는 모든 pool 리스트다 (저장되는 객체의 size는 block의 size class가 수용 가능 해야한다). 수용 가능한 블록을 찾을때 usedpools 리스트에서 먼저 찾는다.  freepools 는 모든 empty 상태의 pool을 기록한 리스트다.  full에서 특정 블록을 free 할 경우, 그 pool의 상태는 used로 바뀐다. Blocks   3가지 상태가 있다:          untouched - 할당되지 않은 메모리      free - 할당 됐으나 CPython이 free 한 메모리      allocated - 할당 된 메모리        위 그림과 같이, 각 pool 에는 자기 pool 내에 free 블록을 가르키는 포인터가 있다  free 블록이 꼭 연속성을 가져야 하는 것은 아니다:    free 블록을 가르키는 포인터는 free 블록들을 탐색할 수 있는 single linked list다  만약 필요한 메모리의 사이즈가 free 블록의 사이즈보다 클 경우, untouched 블록들을 사용한다Arena   여러 개의 pool로 구성되어 있다  double-linked 리스트다  Arena내에 할당 가능한 pool의 갯수를 기준으로 정렬이 되어있다 (오름차순)  오름차순인 이유?          CPython이 특정 메모리를 free한다는 것은 OS에게 그 메모리를 돌려준다는 뜻이 아니다. CPython은 메모리를 free한 이후에도 그 메모리를 계속 사용한다.  즉 Arena를 더 적게 사용하는 것이 전체적인 프로그램의 메모리를 더 적게 사용하는 것이다.      Global Interpreter Lock source: Real Python   간단히 말하면 mutex (lock) 이다. 단 하나의 thread만 Python Interpreter를 쓸 수 있게 하는 장치다  CPU를 이용한 multi threaded 앱에서는 bottleneck이 될 수 있다  아무리 내 코드가 multi threaded용으로 짜여졌다고 하더라도, 실제로는 single threaded 앱처럼 실행이 된다왜 도입 됐는가?   일단 Python GIL은 thread라는 개념이 존재하기 전에 도입됐다  파이썬 메모리 관리 특성 상 object에 대한 race condition이 생길 수 있는데, 이를 방지 하려면 일종의 lock이 필요했다  object 단위로 lock을 도입하기에는 deadlock 문제가 생기고 성능이 저하 될 수 있어서 GIL을 도입했다.  가장 간단하고 효과적이었기 때문이다Parallel program은 파이썬으로 불가능한가?   Multi-threaded 말고 multi-process 방법으로 접근하면 앱을 parallel하게 짤 수 있다  혹은 다른 python interpreter를 사용하면 된다. GIL은 CPython 에만 존재하기 때문이다 (CPython이 Python의 베이스다)All is One, One is all 파이썬에서 모든 것은 객체다. 변수, 함수, 클래스 등등 다 객체다. PyObject라는 객체로 모든 것이 관리되기 때문에 이것을 이해하면 신기한 방법으로 코드를 짤 수 있다. 몇 가지만 알아보자면:   First class function: 파이썬은 변수, 클래스뿐만 아니라 함수를 다른 함수의 리턴 값 혹은 인자 (parameter) 로 쓸 수 있다. 이는 함수가 객체이기 때문.  Closure function: 함수(A) 내의 함수(B)가 함수(A)가 가진 변수를 저장하고 사용하는 함수(B)말로 표현하기 어렵다. 코드로 보자. First class function import sysinputs = sys.stdin.readlineK, V = map(int, input().split(' '))위 코드를 살펴보면 함수 sys.stdin.readline을 변수 inputs에 저장한 뒤, map 함수에서 inputs()로 실행 시키는 것을 볼 수 있다. 이런 방식으로 변수에 함수를 저장하는 것이 first class function의 특징이라고 볼 수 있다. 또 다른 예를 들면, map 함수에 인자로 int, input().split(' ') 이 있는 것을 볼 수 있다. 여기서 int 인자는 사실 함수다. 즉, 위의 코드를 실행하면 sys.stdin.readline 함수로 읽은 유저의 입력 값을 ' '로 나누어서 array화 시킨 뒤 map 함수를 이용해 array안에 모든 element를 int() 화 시켜주는 코드다. 이런식으로 함수를 변수처럼 인자로도 주고, 변수에도 저장하고, 다른 함수에서 리턴 값으로도 주고 할 수 있는 것이 바로 first class function인 것이다. 이 모든 것이 가능한 이유는? 파이썬에서 모든 것은 객체기 때문이다. Closure function def multiply_by(n):    def multiplier(x):        return x * n        return multipliertimes3 = multiply_by(3)print(times3(9)) # 27위 코드를 잘 보면 방금전에 배운 First class function의 특징을 잘 이용하고 있다. 일단 multiplier() 함수를 먼저 확인해 보자, 이 함수는 x 와 n을 곱한 값을 리턴해 주는 함수다. x는 이 함수의 인자 (parameter)로 받는다. 그럼 n은? n은 보다시피 multiplier 함수를 감싸고 있는 multiply_by 함수의 인자다. 즉, multiplier 함수는 본 함수의 인자 x 와 multiply_by 함수의 인자 n을 사용하는 함수다. 그리고 multiply_by 함수는 multiplier 함수를 리턴한다. first class function 특징이다. 밑에 코드를 보자. times3 = multiply_by(3) 이 코드가 실행이 되면 3 은 누구의 인자로 가게 될까? multiply_by의 인자가 3이 된다. 곧 n 은 3이 된다. 이후 times3(9) 이라는 코드가 있다. 이걸 풀어보면 multiplier(x=9)이라는 코드가 되는 것이다. 그러면 당연히 값은 n * x니까 3 * 9 = 27 가 된다. Closure 함수의 특징은 주어진 것을 기억할 수 있는 것이다. 심지어 multiply_by 함수를 지워도 times3 함수는 주어진 3의 값을 기억하고 쓸 수 있다. def multiply_by(n):    def multiplier(x):        return x * n        return multipliertimes3 = multiply_by(3)del multiply_byprint(times3(9)) # 27print(multiply_by(3)) # NameError: name 'multiply_by' is not defined정리   Closure 함수는 아래와 같은 특징이 있다:          함수(A)안에 함수(B)가 있고      함수(B)는 함수(A)가 쓸 수 있는 변수, 객체, 클라스를 사용하고      함수(A)가 함수(B)를 리턴해야한다        언제 쓰는 것 일까?          OOP를 구현하기 위해 사용하기도 하고      특정 함수의 구조를 숨기기 위해서도 사용하며      Python Decorator 함수에서도 사용된다        무조건적으로 함수(A)에 주어진 값을 숨길 수 있나?          아니다                &gt;&gt;&gt; times3.__closure__[0].cell_contents  3                    위와 같이 보고자 하면 closure 함수가 무엇을 기억하고 있는지 볼 수는 있다.      Decorators 고오오급 정보까지는 아니지만 파이썬으로 개발하다가 보면 가끔식 이런 함수를 볼 때가 있다. @whatsthisdef someFunc():    print(\"이게 뭐야\")someFunc()# 출력:# This is the decorator,# 이게 뭐야# Decorator ended이런 함수를 Decorator를 사용한 함수라고 표현하는데 위에서 Decorator는 whatsthis에 속한다. Decorator란 Closure 함수를 사용해서 특정 함수의 앞, 뒤로 간단하게 기능을 추가해주는 것이다. 자 whatsthis 함수를 한번 보자. def whatsthis(func):    def wrapper():        print(\"This is the decorator, \")        func()        print(\"Decorator ended\")    return wrapper잘 살펴보면 Closure 함수인 것을 알 수 있다. wrapper는 whatsthis 함수의 func 인자를 사용하는 함수고 whatsthis 함수는 리턴 값으로 wrapper 함수를 준다. wrapper 함수의 func() 함수는 우리가 인자로 주는 함수인 것을 알 수 있다. 이 func() 함수가 @whatsthis 아래에 작성이 되는 함수인 것이다. 다시 원문 코드를 한 번 보자. @whatsthisdef someFunc():    print(\"이게 뭐야\")someFunc()# 출력:# This is the decorator,# 이게 뭐야# Decorator ended@ 부호를 사용하고 Closure 함수명을 적어준 뒤, 아래 해당 Closure 함수에 사용할 함수를 적어 주게되면 해당 함수는 인자 함수로 사용된다. 현재 위의 코드를 풀어서 보면, someFunc()는 사실 whatsthis 함수의 wrapper 함수인 것이다. 그리고 wrapper 함수 안에 func()는 someFunc 함수 인 것이다. 이렇게 설명하면 헷갈리니까 someFunc()를 변수명에 저장하자 def whatsthis(func):    def wrapper():        print(\"This is the decorator, \")        func()        print(\"Decorator ended\")    return wrapper@whatsthisdef someFunc():    print(\"이게 뭐야\")x = someFuncx()# 출력:# This is the decorator,# 이게 뭐야# Decorator ended자, x는 someFunc 함수다. someFunc는 wrapper 함수다. wrapper 함수는 whatsthis 함수의 인자 func를 사용한다. func는 someFunc다. 고로, x는 someFunc 함수를 사용하는 wrapper 함수다. 이번에는 인자를 받을 수 있는 Decorator를 만들어보자 def whatsthis(func):    def wrapper(myname):        print(\"This is the decorator,\", myname)        func()        print(\"Decorator ended\")    return wrapper@whatsthisdef someFunc():    print(\"이게 뭐야\")x = someFuncx(\"마이클\")# This is the decorator, 마이클# 이게 뭐야# Decorator ended위를 보면 myname이라는 변수가 인자로 주어진다. 이 인자를 주는 곳은 함수를 호출 할 때다. x('마이클')을 호출하면 마이클이라는 이름이 잘 표현되는 것을 알 수 있다. 만약 someFunc() 함수에서 인자를 받고 싶다면? def whatsthis(func):    def wrapper(myname):        print(\"This is the decorator,\")        func(myname)        print(\"Decorator ended\")    return wrapper@whatsthisdef someFunc(name):    print(\"이게 뭐야, \", name)x = someFuncx(\"마이클\")# This is the decorator,# 이게 뭐야, 마이클# Decorator ended이런식으로 활용하면 된다. wrapper 함수의 myname 인자가 그대로 func(myname)에 인자 값으로 주어진다. someFunc(name) 함수의 name은 myname이 되는 것이다. x는 wrapper 함수인 것을 인지하면 이해하기가 쉬워진다. 자 이제 Decorator를 알아보았다. 하지만 Decorator는 중첩이 가능하다. @whatisthis@whatisthis2def someFunc():    print(\"살려줘\")someFunc()# 출력 :# This is the decorator,# Hello There,# 살려줘# Bye# Decorator ended전체 코드를 살펴보자. def whatisthis2(func):    def wrapper():        print(\"Hello There, \")        func()        print(\"Bye\")        return wrapperdef whatsthis(func):    def wrapper():        print(\"This is the decorator,\")        func()        print(\"Decorator ended\")    return wrapper@whatsthis@whatisthis2def someFunc():    print(\"살려줘\")someFunc()간략히 설명하자면 @whatsthis Decorator의 인자 함수는 whatisthis2 함수가 된다. 그리고 @whatisthis2의 인자 함수는 someFunc 함수가 된다. 그리고 whatsthis 의 리턴 함수는 wrapper 함수인데, 이 wrapper 함수는 whatisthis2 의 wrapper 함수를 사용하는 것이다. 즉, someFunc 함수를 실행 시키면 사실 아래 코드가 실행되는 것이다 print(\"This is the decorator,\") # whatsthis의 wrapper 함수print(\"Hello There\")            # whatisthis2의 wrapper 함수print(\"살려줘\")                 # someFunc 함수print(\"Bye\")                    # whatisthis2의 wrapper 함수print(\"Decorator Ended\")        # whatsthis의 wrapper 함수머리가 쿠크다스 마냥 뽀개질거 같은데 왜 쓰는 것일까. 보면 알겠지만 한 번 이해만 한다면 가독성이 뛰어난 방법으로 코드를 짤 수 있기 때문이다. 예를 들면 @loggerdef someFunc():    pass위와 같이 Decorator 이름만 잘 지어준다면 가독성이 매우 뛰어나다. @logger가 내부적으로 정확히 어떻게 돌아가는지 알 필요도 없고 사용법만 알면 되니까 개발자 입장에서는 상당히 편리한 기능이라고 볼 수 있다. Decorators 2 Decorator는 함수를 꾸며주는 것이라고 배웠을 것이다. 맞는 말이다. 사실 함수뿐만 아니라 Class도 가능하다. def Foo(obj):    def wrapper():        print(\"Creating object\")        print(obj().name)        print(\"Object created\")    return wrapper@Fooclass Bar:    def __init__(self):        self.name = \"test\"    Bar()# 출력 :# Creating object# test# Object created이런식으로 Bar 클라스를 Foo closure 함수에서 사용을 하는 것이다. 혹은 Foo Decorator 자체를 class 객체로도 만들수있다. class Foo:    def __init__(self, cls):        self.x = cls        def __call__(self):        print(\"testing\")        self.x().run()        print(\"test done\")@Fooclass Bar:    def __init__(self):        self.name = \"test\"        def run(self):        print(self.name)    Bar()# 출력 :# testing# test# test done이런 경우 Decorator 객체인 Foo의 __call__ 내장 함수를 wrapper 함수라고 생각하면 된다. 그리고 Foo의 __init__ 함수의 인자로 Bar 가 주어진다고 보면 된다. 이런식으로 Decorator를 쓰는 경우는 드문 것 같다. 마찬가지로, 이런 방식도 가능하다 class Foo:    def __init__(self, func):        self.x = func        def __call__(self):        print(\"testing\")        self.x()        print(\"test done\")@Foodef someFunc():    print(\"Yo\")    someFunc()# 출력 :# testing# Yo# test done쉽게 생각하면 @ 다음에 오는 이름의 함수/객체는, 바로 아래 있는 함수/객체를 인자로 사용한다. # 함수를 쓰든@Foodef Bar():    pass# class를 쓰든@Fooclass Bar:    pass이것은 사실: Bar = Foo(Bar)인것이다 일반적으로 Decorator를 많이 볼 일이 없을수도 있다. 하지만 개발자라면 언어가 제공하는 개발 방법을 잘 알고 있고 그 방법들을 적재적소에 활용하는 것이 중요하다고 생각해서 포스트를 남겨 보았다. Decorators 3 최근 블로그를 읽다가 Decorator에 대해 새로운 사실을 알았다. Decorator안에 inner 둘러싸는 코드는 @decorator_name 선언할 때 실행이 된다. def some_dec_func(func):    print(\"hey\")    def inner():        func()        return inner@some_dec_funcdef hello():    print(\"hello\")# Note: 함수를 선언하기만 하고 사용하지는 않는다.# 이 상태로 코드를 실행하면 다음과 같이 출력된다:# hey# 왜 일까?이유는 Python에서 Decorator를 사용하는 것은 some_dec_func(hello)를 실행하는 것이다. 즉, 이 파일을 compile하게 되면 interpreter가 @some_dec_func 라인과 밑에 있는 함수를 읽고 some_dec_func(hello) 를 실행하게 되면서 some_dec_function의 print(\"hey\")가 실행이 된다. 그러면 Decorator 함수를 선언을 하게 되면, 어디에 있든 inner 앞 뒤의 코드는 자동적으로 실행되는 것인가? 그렇다. ","categories": [],
        "tags": ["python"],
        "url": "https://json9512.github.io/blog/python-advanced/"
      },{
        "title": "호주 스타트업 캡스톤 후기",
        "excerpt":"이 글은 학과 마지막 1년 동안 호주 스타트업 Bidhive 와 CV builder 프로젝트를 한 후기다. Bidhive는 호주 B2B 시장에서 기업들의 입찰 매니지먼트 서비스를 제공하는 기업이다. 기업들이 입찰하는 과정을 좀 더 효율적으로 관리할 수 있게 도와주는 플랫폼을 서비스하고 있고 실제로 호주를 비롯해 유럽권과 미국권에서 펀딩을 추진하고 있다.알만한 고객으로는 세계 최대 해운회사 덴마크의 머스크 라인이 있다. Bidhive 측에서 요구한 것은 간단히 말하면 이력서 매니지먼트 플랫폼이었다. 과정 시작부터 코로나 19와 겹치면서 모든 미팅이 줌을 통해 진행되었다. 실제로 프로젝트가 끝날 때까지 단 한 번도 Bidhive 팀을 만나지 못 했다. 처음 Bidhive가 제시한 요구사항은 상당히 high-level에서의 플랫폼을 이야기 하고 있었고 첫 미팅을 하고 나서 Bidhive 역시 정확히 무엇을 원하는지 모른다는 것을 파악했다. 이후 나를 포함한 학생 4인의 개발팀과 Bidhive의 CEO, CXO와 매주 줌 미팅을 진행하며 서비스의 기능이 무엇인지부터 시작해 버튼의 모양까지 하나씩 다 이야기 해 나가면서 brainstorming을 했다.첫 2주 정도는 기업간의 입찰 시스템에 대해서 무지했던 우리 개발팀이 입찰 시스템에 대해 공부하고, Bidhive 플랫폼을 직접 local development 버전으로 실행 해 보는데 할애했다. 그 후로는 계속된 줌 미팅으로 생각들을 정리하기 시작했으며, 정리한 내용을 Slack, Mirro, Asana, Trello, Google Drive 등에 저장하기 시작했다. 전반적인 분위기는 상당히 좋았다. 시간이 지날수록 1년안에 개발하지 못하는 수준의 기능들에 대해 이야기 하기 시작했으며, 최소한의 서비스 기능들을 user story화 시켜서 엑셀로 정리를 하기 시작했다. 개발 스택   프론트: Reacth with TypeScript  백엔드: Django (Python)  DB: PostgreSQL사실 이때까지만 해도 CI/CD나 Docker, AWS, 분산 클라우드 서비스 등 전반적으로 웹 앱을 설계하는 능력이 많이 부족했다. (물론 지금도 부족하다.) 더군다나 이런 내가 팀 내 리드 개발자였다. 너무 부족했던 나 자신을 돌아보는 계기가 되기도 했다. 아무튼, 위 기술스택은 기존 Bidhive 플랫폼과 똑같았고 이유는 Bidhive 측이 UI 적으로나 기능적으로나 자기들의 기존 플랫폼과 연동되고 일관성있게 만들고 싶다고 했기 때문이다. (지금 와서 생각해보면 사실 언어/프레임워크는 상관이 없었다.) 개발 스택 정하고, 기본 뼈대를 구축하고, 전체 팀이 개발을 시작한지 2~3주만에 1학기가 끝났다. 이 시점에 우리는 아무것도 없는 백엔드와 DB, 그리고 프론트엔드는 Navbar만 있는 페이지 4개가 끝이었다. 방학 1달 동안에는 캡스톤 미팅을 하지 않았고 그 기간동안 머신러닝을 이용해 기업이 원했던 이력서 추천 기능의 개념을 증명하는 간단한 모델을 만들었다. 짧은 프레젠테이션으로 만들어서 발표를 5분 가량 했는데 Bidhive가 마음에 들어했고 이 발표를 했던게 추후에 영입 제의를 한 결정적 이유이지 않을까 생각한다. 이후 2학기가 시작되자마자 개발을 재개했고 이때까지도 MVP에 정확히 어떤 기능들을 집어 넣을지에 대한 의견을 조율하고 있었다. 이때부터 리드 개발자로서 시간이 없다는 것을 인지하고 매일 적어도 2 시간씩 개발에 매진했다. 2학기를 3주 정도 남기고서야 Bidhive와 MVP를 조율할 수 있었고 이전까지 부분적으로 구현 시켜놨던 몇 몇개의 기능들을 지우고 수정하는 시행착오를 겪었다. 이때 테스트 코드의 중요성과 초반 설계 작업이 얼마나 중요한지 깨달았다. 지속된 에러로 밤을 새는 것은 기본이고 코드 역시 날이 갈수록 난장판이 되어가고 있었다. 설상가상으로 학기 말 여러 과제들이 겹쳐서 팀원들이 다른 과제를 하느라 미팅을 이탈하는 빈도가 늘어났고 개발이 더뎌지게 되었다. 하지만 리드 개발자로서 MVP의 요구사항을 꼭 성공 시키겠다는 마음을 먹었고 팀원에게 앞으로 구현해야 할 기능들을 할당해주고 나 역시 Refactoring과 MVP에 핵심이 되는 기능을 구현하기 시작했다. 결과 결과적으로 MVP에서 약속한 기능들을 모두 개발 할 수 있었다. 하지만 1학기 초창기에 서비스에 대한 구축을 시작했을 때 의논했던, 인공지능과 본 플랫폼과의 호환 같은 핵심 기능들은 빠져 있는 상태였다. Bidhive가 실질적으로 만들고자 한 플랫폼은 이것 (Demo)이지만, 우리가 1년 동안 개발 했던 것은 저 프로젝트의 뼈대라고 볼 수 있는 CV를 직접적으로 만드는 기능이었다. 이하 개발한 MVP의 스크린 샷: 유저 이력서 페이지  기업 이력서 페이지  검색 페이지  결론 1년 동안 고생한 만큼 성적도 성과도 좋았지만 개발자로서 만족 할 만한 수준의 서비스는 아니었다. 일단 초기 설계 과정부터 제대로 된 개발 디자인:   서버는 RESTful 할 건지          완벽한 RESTful 모델이 아님        유저 인증/인가는 어떻게 할 건지          django의 기본 유저 인증/인가 사용 (인가에 버그가 있어서 완벽하지 않음)        Database indexing은 어떤 방식으로 시도 할 건지          고려하지 않음        프론트엔드의 state 관리는 어떻게 할 건지          jotai 사용        코드 Quality는 어떤 방식으로 관리 할 건지          개인에게 맡기고 전체적인 것은 고려하지 않음      등을 하지 못 했던 것과 테스트 코드의 부재 및 CI/CD pipeline의 부재가 아쉽다. 또한 개발 막바지에 기능 개발을 분담했는데 이 과정에서 개발을 많이 안해본 팀원에게 비교적 중요한 유저 인증을 맡긴다던지, 조금 더 꼼꼼하게 팀원들의 코드를 리뷰하지 않았던 것이 리드 개발자로서 아쉬움이 많이 남는다. 코로나19와 너무 늦게 확립된 MVP 기능들과 개개인의 여러가지 악재들이 겹친 상황에서도 끝까지 개발을 완수한 것이 의미가 있었던 프로젝트였다. 여담   B2B 시장도 일반인들이 쉽게 접하기 어렵지만 상당히 규모가 크고 도전해 볼 만한 시장이라는 것을 알게 되었다.  원격 근무, 개발, 미팅 만으로 이런 프로젝트가 가능하다.  스타트업은 아무나 하는 것이 아니다  방학기간 동안 만든 추천 모델은 NLP를 기반으로 search keyword를 통해 유저의 이력서를 추천해 주는 시스템이다. 기능적으로는 특정 입찰에서 추진하는 프로젝트에 알맞는 인원을 찾고자 할 때, 가장 잘 어울리는 인원의 이력서를 결과 창 가장 먼저 배치하기 위함이었다.","categories": [],
        "tags": ["호주"],
        "url": "https://json9512.github.io/blog/%EC%BA%A1%EC%8A%A4%ED%86%A4/"
      },{
        "title": "Dijkstra's Shortest Path",
        "excerpt":"출처: GeeksforGeeks, Baeldung, cppsecrets 유명한 다익스트라의 최단 거리 찾기 알고리즘 Prim’s Minimum Spanning Tree 알고리즘과 유사하다. 그리디 알고리즘이다. 다른점:   다익스트라 알고리즘은 최단거리를, 프림의 알고리즘은 Minimum Spanning Tree를 찾는 알고리즘이다  다익스트라 알고리즘은 undirected, directed graph 모두 적용이 되지만 프림의 알고리즘은 undirected graph에만 적용된다  다익스트라 알고리즘은 edge의 weight가 단 하나라도 음수(negative)면 최단 거리를 찾지 못 할수도 있다간단한 예를 들자면, 다익스트라 알고리즘은 가장 적은 시간/연료로 A 포인트에서 B 포인트까지 길을 찾는 것이고 프림의 알고리즘은 가장 적은 시간/재료로 여러개의 포인트가 서로 연결 되도록 (사이클 없이) 도로를 까는 것이다. 방법   최단 거리 경로를 저장하는 set를 만든다. (empty set)  모든 vertices 간의 거리 값을 지정한다. 시작점을 제외한 모든 vertices 거리 값은 무한대가 된다. 시작점은 0으로 만든다  모든 vertices가 최단 거리 경로를 저장하는 set에 들어올때까지 이하 반복 한다:          set에 포함되지 않는 vertices 중 최단 거리를 가지고 있는 vertex u를 고른다      set에 포함 시킨다      vertex u 와 인접한 모든 vertices의 거리 값을 갱신한다.      Python def createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = createGraph()# set starting pointinitial = 'D'# keeps track of pathspath = {}adj_node = {}# keeps track of nodes yet to visitqueue = []# create adjacency graph with distance values # intialized as infinity # except the initial (starting) node for node in graph:    path[node] = float('inf')    adj_node[node] = None    queue.append(node)path[initial] = 0# while queuewhile queue:    # for visualization    '''    print(\"Graph: \\n\", graph)    print(\"Path: \\n\", path)    print(\"Adj_nodes: \\n\", adj_node)    print(\"Queue (nodes to visit): \\n\", queue)    '''    # find the node with the     # minimum distance value    min_key = queue[0]    min_val = path[min_key]    for n in range(1, len(queue)):        if path[queue[n]] &lt; min_val:            min_key = queue[n]            min_val = path[min_key]    # update the current node as the node with the    # minimum distance    current = min_key    # remove the node from 'to visit' queue    queue.remove(min_key)    # iterate through the nodes    # Update the distance value using the current node    for i in graph[current]:        alternate = graph[current][i] + path[current]                if path[i] &gt; alternate:            path[i] = alternate            adj_node[i] = currentdestination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')# prints:# H &lt;- J &lt;- E &lt;- B &lt;- A &lt;- D &lt;-자세히 위의 코드를 조금 더 자세히 살펴보자 def create_graph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = create_graph()이 코드를 실행 하면 아래와 같은 그래프가 형성된다  우리의 목적은 ‘D’ 에서 ‘H’ 까지 최단 거리를 찾는 것 이다. # set starting pointinitial = 'D'# keeps track of pathspath = {}adj_node = {}# keeps track of nodes yet to visitqueue = []# create adjacency graph with distance values # intialized as infinity # except the initial (starting) node for node in graph:    path[node] = float('inf')    adj_node[node] = None    queue.append(node)path[initial] = 0시작 노드 initial을 지정 해주고 추후에 사용할 path 와 adj_node를 선언해준다 path는 시작 노드에서 특정 노드까지 최단 거리 값을 저장 시키기 위한 것이고 adj_node는 특정 노드의 최단 거리 값을 계산했을때 사용한 인접한 노드를 저장해 주는 것이다. queue는 현재 최단 거리 값을 계산 해야 할 노드들을 저장한 리스트다. 이후 for 문에서 그래프 속 각 노드들의 최단 거리 값을 inf로 선언해주고 adj_node 값도 초기화 시켜준 뒤 queue에 저장한다 path[initial] = 0 로 시작 노드를 지정해준다 # while queuewhile queue:    # find the node with the     # minimum distance value    min_key = queue[0]    min_val = path[min_key]    for n in range(1, len(queue)):        if path[queue[n]] &lt; min_val:            min_key = queue[n]            min_val = path[min_key]    # update the current node as the node with the    # minimum distance    current = min_key    # remove the node from 'to visit' queue    queue.remove(min_key)이후 queue에 노드가 없어질때가지 while문을 돌린다. min_key - 최단 거리 값을 가지고 있는 노드 min_val - 최단 거리 값 min_key 와 min_val을 queue의 첫 번째 노드로 선언해준 뒤 queue에 남아 있는 나머지 노드들과 비교를 하며 가장 거리 값이 낮은 노드를 찾는다 이후 찾은 노드를 current에 저장해주고 queue에서 해당 노드를 지운다     # iterate through the nodes    # Update the distance value using the current node    for i in graph[current]:        alternate = graph[current][i] + path[current]                if path[i] &gt; alternate:            path[i] = alternate            adj_node[i] = current이후 현 노드 (최단 거리 값을 가진)의 인접 노드들을 for문을 돌린다 alternate - 현재 노드와 인접한 노드의 거리 값 + 현재 노드까지의 최단 거리 예를 들자면, current가 A면 인접 노드는 B, C, D 가 되고, 위에 for문이 각각의 인접 노드의 거리 값을 현재 노드 A의 최단 거리 값과 더 한다 (alternate). 즉 A를 이용해서 각 인접 노드로 가는 거리 값이다 이 alternate 값과 현재 인접 노드의 거리값 path[i]를 비교해서 alternate가 더 작을 경우, 인접노드의 최단 거리 값(path[i])을 alternate로 바꾸고 adj_node에 현재 노드 (current)를 저장해 준다. 예를 들면 A의 인접노드 B를 A를 통해서 가게 됐을때 그 값이 현재 B의 최단 거리 값 보다 작으면, B의 값을 바꿔주고 A를 사용했다고 adj_node에 명시해 준다 여기까지만 코드를 실행 시키면 다익스트라 알고리즘을 이용해 시작 노드 D에서 나머지 노드들까지 가는 최단 거리가 계산된다. destination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')위의 코드를 실행 시키면 destination에 저장된 목적지 노드까지의 경로가 나온다. 위 코드는 while 문만 간단히 설명하자면 destination = adj_node[destination] 로 while문이 돌때마다 현재 노드(destination)를 현재 노드의 최단 거리 값을 계산 할 때 사용했던 인접 노드(adj_node[destination])로 바꿔준다 이후 if문으로 destination 이 None일때 while문을 종료시키면 시작 노드 initial에서 목적지 노드 destination까지의 최단 경로를 알 수 있다. 실제로 확인을 해보면 D에서 A를 통해 H를 가는 경로와 F를 통해 H로 가는 경로 값을 비교해보면 A가는 경로가 최단 경로인 것을 알 수 있다. A를 통할 경우: 10 + 1 + 5 + 7 + 2 = 25 F를 통할 경우: 7 + 9 + 4 + 7 + 2 = 29 위 알고리즘의 Time Complexity는 O(V^2)이다. 하지만 우선 순위 큐를 사용하면 시간 복잡도를 O(V + E log V) 까지 줄일 수 있다. 관련 포스트 Dijkstra 최단 경로 알고리즘을 사용한 문제 백준 다익스트라로 분류된 문제 [프로그래머스] 배달 [프로그래머스] 가장 먼 노드 요런 문제들을 풀려면 O(V^2)의 시간 복잡도로는 풀 수가 없다. ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dijkstra-shortest-path/"
      },{
        "title": "OSI 7 Layers",
        "excerpt":"출처: 위키피디아, 양햄찌님의 블로그 Open Systems Interconnection model (OSI) 7 계층에 대해 알아보자       OSI 7 계층은 참조 모델이다. 컴퓨터 또는 전자 통신 장비끼리의 통신 과정을 위한 모델이다.         OSI 7 계층이 만들어진 이유는 장비에 상관없이 모든 컴퓨터/전자기기 간 통신 과정에 기준을 세우기 위함이다.         국제표준화 기구 (ISO) 에서 1984년에 만들었다.         통신이 일어나는 과정을 단계 별로 볼 수 있다.         각 Layer는 독립적이다. 즉 Physical Layer에서 문제가 생기면 Physical Layer와 연관 있는 장비만 손보면 된다.         상하구조를 가지고 있다. Layer 7 이 작동하려면 Layer 1 ~ 6 까지 문제가 없어야 한다.         유지관리가 수월하고, 범용적이다   7 Layer (밑에서부터 위로):   Physical Layer  Data Link Layer  Network Layer  Transport Layer  Session Layer  Presentation Layer  Application Layer앞 글자만 따면 P - D - N - T - S - P - A   People Don’t Spa 로 외웠다 Physical Layer   하위층  Protocol Data Unit = bit  물리적 매체 (Wire)등을 통해 bit를 전송한다  물리적 장치와 인터페이스가 전송을 위해 필요한 기능과 처리절차를 규정하고 있다출처: studytonight 하는 것   Representation of Bits - 0 과 1로 이루어진 비트가 어떻게 encoding (시그널로 변환) 될 건지를 정함  Data rate - 보내는 데이터 레이트를 정함. 보통 bits per second 단위  Synchronization - 비트 단위로 transmitter (보내는 쪽)와 receiver (받는 쪽)의 동기화 시킴  Interface - 기기와 전송 매체간 전송 인터페이스를 정함. (Ethernet, Radio waves)  Line configuration - 기기와 전송매체를 연결 시킴: point-to-point configuration, multi point configuration  Topologies - 기기는 다음과 같은 구성으로 연결이 돼야한다: Mesh, Star, ring, bus  Transmission Modes - 기기간 전송 방향성을 정함: Simplex(one signal is transmitted in one direction), Half-Duplex (data is transmitted in both direction, not at the same time), Full-Duplex (data is transmitted both direction simultaneously)  Broadband, Baseband 전송을 담당함Data Link Layer   하위층  PDU = Frame  노드와 노드 사이의 데이터 전달  단순히 bit를 전하는 물리 계층에 신뢰성을 더하기 위한 흐름제어 및 오류제어 기능  LLC, MAC 두 개의 sub layer로 구성Network Layer   하위층  PDU = Packet  송신 측에서 최종 목적지까지 packet 전달  송수신 측의 논리주소 지정 및 패킷이 최종 목적지에 도달하도록 경로를 배정하는 라우팅 기능  데이터 링크의 물리주소는 패킷이 시스템으로 이동할 때마다 변경하지만, 네트워크 주소는 목적지까지 변하지 않음Transport Layer   하위층  PDU = Segment  네트워크 계층에서 패킷을 종단까지 전달한다면 (네트워크 주소), Transport Layer는 종단 내에서 최종 수신 프로세스로의 전달 (포트 주소)을 담당  분할/재조립, 연결/흐름제어, 오류제어Session Layer   상위층  PDU = message  통신하는 프로세스 사이의 대화제어 및 동기화를 담당Presentation Layer   상위층  PDU = message  데이터의 변환, 압축, 암호화를 담당Application Layer   상위층  PDU = message  사용자에게 서비스 제공 역할. SMTP, FTP, HTTP등 사용자가 원하는 최종 목표에 해당","categories": [],
        "tags": ["Network"],
        "url": "https://json9512.github.io/blog/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI-7-Layer/"
      },{
        "title": "Dijkstra's Shortest Path 2",
        "excerpt":"출처: greenhelix 푸푸릇님의 post, HackerEarth 전 포스트에서 시간 복잡도 O(V^2)의 알고리즘을 살펴보았다. 이번 포스트에서는 시간 복잡도 O(V + E log V)를 가진 다익스트라 최단 거리 알고리즘을 살펴보자 방법   모든 거리 값을 INF로 지정 해주고 시작 노드의 거리 값만 0으로 지정해준다.  (거리, 노드) 형식으로 노드들을 min-우선 순위 큐에 저장한다. 우선 순위 큐는 거리를 기준으로 한다  가장 적은 거리 값을 가진 노드를 우선 순위 큐에서 꺼낸다.  꺼낸 노드와 연결 된 노드들의 거리 값을 계산 한다. 계산 방식은 현재 노드까지 거리값 + 현재 노드에서 다음 노드까지 거리값 &lt; 다음 노드의 현재 거리 값을 사용한다. 거리 값이 갱신된 새로운 노드를 우선 순위 큐에 저장한다  만약 꺼낸 노드가 이전에 사용한 노드라면, 무시하고 다음 노드를 꺼낸다  우선 순위 큐가 비워질때가지 반복한다Python 부분적으로 먼저 살펴 본 후, 마지막에 전체 코드를 보도록 하자 def createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }graph = createGraph()전과 같이 이걸 실행하면 아래와 같은 그래프가 graph에 저장된다.  def dijkstra(graph, start):    # set adj_node     adj_node = {}    for node in graph:        adj_node[node] = None        # set all distance to INF    distance_matrix = {node: float('inf') for node in graph}    # starting position is 0    distance_matrix[start] = 0    # create min-priority-queue    heap = []    # add the starting point to priority queue    heapq.heappush(heap, [distance_matrix[start], start])위의 코드는 다익스트라 알고리즘에 쓸 변수들을 만들고 초기화 시켜주는 코드다 adj_node - 노드들이 최단 거리 값을 계산 할 때 사용했던 인접 노드 정보를 담고 있다 distance_matrix - 노드의 최단 거리 값을 가지고 있다 heap - 최단 거리 값을 기준으로 만들어진 우선 순위 큐 초기화 작업 시 adj_node는 다 None으로 해주고 distance_matrix도 모든 노드들이 inf 값을 가지게 선언 해준다. 시작 노드만 distance_matrix에서 거리값을 0으로 선언하고 시작 노드를 heap에 [거리값, 노드] 형식으로 넣어준다 이후 while문으로 heap에 노드들이 다 없어질때까지 아래의 작업을 반복한다.   우선순위 큐에서 노드를 꺼낸 뒤 거리값을 distance, 노드 이름을 node에 저장한다    while heap: # Take out an item from the priority queue distance, node = heapq.heappop(heap)        distance_matrix에서 현 node의 거리 값이 distance보다 낮으면, 다음 iteration으로 넘어간다     # If this node was used before and has lesser # distance value than the new distance # skip this node if distance_matrix[node] &lt; distance:     continue         현 node와 연결된 모든 노드들을 for 문을 돌린다     # Iterate through all the next nodes connected to  # the current node for next_node, next_node_distance in graph[node].items():        for 문에서 이하 반복한다          현재 노드의 최단 거리 값이랑 다음 노드로 가는 거리 값을 더한다         # Calculate the new distance using current node # to get to the next node new_distance = distance + next_node_distance                    next_node를 위해 갱신된 거리 값 new_distance가 distance_matrix에 저장 된 거리 값 보다 적으면, distance_matrix 값을 갱신해준다.   이후 [갱신된 거리값, 다음 노드] 를 우선 순위 큐 heap에 넣어준다  adj_node에도 현재 node를 사용 했다고 저장해준다         # change the distance if new_distance is lesser if new_distance &lt; distance_matrix[next_node]:     distance_matrix[next_node] = new_distance     # add the updated node to the priority queue     heapq.heappush(heap, [new_distance, next_node])                 # update adj_node that next_node used current node     adj_node[next_node] = node                    전체 코드 import heapqdef createGraph():    return {        'A': {'B':1, 'C':4, 'D':2},        'B': {'A':9, 'E':5},        'C': {'A':4, 'F':15},        'D': {'A':10, 'F':7},        'E': {'B':3, 'J':7},        'F': {'C':11, 'D':14, 'K':3, 'G':9},        'G': {'F':12, 'I':4},        'H': {'J':13},        'I': {'G':6, 'J':7},        'J': {'H':2, 'I':4},        'K': {'F':6}    }def dijkstra(graph, start):    # set adj_node     adj_node = {}    for node in graph:        adj_node[node] = None        # set all distance to INF    distance_matrix = {node: float('inf') for node in graph}    # starting position is 0    distance_matrix[start] = 0    # create min-priority-queue    heap = []    # add the starting point to priority queue    heapq.heappush(heap, [distance_matrix[start], start])    # if there are nodes in heap    while heap:        # Take out an item from the priority queue        distance, node = heapq.heappop(heap)        # If this node was used before and has lesser        # distance value than the new distance        # skip this node        if distance_matrix[node] &lt; distance:            continue                # Iterate through all the next nodes connected to         # the current node        for next_node, next_node_distance in graph[node].items():                        # Calculate the new distance using current node            # to get to the next node            new_distance = distance + next_node_distance            # change the distance if new_distance is lesser            if new_distance &lt; distance_matrix[next_node]:                distance_matrix[next_node] = new_distance                # add the updated node to the priority queue                heapq.heappush(heap, [new_distance, next_node])                                # update adj_node that next_node used current node                adj_node[next_node] = node    return distance_matrix, adj_nodegraph = createGraph()initial = 'D'distance_matrix, adj_node = dijkstra(graph, initial)print(distance_matrix)print(adj_node)# Show shortest path from 'D' to 'H'destination = 'H'print('Path between {} to {}'.format(initial, destination))print(destination, end=' &lt;- ')while True:    destination = adj_node[destination]    if destination == None:        print(\"\")        break        print(destination, end=' &lt;- ')# prints: H &lt;- J &lt;- E &lt;- B &lt;- A &lt;- D &lt;-dijkstra 함수는 거리 값 distance_matrix랑 사용한 인접 노드 정보 adj_node만 주고 실질적으로 최단거리를 계산하려면 adj_node 사용해야 한다 코딩 테스트에서는 대부분 위와 같이 우선 순위 큐로 구현하지 않으면 효율성 테스트에서 실패 할 수도 있다 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dijkstra-shortest-path-2/"
      },{
        "title": "Sonar to Image 연구 프로젝트 후기",
        "excerpt":"2019년 11월부터 2020년 2월까지 호주 QUT 대학교에서 진행한 10주 연구 프로젝트 ‘Sonar to Image’에 관한 후기다. 깃허브 대학교 2학년 마치고 여름 방학 동안 10주 연구 프로젝트를 한 적이 있다. 연구 팀은 지도 교수 2명 학생 2명 이렇게 4인이었고 사실상 연구 경험을 ‘맛 보기’ 하는 프로젝트였다. 연구 내용 연구의 핵심은 가상 공간 (VR)에 해저 환경을 딥러닝을 이용해 구현하는 것이었다. 임의의 환경을 만드는 것이 아닌 실존하는 해저 지형을 딥러닝이 만들어내는 것이었다. 궁극적인 목표는 잠수함이 해저를 탐험 할 때 sonar로 지형 지물의 존재여부를 알게 되는데, 이때 가상의 스크린에 바로 지형이 펄쳐지도록 하는 것이 이 연구의 마지막 단계라고 했다. 이 부분은 크게 2가지로 나뉘어졌었다.   수집된 sonar와 제한적인 image를 가지고 딥러닝 모델을 구현하는 것  딥러닝이 생성한 데이터를 (Unity나 Unreal) VR 환경에 구축하는 것여기서 나는 1번을 하게 되었다. 지도 교수님의 도움으로 어떤 모델을 만들어야 할지 알아보다가 GAN 모델로 정하게 되었다. GAN 이란 Generative Adversarial Network의 약자인데, 쉽게 말하면 두 개의 딥러닝 네트워크가 서로 상호작용하며 주어진 학습 데이터를 바탕으로 새로운 데이터를 만들어 낼 수 있는 모델이다. 구체적인 내용은 모델 학습에서 설명하겠다. 연구 일지 딥러닝, 머신러닝으로 모델을 만들 때 크게 3 가지가 중요하다고 볼 수 있는데:   Data preprocessing 데이터 전처리  Model training 모델 학습  Model evaluation 모델 평가이 중 데이터 전처리 과정이 모델의 능력을 결정한다고 볼 수 있다. 아무리 모델이 뛰어나도 쓰레기 데이터가 들어가면 쓰레기 데이터가 나온다. 데이터 전처리 과정 일단 데이터는 ROS 형식으로 저장이 되어 있었고, 거기서 유용한 데이터를 찾고 엑셀화 시키는 것에만 1주~2주 정도 소모됐다. 내게 주어진 데이터는:   기계가 전 방위 1~2초 단위로 수집한 sonar 데이터와  기계 하단부 카메라에서 수집한 해저 땅? 사진들 300백 장 정도가 다였다.일단 사진 데이터가 하단부 밖에 촬영을 못했기 때문에 실제로 모델을 학습 시킬 때 사용할 수 있었던 데이터는 sonar가 하단부 카메라 각 안에 들어올때 밖에 없었다. 이후 카메라 각 안에 들어오는 sonar 수치를 binary map으로 찍어서 이미지화 시켰다. 그리고 기존 사진 300백 장도 살펴보니 Spotlight effect (사진 중앙만 밝은 현상)이 심해서 이걸 없애는 알고리즘을 찾느라 또 시간을 많이 보냈다. CLAHE라는 알고리즘으로 Spotlight effect를 지운 후 마침내 모델 학습을 위한 [sonar binary map, 카메라가 수집한 사진] 을 만들었다. 모델 학습 GAN 은 Generator, Discriminator라는 2개의 네트워크가 서로 상호작용한다. 간단히 설명하면 Generator는 주어진 X 정보를 활용해 Y 정보를 제작한다, 이후 Discriminator는 제작된 Y가 실제 Y인지 분별하는 역할을 한다. Generator는 궁극적으로 Discriminator를 속일 수 있을 만한 데이터를 만들게 되고, Generator가 만든 Y 데이터가 모델이 만들어낸 데이터라고 보면 된다. 즉 이 연구에서는 Generator 에게 sonar binary map을 주고 카메라가 수집한 사진 같은 데이터를 만들어내라고 하는 것이다. 그러면 Discriminator는 실제 카메라가 수집한 사진과 Generator가 만든 카메라가 수집한 사진을 비교하며 유사도 점수를 준다. 모델 자체는 pix2pix 모델을 조금 더 경량화 시켜서 사용했고 완성도는 딥러닝에 대한 지식이 없을 때 만든거라 뛰어나지 않다. 모델 평가 확실히 처음 딥러닝을 접할 때여서 Overfitting이 뭔지 어떻게 해결하는지 잘 몰랐다. 즉, 모델 자체의 완성도는 좋지 않다. 그냥 이런 모델을 시도해 봤다 정도로 보면 되겠다. 결과 사진 한장을 보고 어떤 사진이 모델이 만들어낸 것인지 분별을 해보자.  실제 사진과 모델이 만든 사진에 차이가 보이긴 보인다.처음 모델이 사진을 만들어 냈을 때 상당히 신기했다.  주어진 sonar binary map 이 제일 윗 줄 Generator가 만들어낸 카메라가 수집한 사진이 중간 줄 실제 카메라가 수집한 사진이 마지막 줄이다. 위 사진은 대조할 카메라가 수집한 사진이 있는 sonar 각에 대한 학습 결과고 실제로 저 모델을 사용해서 카메라가 수집한 사진이 없는 sonar 각 까지 모델로 만들어서 이어보면 상당히 흥미로운 결과를 볼 수 있다. 궁금하면 여기 에 있다 처음 도전한 딥러닝이었고 데이터 전처리, 모델 학습 및 평가 과정이 상당히 부족한 프로젝트였지만 이 계기를 통해 나는 인공지능에 대해 좀 더 관심을 가지게 되었다. 그리고 이후 머신러닝/딥러닝 과목을 이수하게 되었다. ","categories": [],
        "tags": ["호주"],
        "url": "https://json9512.github.io/blog/%EC%97%B0%EA%B5%AC-Sonar-to-Image-%EC%97%B0%EA%B5%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0/"
      },{
        "title": "Bubble Sort",
        "excerpt":"출처: GeeksforGeeks 버블 정렬에 대해 알아보자.   가장 간단한 정렬 알고리즘  모든 item을 짝지어서 비교한다  이미 정렬된 array를 마지막에 다시 한 번 훑어야 하는 단점이 있다  Inplace하고 Stable한 알고리즘이다Time Complexity:   Worst: O(n^2) [array 가 reverse 정렬 됐을 시]  Best: O(n) [array 가 정렬이 됐을 시]Auxiliary Space Complexity:   O(1)Bubble sort visualization   Python def bubbleSort(arr):  n = len(arr)   # loop through the entire array  for i in range(n):    # inner loop    # n-i-1: elements found above here are already sorted    for j in range(0, n-i-1):      # Swap if the element found is greater than the next element      if arr[j] &gt; arr[j+1]:        arr[j], arr[j+1] = arr[j+1], arr[j]array = [51, 23, 41, 22, 1, 5]bubbleSort(array)'''outer loop iteration[51, 23, 41, 22, 1, 5] initial[23, 41, 22, 1, 5, 51][23, 22, 1, 5, 41, 51][22, 1, 5, 23, 41, 51][1, 5, 22, 23, 41, 51][1, 5, 22, 23, 41, 51] sortedinner loop operation for first outer loop iterationouter loop: [51, 23, 41, 22, 1, 5] initialinner loop: [51, 23, 41, 22, 1, 5] initialinner loop: [23, 51, 41, 22, 1, 5]inner loop: [23, 41, 51, 22, 1, 5]inner loop: [23, 41, 22, 51, 1, 5]inner loop: [23, 41, 22, 1, 51, 5]inner loop: [23, 41, 22, 1, 5, 51] after j loop finished'''","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Bubble-Sort/"
      },{
        "title": "Counting Sort",
        "excerpt":"출처: GeeksforGeeks Counting 정렬에 대해 알아보자   특정 범위에 있는 아이템을 정렬 할 때 사용한다  각 아이템의 카운트를 구한 뒤  수학적 방식으로 접근해서 정렬된 array를 만든다  Inplace 하지 않다  Stable 하다알고리즘   arr 내에 모든 아이템의 개수를 counter array에 저장한다  counter array를 (1, n) 으로 for loop을 돌면서, counter[i] += counter[i - 1] 로 바꾼다  arr를 뒤에서부터 돌면서          각 아이템 (i)의 counter[i] - 1 값을 index로 사용한다      아이템 i를 output array에 index 위치에 저장한다        arr를 다시 한번 돌면서 각 item을 output array에 있는 값으로 바꾼다Time Complexity:   Worst: O(n+k) [n 이 아이템의 수, k가 아이템의 범위]Space Complexity:   O(n+k)Counting sort visualization   Python def countingSort(arr):    # extract max and min value    max_val = int(max(arr))    min_val = int(min(arr))    range_of_val = max_val - min_val + 1    # final sorted array    output = [0 for i in range(len(arr))]    # counter array    counter = [0 for i in range(range_of_val)]    # Count the items in the array    for i in range(len(arr)):        idx = arr[i] - min_val        counter[idx] += 1        # Modify counter array to keep the index position of the items    # in the sorted array    for i in range(1, len(counter)):        # add the previous item's counter value        counter[i] += counter[i-1]        # Create the sorted array    for i in range(len(arr) - 1, -1, -1):        # find the index value for the item arr[i]        idx = arr[i] - min_val        counter_val = counter[idx]                # place it in the final array        output[counter_val - 1] = arr[i]        # decrease the value in the counter array        counter[idx] -= 1        # update the values in array     for i in range(len(arr)):        arr[i] = output[i]arr = [5, 2, 3, 1, 16, 4, 7]countingSort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Counting-Sort/"
      },{
        "title": "Heap Sort",
        "excerpt":"출처: GeeksforGeeks 힙 정렬에 대해 알아보자.   binary heap 데이터 구조를 사용한다  binary heap은 max-heap 구조를 가진다  Inplace 하다  Stable 하지 않다알고리즘   주어진 array로 max-heap을 만든다  가장 큰 값을 가진 root 노드와 binary heap의 마지막 노드의 자리를 바꾼다  heap의 크기를 1 줄인다  root 자리에 위치한 마지막 아이템에 대하여 heapify를 진행한다  heap의 크기가 1 이상이면 반복한다Time Complexity:   Worst: O(n log n)Auxiliary Space Complexity:   O(1)Heap sort visualization   Python def heapify(arr, length, root):    # initialize largest as root    largest = root    print(arr)    # children nodes    left = 2 * root + 1     right = 2 * root + 2    # see if left child of root exists and is greater than root    if left &lt; length and arr[left] &gt; arr[largest]:        largest = left    # see if right child of root exists and is greater than root    if right &lt; length and arr[right] &gt; arr[largest]:        largest = right    # change root if needed    if largest != root:        # swap        arr[root], arr[largest] = arr[largest], arr[root]         # heapify (check again for largest value to head to the root)        heapify(arr ,length, largest)    # sortdef heapSort(arr):    length = len(arr)    # build max heap    for i in range(length//2 -1, -1, -1):        heapify(arr, length, i)    # extract elements    for i in range(length-1, 0, -1):        # swap        arr[i], arr[0] = arr[0], arr[i]        heapify(arr, i, 0)    arr = [12, 15, 13, 5, 6, 7]heapSort(arr)'''[12, 15, 13, 5, 6, 7] # initial[12, 15, 13, 5, 6, 7][12, 15, 13, 5, 6, 7][15, 12, 13, 5, 6, 7][7, 12, 13, 5, 6, 15][13, 12, 7, 5, 6, 15][6, 12, 7, 5, 13, 15][12, 6, 7, 5, 13, 15][5, 6, 7, 12, 13, 15][7, 6, 5, 12, 13, 15][5, 6, 7, 12, 13, 15][6, 5, 7, 12, 13, 15][5, 6, 7, 12, 13, 15] # final'''Iterative version def buildMaxHeap(arr, length):    for i in range(length):        # if child is greater than parent        if arr[i] &gt; arr[(i-1)//2]:            j = i            # swap parent and child until parent is smaller            while arr[j] &gt; arr[int((j-1)/2)]:                arr[j], arr[int((j-1)/2)] = arr[int((j-1)/2)], arr[j]                j = int((j-1)/2)              def heapsort(arr, length):    buildMaxHeap(arr, length)    for i in range(length-1, 0, -1):        print(arr)        # Swap value of first indexed value with the last indexed value        arr[0], arr[i] = arr[i], arr[0]        # maintaining heap property after swapping        root_idx = 0        index = 0        while True:            # initially 'index' is the left child index in the max heap array            #        15      root            #    10     13   left = 10, right = 13            #  4   8  11  12            #            # as array= [15, 10, 13, 4, 8, 11, 12]            # root idx = 0            # left idx (index) = 1            # right idx (index+1) = 2            index = 2 * root_idx + 1            # if left is smaller than right,             # point index to right            if index &lt; i-1 and arr[index] &lt; arr[index +1]:                index += 1                        # if parent is smaller than child,             # swap            if index &lt; i and arr[root_idx] &lt; arr[index]:                arr[root_idx], arr[index] = arr[index], arr[root_idx]                        root_idx = index            if index &gt;= i:                breakarr = [ 10, 20, 15, 17, 9, 21]heapsort(arr, len(arr))print(arr)'''[21, 17, 20, 10, 9, 15] # after max heap[20, 17, 15, 10, 9, 21][17, 10, 15, 9, 20, 21][15, 10, 9, 17, 20, 21][10, 9, 15, 17, 20, 21][9, 10, 15, 17, 20, 21] # final'''","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Heap-Sort/"
      },{
        "title": "Insertion Sort",
        "excerpt":"출처: GeeksforGeeks 삽입 정렬에 대해 알아보자.   내 손에 쥔 카드를 정렬 할 때와 비슷하다  선택한 카드를 알맞는 위치에 삽입하면 된다  Inplace하고 Stable 하다알고리즘   arr[1] 부터 arr[n] 까지 loop을 돌린다  현재 아이템을 그 전 아이템들과 비교한다  현재 아이템보다 큰 아이템들을 한칸씩 위로 올려주고  현재 아이템을 찾은 위치에 넣어준다Time Complexity:   Worst: O(n^2)Auxiliary Space Complexity:   O(1)Insertion sort visualization   Python def insertionSort(arr):  for i in range(1, len(arr)):    print(\"outer\", array)    key = arr[i]        # move elements of arr[0 ... i-1], that are    # greater than key, to one position ahead of their current position    j = i-1    while j &gt;= 0 and key &lt; arr[j]:      arr[j+1] = arr[j]      j -= 1      print(\"inner\", array)          arr[j+1] = keyarray = [43, 32, 3, 21, 15, 4, 2]insertionSort(array)print(array) # [[2, 3, 4, 15, 21, 32, 43]]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Insertion-Sort/"
      },{
        "title": "Merge Sort",
        "excerpt":"출처: GeeksforGeeks Merge 정렬에 대해 알아보자.   분할 정복 알고리즘이다  주어진 array를 반으로 나눈다  나뉜 반쪽들을 각각 sort해주고 합친다  Inplace 하지 않다  Stable 하다  external sorting에 유용한 알고리즘이다Time Complexity:   Worst: O(n log n)Auxiliary Space Complexity:   O(n)Merge sort visualization   Python def mergeSort(arr):    if len(arr) &gt; 1:        # find the mid point        mid = len(arr) // 2        # divide into two sub arrays        left = arr[:mid]        right = arr[mid:]        # Sort the left half        mergeSort(left)                # Sort the right half        mergeSort(right)                # create index counter for left, right, original array        i = j = k = 0        while i &lt; len(left) and j &lt; len(right):            if left[i] &lt; right[j]:                arr[k] = left[i]                i+=1            else:                arr[k] = right[j]                j+= 1            k += 1                # add remaining elements        while i &lt; len(left):            arr[k] = left[i]            i += 1            k += 1        while j &lt; len(right):            arr[k] = right[j]            j += 1            k += 1array = [1, 5, 32, 2, 42, 3, 55]mergeSort(array)print(array) # [1, 2, 3, 5, 32, 42, 55]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Merge-Sort/"
      },{
        "title": "Quick Sort",
        "excerpt":"출처: GeeksforGeeks Quick 정렬에 대해 알아보자.   분할 정복 알고리즘이다  pivot을 사용해 주어진 array를 partition한다  pivot 보다 작은 것은 왼쪽에, 보다 큰 것은 오른쪽에 놓는 작업이다  pivot의 위치에 따라 알고리즘의 효율성이 달라진다  Stable하지 않다  Inplace 하다  Inplace 알고리즘이기 때문에 merge sort보다 선호 될 때가 있다Time Complexity:   Worst: O(n^2) [array에서 가장 큰 수 혹은 작은 수가 pivot인데 array가 이미 정렬이 됐을 때]  Best: O(n log n)Auxiliary Space Complexity:   O(log n) (Best)  O(n) (Worst)Quick sort visualization   Python def partition(arr, low, high):    # partition the array    # place the pivot on the right position     # start i (all the numbers less than pivot) from low -1    i = low-1    # pivot will be the rightmost element    pivot = arr[high]    # iterate through the array    for j in range(low, high):                # if the current element is less than the pivot        if arr[j] &lt; pivot:            # print for visuals            print(arr)            # increment the lower bound index            i+=1            # swap the current element with the element right after the lower bound index            arr[i], arr[j] = arr[j], arr[i]            # swap the pivot with the element at lower bound index + 1    arr[i+1], arr[high] = arr[high], arr[i+1]    # return the position of the pivot    return i + 1def quickSort(arr, low, high):    # only partition when lower bound is lower than higher bound    if low &lt; high:        partitioned = partition(arr, low, high)        # quick sort the left sub array of pivot        quickSort(arr, low, partitioned-1)        # quick sort the right sub array of pivot        quickSort(arr, partitioned+1, high)arr = [0, 10, 7, 3, 8, 9, 1, 5] n = len(arr) quickSort(arr,0,n-1) print(arr)'''[0, 10, 7, 3, 8, 9, 1, 5] # j = 0[0, 10, 7, 3, 8, 9, 1, 5] # swap j, i = 0, 0[0, 3, 7, 10, 8, 9, 1, 5] # swap j = 3, i = 1 + 1 = 2; arr[j] &lt;-&gt; arr[i][0, 3, 1, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 8, 9, 7, 10][0, 1, 3, 5, 7, 8, 9, 10] # final'''Iterative def partition(arr, low, high):    # partition the array    # place the pivot on the right position     # start i (all the numbers less than pivot) from low -1    i = low-1    # pivot will be the rightmost element    pivot = arr[high]    # iterate through the array    for j in range(low, high):                # if the current element is less than the pivot        if arr[j] &lt; pivot:            # print for visuals            print(arr)            # increment the lower bound index            i+=1            # swap the current element with the element right after the lower bound index            arr[i], arr[j] = arr[j], arr[i]            # swap the pivot with the element at lower bound index + 1    arr[i+1], arr[high] = arr[high], arr[i+1]    # return the position of the pivot    return i + 1def quickSort(arr, low, high):    # create supplementary stack    size = high - low + 1    stack = [0] * size    # push initial values to stack    top = 0    stack[top] = low    top += 1    stack[top] = high    # keep popping while stack is not empty    while top &gt;= 0:        # pop low, high        high = stack[top]        top -= 1        low = stack[top]        top -=1        # set pivot in its correct position        pivot = partition(arr, low, high)        # if there are elements on left side of pivot,        # push it to stack        if pivot-1 &gt; low:            top += 1            stack[top] = low            top += 1            stack[top] = pivot - 1                # if there are elements on right side of pivot,        # push it to the stack        if pivot+1 &lt; high:            top += 1            stack[top] = pivot + 1            top += 1            stack[top] = higharr = [4, 3, 5, 2, 1, 3, 2, 3] n = len(arr) quickSort(arr, 0, n-1) print(arr)'''[4, 3, 5, 2, 1, 3, 2, 3][2, 3, 5, 4, 1, 3, 2, 3][2, 1, 5, 4, 3, 3, 2, 3][2, 1, 2, 3, 3, 3, 5, 4][2, 1, 2, 3, 3, 3, 5, 4][2, 1, 2, 3, 3, 3, 4, 5][1, 2, 2, 3, 3, 3, 4, 5]'''Pivot을 Mid로 할 때 출처: BogoToBogo def quickSort2(arr):    def sort(arr, low, high):        if low &gt;= high:            return                left = low        right = high        # pivot selection        mid = (left + right) // 2        pivot = arr[mid]        # Partition        while left &lt;= right:            # find the element from left             # that is greater than pivot            while arr[left] &lt; pivot:                left += 1                        # find the element from right            # that is less than pivot            while arr[right] &gt; pivot:                right -= 1                        # swap the left and right items            # if left &lt;= right            if left &lt;= right:                arr[left], arr[right] = arr[right], arr[left]                left += 1                right -= 1                # recursion        sort(arr, low, right)        sort(arr, left, high)    sort(arr, 0, len(arr) - 1)","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Quick-Sort/"
      },{
        "title": "Selection Sort",
        "excerpt":"출처: GeeksforGeeks 선택 정렬에 대해 알아보자.   가장 작은 수를 가장 앞단에 놓는 알고리즘이다  Inplace 하다  Stable 하지 않다Time Complexity:   Worst: O(n^2)Auxiliary Space Complexity:   O(1)Selection sort visualization   Python def selectionSort(arr):  # loop through the entire array  for i in range(len(arr)):    # idx position to store minimum value    min_idx = i        # loop through the to-sort array (i+1, end)    for j in range(i+1, len(arr)):            # Update idx with the minimum value      if arr[j] &lt; arr[min_idx]:        min_idx = j        # swap positions after j loop is finished    arr[i], arr[min_idx] = arr[min_idx], arr[i]array = [64 ,32, 52, 1, 31, 36, 31]selectionSort(array)print(array) # [1, 31, 31, 32, 36, 52, 64]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Selection-Sort/"
      },{
        "title": "Prim's Minimum Spanning Tree",
        "excerpt":"출처: GeeksforGeeks, cppsecrets, bradfieldcs Prim의 Minimum Spanning Tree 알고리즘에 대해 알아보자   그리디 알고리즘이다.  가장 작은 weight로 MST를 구현하는 것  Naive하게 구현 하면 Time complexity O(|V|^2) 이나 다익스트라와 같이 priority queue를 사용하면 O(E log V)로 만들 수 있다방법   MST에 포함된 vertex를 저장할 set를 만든다 (empty set)  모든 vertices 간의 weight 값을 지정한다. 시작점을 제외한 모든 vertices weight 값은 무한대가 된다. 시작점은 0으로 만든다  모든 vertices가 MST에 포함된 vertex를 저장하는 set에 들어올때까지 이하 반복 한다:          set에 포함되지 않는 vertices 중 최단 거리를 가지고 있는 vertex u를 고른다      set에 포함 시킨다      vertex u 와 인접한 모든 vertices의 거리 값을 갱신한다.      Python def createAdjMatrix(V, G):    # Create empty adjacent matrix    adjMatrix = [[0 for row in range(V)] for col in range(V)]    # populate adjacency matrix with correct weights    for i in range(0, len(G)):        # G[i][0] is index of one vertex (node)        # G[i][1] is index of the other vertex        adjMatrix[G[i][0]][G[i][1]] = G[i][2]        adjMatrix[G[i][1]][G[i][0]] = G[i][2]        return adjMatrixdef primsMST(V, G):    # create adjacency matrix from graph    adjMatrix = createAdjMatrix(V, G)    # choose initial vertex from graph    vertex = 0    # initialize empty edges array and empty MST    MST = []    edges = []    visited = []    # keep track of min Edge    # [from, to, weight]    minEdge = [None, None, float('inf')]    # run prim's algorithm until the MST    # has all the vertices    while len(MST) != V - 1:                # mark the vertex as visited        visited.append(vertex)        # add each edge to the list of potential edges        for i in range(0, V):            if adjMatrix[vertex][i] != 0:                edges.append([vertex, i, adjMatrix[vertex][i]])                # find the edge with the smallest weight to a vertex        # that has not yet visited        for edge in range(0, len(edges)):            if edges[edge][2] &lt; minEdge[2] and edges[edge][1] not in visited:                minEdge = edges[edge]                # remove min weighted edge from the list of edges        edges.remove(minEdge)        # push min edge to MST        MST.append(minEdge)        # update vertex and rest minEdge        vertex = minEdge[1]        minEdge = [None, None, float('inf')]        return MSTif __name__ == \"__main__\":    # create graph nodes (vertices)    a, b, c, d, e, f = 0, 1, 2, 3, 4, 5    # create graph edges with weights    graph = [[a, b, 2],        [a, c, 3],        [b, d, 3],        [b, c, 5],        [b, e, 4],        [c, e, 4],        [d, e, 2],        [d, f, 3],        [e, f, 5]]    print(primsMST(6, graph))    # prints [[0, 1, 2], [0, 2, 3], [1, 3, 3], [3, 4, 2], [3, 5, 3]]    # Which is a MST of:    #     1(b) - 3(d) - 4(e)    #     |      |    #     0(a)   5(f)    #     |    #     2(c)우선 순위 큐를 사용한 Prim’s MST import heapqfrom collections import defaultdictdef createSpanningTree(graph, start):    mst = defaultdict(set)    visited = set([start])    edges = [        (cost, start, to) for to, cost in graph[start].items()    ]    heapq.heapify(edges)    # Find the mst    while edges:        cost, frm, to = heapq.heappop(edges)        if to not in visited:            visited.add(to)            mst[frm].add(to)            for to_next, cost in graph[to].items():                if to_next not in visited:                    heapq.heappush(edges, (cost, to, to_next))        return mstexample = {    'A': {'B': 2, 'C': 3},    'B': {'A': 2, 'C': 1, 'D': 1, 'E': 4},    'C': {'A': 3, 'B': 1, 'F': 5},    'D': {'B': 1, 'E': 1},    'E': {'B': 4, 'D': 1, 'F': 1},    'F': {'C': 5, 'E': 1, 'G': 1},    'G': {'F': 1},}mst = dict(createSpanningTree(example, 'A'))print(mst)# {'A': {'B'}, 'B': {'D', 'C'}, 'D': {'E'}, 'E': {'F'}, 'F': {'G'}}##  Original#     #       2 -- A ---- 3#       |           |#       B -- 1 ---- C#       | \\         |#       1   4       5#       |    \\      |#       D -1- E -1- F -1- G##  MST:#       2 -- A #       |           #       B -- 1 ---- C#       |           #       1           #       |           #       D --1-- E --1-- F --1-- GPrim’s MST 알고리즘을 사용한 문제 Leetcode 1584 Min cost to connect all points [프로그래머스] 섬 연결하기 백준 1197번 최소 스패닝 트리 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prim's-minimum-spanning-tree/"
      },{
        "title": "Radix Sort",
        "excerpt":"출처: GeeksforGeeks 라딕스 정렬에 대해 알아보자   제일 큰 숫자의 자릿수를 구하고  자릿수를 기준으로 정렬을 한다  내부에서는 카운팅 정렬이 사용된다Time complexity   O(d*n) - d는 가장 큰 수의 자릿수, n은 element 개수Space complexity   O(n + 2^d) - 2^d 인 이유는 각 key를 저장하기위한 비트 수Radix sort visualization   Python def radixSort(arr):    def helperFunc(arr, expo):        # implement counting sort        N = len(arr)        output = [0] * N        # initialize counter array as 10        counter = [0] * 10        # store frequency in count        for i in range(N):            idx = arr[i] / expo            counter[int(idx % 10)] += 1                # change counter i        for i in range(1, 10):            counter[i] += counter[i-1]                # build output array        i = N - 1        while i &gt;= 0:            idx = arr[i] / expo            output[counter[int(idx % 10)] - 1] = arr[i]            counter[int(idx % 10)] -= 1            i -= 1                # copy result to array        for i in range(N):            arr[i] = output[i]    # find the max number to know the number of digits    max_val = max(arr)    # Do counting sort for every digit    # Instead of passing the digit number,    # exp is 10^i where i is the current digit    exp = 1    while max_val / exp &gt; 0:        helperFunc(arr, exp)        exp *= 10","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Radix-Sort/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -1",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이 포스트는 . . . 얼마 전 막 학기가 끝나고 취준을 위해 2주동안 Medium 클론을 만들어 봤다. 이 프로젝트를 새롭게 해보려고 한다. 그리고 그 과정을 포스트 형식으로 기록하려고 한다. 이번 포스트는 이 프로젝트를 다시 해보는 이유와 2주 동안 개발했던 미디엄 클론의 기술 스택을 살펴보자 다시 하는 이유 일단 처음 미디엄 클론 프로젝트를 했을 때는 단기간에 빠르게 개발 할 수 있는가? 가 목표였고, 이를 충족 시키기 위해 서비스의 MVP를 개발 한다는 느낌으로 매일 5~8시간 정도 개발했었다. 이렇게 빠르게만 하다보니 퀄리티 자체는 높지 않다고 생각한다. 그래서 이번에는 새로운 언어도 배워 볼 겸, 조금 더 제대로 백엔드 디자인 가이드에 준수 하면서 만들어 보려고 한다. 왜 같은 프로젝트를 또 하는가? 한번 해봤던 프로젝트이기 때문에 서비스의 기능들을 구상해야되는 시간이 0에 가깝기 때문이다. 현재 아직 취준 중이기 때문에 새로운 프로젝트를 구상하고 만들어보기에는 준비해야 할 것들이 많기 때문이다. 또한 이번 프로젝트의 목적은 새로운 언어 습득과 백엔드 설계 및 자동화에 중점을 두고 할 것이기 때문에 그 외 불필요한 것들은 생략하는 것이다. 나름 선택과 집중이라고 볼 수 있다. 기존 미디엄 클론의 기술 스택 일단 서버에서 프론트를 렌더해주는 웹 앱이고 사용한 스택은 다음과 같다. Frontend:   Pug  JSBackend:   Nodejs (Express)  Mocha-chai (Test library)DB:   PostgresqlCI/CD:   Travis CI  Appveyor  Code Climate  Coveralls  HerokuCode storage/maintenance:   Git/Github부족했던 점 2 주만에 만든 것 치고는 나름 이것저것 많이 써봤지만 아쉬운 점이 많다. 일단 첫번째로는 SSR을 도전해본다고 frontend의 복잡함을 간과했던 것 두번째는 백엔드 코드가 디자인 가이드 없이 만들어졌다는 점과 백엔드 문서화 작업이 이루어지지 않았다는 점이다. 이번에는 뭐가 다른가? 이번에는 Go lang을 배우기 위해 다시 만들어 보는 것이 가장 큰 이유다. 일단 Frontend와 Backend를 확실히 나눈 뒤, Backend를 먼저 개발하는 것에 집중 할 것이다. REST 기준을 최대한 준수하며 RESTful한 HTTP API로 만들 계획이다. 여기에 TEST 코드와 CI/CD까지 붙이고 Docker로 이미지화까지 도전해 볼 계획이다. 마무리 정리를 하자면:   Frontend와 Backend를 나눈다  Backend 언어는 Go lang  Backend 디자인은 REST에 최대한 준수하는 HTTP API  Test 코드 및 CI/CD와 Docker 이미지화뭔가 많아 보인다. 괜찮다. 백엔드는 자동화만 잘 해주면 문제없다. 아마도. 다음 포스트에서는 개발 및 테스트를 어떻게 할지, 어떤 라이브러리를 사용할지 살펴보도록 하자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-1/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -2",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   왜 다시 이 프로젝트를 하는지  어떤 언어를 사용할 것인지이 포스트는 . . .   어떤 프레임워크/툴들을 사용 할 것인지에 대해 알아보자.백엔드 설계 일단 저번 포스트에서도 언급했듯이 언어는 Go로 정해졌다. 이유는 내가 Go 언어를 공부해보고 싶기 때문이다. 그리고 디자인 방식도 REST에 최대한 준수하는 API를 만들어 보겠다고 했다. 그러면 현재 언어와 설계 방식은 정해져있다. 그러면 이에 맞는 프레임워크와 개발 방식 그리고 개발 방식에 따른 테스트 라이브러리을 정해보자. 프레임워크 Go에서 REST한 API를 만들때 쓰는 프레임워크 중 대략 7가지를 보고 하나를 정하려고 한다. 7개의 프레임워크는 이 영문 포스트에 있다   Revel - “out of the box” 프레임워크  Gin - “lean”, 미니멀리스틱한 프레임워크  Martini - Gin의 베이스가 되는 라이브러리  Web.go - 트리 라우팅을 사용하는 미니멀한 라이브러리  Gorilla - package관리가 쉬운 프레임워크  Goji - 정말 최소한의 기능만 구현된 프레임워크  Beego - Revel 같은 out of the box 프레임워크일단 Revel, Beego 같은 경우는 너무 많은 것들이 이미 구현이 돼있어서 배우는게 없을 것 같아서 제외시키겠다. Web.go, Goji 같은 경우는 너무 미니멀한 것들이라 제외시키겠다. 너무 미니멀하면 구현을 해야하는 것들이 너무 많아져서 시간이 또 오래걸린다. Gorilla 같은 경우는 package 단위로 더하고 빼고 할 수 있어서 좋지만, 설정이 까다롭다는 점에서 Go를 처음 접하는 내가 효율적으로 사용할 수 있을까라는 의문이 있을뿐더러 package 설정에 쏟는 시간을 차라리 테스트나 자동화에 쏟는게 더 바람직하다고 생각하니까 빼도록 하겠다. 그러면 Gin과 Martini가 남게 되는데, 사용사례도 Gin이 더 많은 것 같고 Gin이 Martini보다 40배 빠르다고 하니까 이번 프로젝트는 Gin으로 백엔드를 개발 할 것이다. 개발 방식 개발 프레임워크를 정했으니 어떤 식으로 개발을 할지 정해보자. 기본적으로 개발은 그냥 해도 된다. 하지만 그냥 개발하면 서비스도 그냥 나온다.   쓰레기 input -&gt; Computer -&gt; 쓰레기 output 즉, 제대로 된 코드를 짜려면 개발 방식도 고려를 해야한다. 하지만 내가 대학교에서 배운, 아니 배우지도 않았다, 듣기만한 TDD (Test driven development)뿐 이다. 3년 가량 학교에서 개발을 배웠지만, 실제로 TDD를 적용한건 2주 미디엄클론을 했을 때 뿐이다. 어떤 개발 방식이 있는지 알아보자   TDD - 최소한의 개발 -&gt; 테스트 케이스를 먼저 작성 -&gt; 기능구현을 하면서 테스트를 통과하는지 검증  BDD - TDD와 비슷하게, 최소한의 개발 -&gt; 유저 시나리오에 맞는 테스트 케이스 작성 -&gt; 기능구현을 하면서 테스트를 통과하는지 검증  DDD - 도메인을 중점으로 개발을 함. Business logic에 맞게 변수/클래스 명을 작성하는 등, 비개발자도 개발자와 코드를 보면서 협업할 수 있도록 하는 것이 포인트.  ATDD - TDD의 업그레이드 버전, 기존 TDD는 코드가 잘 작동하는냐가 중점이라면 ATDD는 Acceptance 기준이 있어서 이 코드가 왜 필요한가? 도 따지게 되는 것  FDD - 기능 중점 개발여기서 알아야 할 것은 개발 방식은 하나를 정해서 하는 것이 아니라 여러 개가 얽혀있는 방식이다. 가령 BDD 같은 경우 TDD 와 DDD를 섞은 방식이라고 볼 수 있다. 아무튼, 나는 BDD 방식으로 접근을 할 것이다. TDD 방식으로 테스트케이스 -&gt; 개발 -&gt; 검증 으로 코드의 안정성을 유지하고 DDD 방식으로 비개발자가 테스트 코드를 보아도 의도된 행동양식을 통과한다는 것을 알 수 있게끔 API endpoint나 변수/클래스 같은 것들을 알기 쉽게 작성할 계획이다. 테스트 라이브러리 자, 이제 테스트 라이브러리만 정하면 된다. Go는 기본 Testing 라이브러리가 잘 되어 있어서 굳이 다른 라이브러리를 사용할 필요가 없지만, 개발자 편의를 위해 만들어 놓은 제 3 라이브러리를 사용 안 할 이유 또한 없다. BDD에 걸맞는 라이브러리가 어떤 것들이 있는지 알아보자. 출처는 이 영문 포스트다 포스트에는 여러 가지 테스트 라이브러리가 있는데 BDD에 특화된 라이브러리를 나열하면:   Ginkgo and Gomega  Goblin  GoConvey  기본 Go Testing 라이브러리가 있다. 일단 Ginkgo 와 Gomega 조합은 사용자도 많고 BDD에 최적화 되어 있고 기능들도 많다. 하지만 기능이 많다는 것은 내가 직접 구현해야 할 것들이 줄어들어서 배움의 장이 좁아진 다는 것이기 때문에 패스하도록 하겠다. GoConvey 같은 경우 UI로 볼 수 있는 서버가 띄워지고 쓰기 편해보이지만 개인적으로 web에 띄워지는 UI로 테스트 코드 결과를 보는 것보다 terminal에 바로 보여지는 것을 선호하기 때문에 패스하겠다. 기본 Go testing 라이브러리는 BDD 로 테스트 케이스를 작성하면 코드 자체가 상당히 지저분해 질 것 같아서 패스하도록 하겠다. 결론은 Ginkgo보다 기능들이 더 적게 구현되어 있지만 있을 건 다 있는 Goblin으로 하곘다. 마무리 정리 하자면 이번 포스트에서 정한 것은   개발 프레임워크 - Gin  개발 방식 - BDD  테스트 라이브러리 - Goblin이 되겠다. 다음 포스트에서는 프로젝트 관리는 무엇으로 할 것인지와 어떤 CI/CD 툴을 사용할 것 인지에 대해 알아보자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-2/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -3",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   어떤 개발 방식, 프레임워크, 테스트 라이브러리를 사용 할 건지이 포스트는 . . .   어떤 CI/CD 툴을 사용할 건지  어떤 project 관리 툴을 사용할 건지 알아보자CI/CD 툴 CI/CD도 테스트 방식 만큼이나 학교에서 듣기만 했지 써본 적은 없는 미지의 기술이었다. 처음 써 본게 역시나 2주 미디엄 클론 코딩을 하면서 Travis CI랑 Appveyor를 썼을 때다. CI/CD를 간략히 설명하자면, Continuous Integration / Continuous Delivery의 약자다. CI 는 여러 사람들이 작성한 코드를 지속적으로 하나의 코드로 통합시키고 검증하는 방식이다. 기본적으로는:   로컬 환경에서 테스트 코드로 코드를 검증한다  CI 환경에서 코드를 컴파일 한다  CI 환경에서 코드를 테스트해서 검증한다  CI 에서 서비스가 배포 될 수 있도록 한다 (Continuous Delivery)마지막 4번이 자동화가 되어있다면 continuous deployment라고 볼 수 있다. 이 모든 과정이 자동화가 되어 있어야 개발자들이 이상한 곳에서 시간을 낭비하지 않는다. 백엔드 엔지니어도 처음 만드는 서비스의 서버 환경을 구성해야되는 상황이면 CI/CD pipepline을 구축할 줄 알아야한다. DevOps가 구축하기도 한다. 이번에는 어떤 CI/CD 툴이 있고, 이 프로젝트에서 어떤 것을 쓸 것인지 알아보자. 출처는 2020년 당신이 알아야 할 탑 7 CI/CD 툴 (미디엄 영문)이다   Travis CI - 이미 사용했으니까 제외  Appveyor - 이미 사용했으니까 제외  Jenkins - 오픈소스 CI/CD 툴, 많은 개발자들이 애용한다  CircleCI - 유료지만 무료 플랜이 나쁘지 않은 서비스  Bamboo - 유료 Atlassian 제품, Bitbucket, Jira 만든 곳  TeamCity - Jetbrains에서 만든 CI 툴  Github Actions - 깃허브 지원 CI/CD 툴외에도 많지만 요정도에서 정해보겠다 일단 Travis CI 와 Appveyor는 사용한 경험이 있어서 패스하고 Bamboo와 CircleCi는 유료라서 제외하겠다. TeamCity는 여러 기능들이 좀 매력적이지만 이 프로젝트에 적용 시키기에는 너무 오버스펙 같아서 패스하겠다. 결국 Jenkins와 Github Actions가 남는데, 개인적으로 Git repository를 이미 Github로 사용하고 있으니 Github Actions로 일관성을 유지하겠다. 물론 위에 나열한 CI/CD 툴은 다 훌륭하다고 생각한다. 사용 방식도 하나만 알면 나머지도 비슷한 느낌이라 쉽게 배울 수 있다고 생각한다. 프로젝트 관리 툴 CI/CD 툴을 정했으니 프로젝트 관리 툴도 정해보자.   Jira  Trello  Asana  Github Projects이미 짐작했겠지만 Github Projects를 사용할 것이다. 이유는 일관성있게 모든 것을 Github내에서 볼 수 있도록 하기 위함이다. 새삼 Github가 정말 개발자 친화적이라고 느낀다. 역시 MS의 힘이란. 마무리 정리를 하자면:   CI/CD 툴 - Github Actions  프로젝트 관리 툴 - Github Projects다음 포스트에서는 앱 설계와 데이터베이스를 정해보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-3/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -4",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   어떤 CI/CD 툴을 사용할 지  어떤 프로젝트 관리 툴을 사용할 지이 포스트는 . . .   앱 설계  어떤 데이터베이스를 사용할지앱 설계 사실 이 “앱 설계”만 적어도 10 포스트는 넘게 작성 할 수 있다. 그만큼 고려해야하는 것이 많기 때문이다. 여태까지 해 왔던 것들도 나름 앱 설계에 들어간다고 볼 수 있다. 0년차 개발자로서 개발지식은 많지 않다. 하지만 새로운 앱을 만들 때 고려해야 하는 것들을 좀 나열해 본다면:   앱은 웹을 위한 앱인지, 안드로이드/iOS를 위한 앱인지, 아니면 둘 다를 위한 앱인지  설계 방식은 Monolithic 인지, SOA인지, MSA 인지  유저 인증/인가는 어디서, 어떻게 할건지, 따로 서버를 둘 건지  Scale이 가능한 앱인지, 어느 부분에서 어떤 metric을 기준으로 Scale out할 건지  백엔드는 stateful 한지 stateless한지  저장소는 어떻게 운영할 건지, 캐시는 활용 할 것인지  어떤 디자인 원칙을 준수할 것인지  버전 관리는 어떻게 할 것인지  테스트는 어떻게 할 것인지, 배포는 어떻게 할 것인지  load balancing은 어떻게 할 것인지  분산된 아키텍쳐면 로그는 어떻게 관리할 것인지  데이터베이스는 scale 할 것인지  방화벽은 어디에 어떻게 적용이 될 것인지등등 끝도 없다. 아무튼, 이 프로젝트의 앱 설계를 위의 9번까지 기준으로 작성을 해보자면 :   이 앱은 웹을 위한 것이다.  설계 방식은 Monolithic 한 방식을 쓰겠다. 이유는 기능별로 서버를 나눌 필요가 없기 때문이다  유저 인증/인가는 다른 포스트에서 다루도록 하겠다  scale은 가능하게끔 만들겠지만 scale 하지는 않을 것 같다  stateless한 서버를 만들겠다 RESTful 하기 위해  캐시는 없고, 데이터베이스는 추후에 서술하겠다  디자인 원칙은 백엔드는 REST에 최대한 준수한 HTTP API  버전 관리는 gvm, go.mod을 통해서 하겠다  테스트는 전 포스트에서 언급한 것 처럼 BDD를 준수하며 테스트 케이스를 만들고 Github Actions로 자동화 시키겠다자, high-level 이지만 대략적인 앱 설계는 끝났다. 설계한 대로 코드를 짤 수 있도록 잘 기억하도록 하자. 데이터베이스 이제 데이터베이스를 정해보자. 이것 또한 여러가지 방법이 있고 상황에 따라 적절한 데이터베이스를 정하는 것이 중요하다. 일단 제일 큰 축인, 관계형을 쓸 것인지 NoSql을 쓸 것인지부터 정하도록 하겠다. 저번 프로젝트에서는 관계형 데이터베이스인 Postgresql을 사용했다. 이번 프로젝트도 기능을 생각해 봤을 때 유저가 있고, 유저마다 포스트를 작성할 수 있고, 포스트에 좋아요를 표시할 수 있고, 코멘트 역시 달 수 있다는 점에서 관계형 RDBMS가 좋은 것 같다. 그러면 RDBMS 중에 사용 할 만한 툴을 찾아보자:   Postgresql  MySQL  SQLite등이 있다. 이번 프로젝트도 Postgresql을 사용하도록 하겠다. 이유는 현재 컴퓨터에 설치되어 있고 바로 구동 가능하기 때문이다. 프로젝트의 목표는 새 언어를 배우고 백엔드를 설계/자동화 하는 것이기 때문에 새로운 데이터베이스를 설치하고 설정하는 것에 시간을 투자하는 것은 비효율적이라고 판단했기 때문이다. SQL은 하나만 쓸 줄 알면 나머지도 언어 자체는 똑같기 때문에 사용하는데 무리가 없다. 마무리 정리를 하자면:   앱 설계를 Monolithic, stateless, scale 가능하게 했고  데이터베이스는 Postgresql이고 캐시는 없다.다음 포스트에서는 백엔드 API를 endpoint들을 설계해보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-4/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -5",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   앱 설계를 어떻게 할 것인지  데이터베이스 어떤 것을 쓸건지이 포스트는 . . .   백엔드 endpoint 설계백엔드 Endpoint 설계 우선 설계에 앞서 기억을 해야 할 것이 있다.   REST에 최대한 준하는 HTTP API이제 Endpoint들을 하나씩 뜯어보자. 일단 이전 프로젝트에서 서버가 지니고 있던 endpoint들을 살펴보면:   / GET - 홈페이지  /login GET - Auth0랑 passport.js 위한 것  /callback GET - Auth0랑 passport.js 위한 것  /logout GET - Auth0랑 passport.js 위한 것  /editor GET - 에디터를 보여주는 것  /editor POST - 에디터를 데이터베이스에 추가하는 것  /editor/update PUT - 에디터를 업데이트 하는 것  /editor/delete DELETE - 에디터를 지우는 것  /like PATCH - 포스트에 라이크를 더 하는 것  /list GET - 모든 포스트를 나열하는 것  /list/tags GET - 모든 포스트를 태그로 나열하는 것  /list/author GET - 모든 포스트를 작성자로 나열하는 것  /myposts GET - 유저가 작성한 포스트를 나열하는 페이지  /post GET - 포스트 정보를 보여주는 페이지  /post/id POST - 포스트를 아이디로 가져와서 보여주는 페이지  /post/tag POST - 포스트들을 태그로 가져와서 보여주는 페이지  /post/list POST - 포스트들을 가져오는 페이지  /users GET - 유저 정보를 가져오는 페이지정도가 있다. 보다시피 전혀 RESTful하지 않고 endpoint와 같이 적힌 설명문을 봤을 때 “응?”하는 것들이 많다. 예를 들면 /like. 중복되는 것도 있고 여러모로 정리가 되어있지 않다. 실제로 정리를 하지 않고 개발했기 때문이다. 이것들을 RESTful하게 정리를 해보자. RESTful 하게 바꾸자 ! 일단 바꾸기에 앞서서 RESTful한 endpoint가 뭔지 알아야 한다. RESTful 시스템이 뭔지는 다른 포스트에서 보도록하자. 위키피디아. REST API의 URI 디자인 가이드만 간략히 나열해보면 출처: resfulapi:   REST에서 primary 데이터는 resource라고 한다.  resource는 단일 (singleton) 혹은 컬렉션 (collection)이 될 수 있다.          /customers - collection      /customer - singleton        resource는 다른 resource의 sub-collection을 포함할 수 있다          /customers/{customer_id}/accounts - accounts sub-collection을 customer_id로 찾을 수 있다.      /customers/{cuustomer_id}/accounts/{account_id} - 마찬가지로 {account_id}를 이용해 accounts 컬렉션에서 단일 데이터를 가져올 수 있다.        resource를 표현 할 때 noun (명사)를 써라  resource를 좀 더 세분화하면 document, collection, store, controller 로 나눌 수 있다.  document는 데이터베이스에 저장되거나 하나의 객체를 뜻하는 단일 데이터다. REST에선 컬렉션안을 구성하는 것이 document라고 생각하면 된다          /customers/{customer_id} - customer_id가 document        collection - 서버가 관리하는 리소스의 집합체다. 클라이언트는 새로운 리소스를 collection에 추가하도록 요구 할 수 있지만, 결정권은 서버에 있다. 복수명을 사용하도록 하자          http://api.example.com/user-management/users        store - 클라이언트가 관리하는 리소스의 집합체다. 클라이언트는 새로운 URI를 생성하지는 않지만, 리소스를 더하거나 빼거나 지우거나 자유롭게 할 수 있다. 복수명을 사용하도록 하자          http://api.example.com/song-management/users/{id}/playlists      클라이언트가 관리한다고 해서 헷갈리지 말자. 다 서버에서 구현하는 것이다.        controller - 리소스의 행위를 뜻한다. 인자와 리턴 값이 있는 함수명이라고 생각하면 된다. 동사를 쓰도록하자          http://api.example.com/song-management/users/{id}/playlist/play        /를 사용해 리소스간 연관성을 표현하자          /electronics      /electronics/computers      /electronics/computers/cpus      /electronics/computers/cpus/{model_id}        마지막에 /는 생략하자          http://api.example.com/electronics/ X      http://api.example.com/electronics O        - 를 이용해 가독성을 챙기자          http://api.example.com/electronics/micro-controllers/ O        _ 는 사용하지 말자          http://api.example.com/electronics/micro_controllers/ X        소문자를 쓰자          http://api.example.com/electronics/CPUS/ X      http://api.example.com/electronics/cpus/ O        파일 확장명은 쓰지 말자          http://api.example.com/some-file.xml X      http://api.example.com/some-file O        CRUD 동사를 URI에 쓰지 말자. HTTP Method로 설명은 충분하다          http://api.example.com/electronics/get/CPUS/ X        URI collection은 query component를 활용하자          http://api.example.com/device-management/managed-devices?region=USA&amp;brand=XYZ&amp;sort=installation-date O      자 이 목록을 기준으로 다시 endpoint들을 작성해보자. 여기서 중요한 것은 editor 와 post 리소스에 있다. 잠시 샘플을 보자. 아래가 /editor를 이용해 페이지를 렌더 했을 때고  다음 이미지는 /post/id를 이용해 페이지를 렌더 했을 때다. 얼핏 보기에 다른 것이 없지 않나? 나도 그렇게 생각한다. 만약 이 두개의 endpoint를 합칠 수 있으면 이상적이다. 그러기 위해서 코드를 좀 살펴보자. 일단 /post/id에 핵심이 되는 코드다.  간단히 설명하면, HTTP POST 방식의 Body에서 id를 이용해 데이터베이스의 post 데이터를 추출 후 결과값을 주는 코드다. 전혀 RESTful 하지 않다. 자 그러면 /editor 를 살펴보자.  ?????? 당황스럽네. 백엔드 코드에서는 연관성을 찾을 수 없어서 프론트엔드 코드를 찾아봤더니 /editor 페이지에서 /post/id를 호출한 뒤 페이지의 나머지 구성 요소를 채우는 방식이었다. 이렇게 의미 없는 endpoint가 많아서 불필요한 것은 없애는 것이 좋다. 자 그러면 새로운 API의 endpoint들을 만들어 보자 HTTP GET   / - API 홈페이지 (보통 가능한 api endpoint들을 나열한다)  /posts - 모든 post들을 나열한다  /posts/{id} - 하나의 포스트를 id로 찾아서 준다  /posts/{id}/like - 하나의 포스트를 id로 찾아서 like만 준다  /posts?userid=xxx - 유저가 작성한 모든 포스트를 찾아준다  /posts?tags=xxx - 포스트를 주어진 tags를 기준으로 필터링해서 준다  /users - 모든 유저들을 나열한다  /users/{id} - 유저를 id로 찾아서 준다HTTP POST   /posts - 새로운 post를 만든다, body에는 id와 payload가 있을 예정  /users - 새로운 user를 만든다, body에는 유저 정보가 있을 예정HTTP PUT   /posts/{id} - 기존의 post를 업데이트 한다, body에는 payload가 있을 예정  /users/{id} - 기존의 user를 업데이트 한다, body에는 payload가 있을 예정HTTP DELETE   /posts/{id} - 기존의 post를 삭제한다  /users/{id} - 기존의 user를 삭제한다정리하고 보니까 깔끔해졌다. 이제 이것을 개발할 때 참고하면 된다. 유저 인증관련 endpoint는 잠시 보류해뒀다. 어떤 인증/인가 방식을 쓸 것인지 생각을 해야하기 때문이다. 마무리 정리하면:   백엔드의 endpoint를 RESTful하게 작성했다.다음 포스트에서는 인증/인가 방식을 정한 뒤 개발 환경을 셋업하는 것에 대해 알아보자 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-5/"
      },{
        "title": "Bucket Sort",
        "excerpt":"출처: GeeksforGeeks 버켓 정렬에 대해 알아보자   인풋이 특정 range에 고르게 분포되어 있을 때 유용하다  Counting Sort에서는 key가 항상 index인데, 만약 주어진 값들이 float이라면?  Bucket Sort을 사용하면 된다방법   n 개의 빈 bucket을 만든다 (list)  arr[i]에 대해 이하 반복한다:          arr[i]를 bucket[n*arr[i]]에 저장한다        Insertion Sort을 사용해 bucket을 정렬한다  정렬된 bucket을 다 이어준다Time complexity   Best Case: O(n * k)  Worst Case: O(n ^ 2)Space complexity   O(nk)Bucket sort visualization   Python def bucketSort(arr):    # number of buckets to create    slots = 10         # create 2d array for buckets    buckets = [[] for i in range(slots)]    for i in arr:        idx_b = int(slots * i)        buckets[idx_b].append(i)        # sort individual buckets    for i in range(slots):        insertionSort(buckets[i])        # concatenate all slots    k = 0    for i in range(slots):        for j in range(len(buckets[i])):            arr[k] = buckets[i][j]            k += 1        # Best: O(n + k) same as counting sort    # worst: O(n^2) same as insertion    # space: O(n * k)arr = [0.8, 0.22, 0.21, 0.4, 0.5, 0.1, 0.99]bucketSort(arr)print(arr)# [0.1, 0.21, 0.22, 0.4, 0.5, 0.8, 0.99]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Bucket-Sort/"
      },{
        "title": "Kruskal's Minimum Spanning Tree",
        "excerpt":"출처: GeeksforGeeks Kruskal’s MST에 대해 알아보자   그리디 알고리즘이다  시간 복잡도: O(E log V)방법   edges를 가중치를 기준으로 오름차순 정렬을 한다  가장 작은 가중치를 지닌 edge를 정한 뒤, 현재 MST에 저장된 edge와 연결 했을 시 Cycle이 되는지 확인한다.여기서 사용하는 알고리즘은 Union-Find 알고리즘이다  Cycle이 형셩되지 않으면 선택된 edge를 MST에 더해준다, 반면 Cycle이 형성되면 무시한다.  MST에 V-1 edge가 생성될 때까지 반복한다.Algorithm visualization   Python # 코드 출처: https://it-garden.tistory.com/411def kruskal(graph, num_of_nodes):        def find(u, disjointSet):        # disjointSet 에서         # vertex u를 재귀적으로 찾는 함수다        if u != disjointSet[u]:            disjointSet[u] = find(disjointSet[u], disjointSet)        return disjointSet[u]        def union(u, v, disjointSet):        # vertex u 와 v 를 union시키는 함수다        root_a = find(u, disjointSet)        root_b = find(v, disjointSet)        disjointSet[root_b] = root_a        # 그래프의 형태는 [[from, to, weight]] 형식이라고 가정한다    # 그래프를 가중치를 기준으로 오름차순 정렬한다    graph.sort(key= lambda x: x[2])    # MST를 기록할 list를 만들어준다    mst = []        # Disjoint Set 도 기록해준다    disjointSet = [0] # 0은 쓰지 않는 vertex다    # 각 vertex를 disjointSet에 만들어준다    for i in range(1, num_of_nodes + 1):        disjointSet.append(i)        # edges counter    edges = 0    # weight counter    mst_cost = 0     # 크루스칼 알고리즘    # edges가 V-1이 아니면 반복    while edges != num_of_nodes - 1:        frm, to, weight = graph.pop(0)        # vertex u와 v가 다른 집합이면 Cycle이 아니라는 뜻        if find(frm, disjointSet) != find(to, disjointSet):             union(frm, to, disjointSet)            mst.append((frm, to))            mst_cost += weight            edges += 1    return mst, mst_cost# 그래프는 Prim 알고리즘 포스트에서 썼던 A,B,C 그래프를 숫자로 치환한 값이다# A: 1, B: 2, C:3 ----- H:7graph = [    (1, 2, 2), # (A, B, 2)    (1, 3, 3), # (A, C, 3)    (2, 1, 2),    (2, 3, 1),    (2, 4, 1),    (2, 5, 4),    (3, 1, 3),    (3, 2, 1),    (3, 6, 5),    (4, 2, 1),    (4, 5, 1),    (5, 2, 4),    (5, 4, 1),    (5, 6, 1),    (6, 3, 5),    (6, 5, 1),    (6, 7, 1),    (7, 6, 1) # (G, F, 1)]# node의 개수는 1-6mst, mst_cost = kruskal(graph, 7)print(mst)print(mst_cost)'''Prim 알고리즘 포스트의 우선 순위 큐 MST와 비교하면 Kruskal 알고리즘 MST도 잘 구해진 것을 알 수 있다.mst:     1 (A) -&gt; 2 (B) -&gt; 4 (E) -&gt; 5 (F) -&gt; 6 (G) -&gt; 7 (H)                 |                v             3 (C)mst_cost: 2 + 1 + 1 + 1 + 1 + 1 = 7'''Kruskal 알고리즘을 사용할 수 있는 문제   백준 9372번 상근이의 여행  백준 2887번 행성터널  프로그래머스 지형이동  LeetCode 1489번 어려운 문제","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Kruskal's-Minimum-Spanning-Tree/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -6",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   백엔드 Endpoint를 RESTful하게 설계했다이 포스트는 . . .   인증/인가 방식 정하기  개발 환경 구축하기인증/인가 인증/인가는 중요하다. 하지만 어떤 식으로 하느냐도 중요하다. 얼마 전 구글의 인증서버가 다운 되면서 전 세계 사람들이 구글 인증을 사용하는 서비스를 못 쓰게 된 사례가 있다. 구글처럼 여러 서비스를 제공하는 경우 인증서버를 따로 두고 각 각 서비스의 서버들이 인증서버와 통신하는 방식으로 유저를 인증한다. 하지만 이번 프로젝트의 경우, 유저 인증/인가 서버를 따로 만들 필요가 없다. 인증/인가 방식만 잘 정해서, 원치 않는 유저만 잘 차단하고 권한이 있는 유저만 Go 서버를 잘 사용할 수 있게만 하면 된다. 그럼 RESTful API를 인증/인가 하는 방식에는 어떤 것들이 있는지 알아보자 [출처: retcase]   Basic Authentication  HMAC  OAuth2.0이것보다 더 있지만 여기서 고르려고 한다. Basic Authentication은 username 과 password를 사용하는 방식이다. HTTP header에 username과 password를 API 서버로 전달하면, 서버는 데이터베이스에 있는 정보와 HTTP header에 저장된 정보를 대조한 뒤 유저를 인증하는 방식이다. 가장 쉽고 기본적이지만 그만큼 보안에 취약하다. 이번 프로젝트에서는 사용하지 않겠다. HMAC은 서버와 클라이언트만 알고 있는 key를 사용해서 인증/인가를 진행하는 방식이다. Basic Authentication 보다 보안에 신경쓴 방법이다. 하지만 이번 프로젝트에서는 쓰지 않겠다. OAuth2.0는 인증을 검증된 Provider를 통해서 유저를 인증하는 방식이다. 여러가지 Flow가 있는데 이번 프로젝트와 잘 맞을 것 같은 방식이 있어서 사용해보려고 한다. Flow는 아래와 같다. (Three legged flow)   User가 내 웹앱(Client)에서 로그인을 누른다  웹앱에서 인가 코드를 OAuth2 제공자에게 요청한다  OAuth2 제공자는 User에게 인증/인가를 요청한다  User가 인증/인가를 한다  OAuth2 제공자가 인가 코드를 내 웹앱에 보내준다  내 웹앱이 OAuth2 제공자에게 Client ID, Client Secret, 방금 받은 인가 코드를 보낸다  OAuth2 제공자가 받은 정보를 인증/인가 후, Access Token을 내 웹앱에 보내준다  Access Token으로 API에 정보를 요청한다과정은 알고 있는게 좋다. Go는 oauth2라는 패키지가 있어서 쉽게 인증/인가를 만들어 볼 수 있을 것 같다. 개발 환경 설정 현재 나의 개발 OS는 Windows 10 Home 64bit 다. 이제부터 개발에 필요한 명령어를 적겠지만 OS가 다르거나 설치된 프로그램의 버전이 다르면 작동이 안 될수도 있다. 알아서 잘 찾아보도록 하자. 우선 제일 먼저 해야 할 것은 Go, Postgresql 설치다. 고는 기본 문서가 잘 되어 있어서 따라하기만 해도 된다.영어지만 설치 가이드를 보고 따라 한 뒤, 튜토리얼을 보면서 Go를 내 컴퓨터에 설치 하도록 하자. Postgresql도 마찬가지다. 설치 가이드를 따라서 설치를 해보자. 고는 지정된 GOPATH 밖에서 새로운 고 코드를 실행하고 싶으면 go mod를 활용해야 한다.새로운 폴더(mediumclone-go)를 생성하고, go mod init 아무이름/mediumclone-go 로 프로젝트 관리를 하자. 이제 고 백엔드 프레임워크 Gin을 설치하자. 고가 설치 되어 있다면, 터미널에서 go get -u github.com/gin-gonic/gin 으로 설치할 수 있다. 설치가 되면 go.mod 에 dependency 업데이트가 돼야하고 go.sum도 만들어져야 한다. 이 go.mod 와 go.sum을 npm의 package.json, package-lock.json, python의 requirements.txt 정도로 생각하자. mediumclone-go에 main.go 파일을 만들어서 간단한 서버를 구현해보자. // mediumclone-go/main.gopackage mainimport \"github.com/gin-gonic/gin\"// SetupRouter ...// returns a *gin.Enginefunc SetupRouter() *gin.Engine {\trouter := gin.Default()\trouter.GET(\"/ping\", func(c *gin.Context) {\t\tc.JSON(200, gin.H{\t\t\t\"message\": \"pong\",\t\t})\t})\treturn router}func main() {\tr := SetupRouter()\tr.Run() // Port 8080}이후 go run main.go를 하고 웹 브라우저에서 localhost:8080/ping 을 요청하면 { message: pong } 이 성공적으로 들어오는 것을 확인 할 수 있다. 이참에 바로 테스트 코드를 작성해보자. go get -u github.com/franela/goblin 로 goblin 을 설치하자. 설치 후 Go 테스트 작성법에 준수하며 main_test.go 파일을 만들어서 테스트 코드를 작성하자. package mainimport (\t\"encoding/json\"\t\"net/http\"\t\"net/http/httptest\"\t\"testing\"\t. \"github.com/franela/goblin\"\t\"github.com/gin-gonic/gin\")func MakeRequest(r http.Handler, method, path string) *httptest.ResponseRecorder {\treq, _ := http.NewRequest(method, path, nil)\tw := httptest.NewRecorder()\tr.ServeHTTP(w, req)\treturn w}func Test(t *testing.T) {\t// Setup router\trouter := SetupRouter()\t// create goblin\tg := Goblin(t)\tg.Describe(\"Server Test\", func() {\t\t// Passing test\t\tg.It(\"GET /ping should return JSON {message: pong}\", func() {\t\t\t// Build expected body\t\t\tbody := gin.H{\t\t\t\t\"message\": \"pong\",\t\t\t}\t\t\t// Perform GET request with the handler\t\t\tw := MakeRequest(router, \"GET\", \"/ping\")\t\t\t// Assert we encoded correctly\t\t\t// and the request gives 200\t\t\tg.Assert(w.Code).Equal(http.StatusOK)\t\t\t// Convert JSON response to a map\t\t\tvar response map[string]string\t\t\terr := json.Unmarshal([]byte(w.Body.String()), &amp;response)\t\t\t// grab the value\t\t\tvalue, exists := response[\"message\"]\t\t\t// make some assertions\t\t\tg.Assert(err).IsNil()\t\t\tg.Assert(exists).IsTrue()\t\t\tg.Assert(body[\"message\"]).Equal(value)\t\t})\t})}이후 go test를 실행해보면  요런 테스트 결과가 나와야한다. 위 테스트 코드와 Gin 서버 작성법은 아래 포스트들에서 참고했다:   craigchilds94  goblin Github  Gin Github마무리 정리를 하자면:   인증/인가 방식을 결정했고  기본적인 개발 환경, 서버 구축, 테스트 코드까지 작성했다다음 포스트에서는 Docker로 컨테이너화를 한 뒤에 모든 과정을 Github Actions로 자동화하는 방법을 알아보자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-6/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -7",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   인증/인가 방식을 결정  기본적인 개발 환경, 서버 구축, 테스트 코드 작성이 포스트는 . . .   Docker Image 화  Github Actions로 테스트 자동화 및 Docker Image 자동화Docker Image화 Docker 는 쉽게 설명하면 PaaS이고 OS-level 가상화를 이용해 앱을 container로 패키지화 해준다. Docker에 대해 설명하는 포스트는 추후에 작성하도록 하겠다. Docker Image화는 가상화된 환경에 특정 앱을 저장시키고 행동양식을 설정해주는 것이다. Image는 Docker Container에 배포되게 되면 설정된 행동양식에 따라 일렬의 코드를 실행시킨다. 이론상으로는 아무 컴퓨터에서 Docker Image 만 Container로 띄우면 Image속에 저장된 Go server는 정상 작동된다. 또한 만든 Docker Image를 Docker Hub에 올릴 수 있다. (Docker Hub는 Github 같은 저장소다) 이 Go Server를 Docker Image로 만들려면 일단 Docker를 설치해야 한다. Docker는 linux에 특화된 프로그램이어서 윈도우에서 설치하려면 구글의 힘이 필요할 수도 있다. 물론 요즘은 쉽게 사용할 수 있도록 잘 만들어 놓았으니, 알아서 Docker를 설치를 해보자.   공식 설치 가이드이 Go server를 이미지화 시키려면 일단 root 경로에 Dockerfile을 만들어야 한다. docker build라는 명령어를 사용을 할텐데 이 명령어는 기본적으로 Dockerfile을 찾는다. docker-compose도 있는데 이거는 복수의 Dockerfile을 이미지화 시켜 각 Container를 구동할 때 주로 사용된다. 아무튼, Dockerfile 속 코드는 다음과 같다. # Source: Go blog https://blog.golang.org/docker# Source: https://medium.com/@monirz/golang-dependency-solution-with-go-module-and-docker-8967da6dd9f6# Start base ImageFROM golang# Setup EnvironmentENV GO111MODULE=onWORKDIR /app/server# Copy go mod and go sumCOPY go.mod .COPY go.sum .# Install dependenciesRUN go mod download# Copy rest of the fileCOPY . .# Build the app in DockerRUN go buildEXPOSE 8080CMD [ \"./mediumclone-go\" ]하나씩 설명해 보겠다 FROM golang - Docker에서 만들어 놓은 golang이라는 이미지다. 이것을 기본으로 쓰겠다고 하는 것이다. ENV GO111MODULE=on - 환경변수 GO111MODULE 을 켜는 것이다. GO111MODULE이 뭔지 설명을 간략히 하자면, 고의 import 방식을 변경해 주는 것이다. 또 다른 이유로는 go get을 할 때 패키지의 특정 버전을 가져올 수 있다. WORKDIR /app/server - 현재 폴더를 /app/server로 해준다 COPY go.mod . - go.mod 파일을 현재 폴더 (도커 내)에 복사 해주는 것 COPY go.sum도 마찬가지 RUN go mod download - 명령어 go mod download를 도커 내에서 실행 시킨다. go.mod에 적힌 모든 패키지를 다운받는다 COPY . . - 현재 폴더 (컴퓨터)의 모든 파일/폴더를 현재 폴더 (도커)로 복사한다 RUN go build - 명령어 go build를 도커 내에서 실행시킨다. go build는 go.mod 파일에 설정 된 xxxx/mediumclone-go에서 mediumclone-go라는 이름의 executable (실행 가능한) 파일을 만든다. (.exe 파일) EXPOSE 8080 - 도커내 포트 8080을 외부에서 연결 할 수 있도록 연다 CMD [ \"./mediumclone-go\" ] - 도커내 터미널에서 주어진 명령어를 실행한다. ./mediumclone-go는 go build 로 만들어진 mediumclone-go 파일을 실행시킨다. 이렇게 Dockerfile을 간단히 만들어봤다. 현재는 환경변수도 없고 개인 정보도 없어서 간단하지만 추후에 데이터베이스를 연결하고 환경변수를 만들게되면 다 추가해줘야 한다. 이제 프로젝트의 root 경로에서 docker build .를 하게 되면 아래와 같이 실행이 되는 것을 볼 수 있다.  docker images를 실행하면 &lt;none&gt; 이지만 방금 만들어진 이미지를 볼 수 있다.  docker run  -p 6060:8080 --name goserver c5a8로 방금 만든 이미지를 컨테이너에 실행해보자.   -p - --publish의 약자다. 뒤에 오는 6060:8080은 포트 숫자고 host:docker 라고 보면 된다. 아까 Dockerfile에서 8080을 열었으니 그 8080에 내 컴퓨터 6060을 연결한다고 보면된다.  --name - 은 실행되는 컨테이너의 이름을 정해주는 것이다  c5a8 - 아까 본 &lt;none&gt; 이미지의 Image ID 일부분이다.docker ps 로 실행되고 있는 모든 컨테이너를 볼 수 있다.  잘 실행되고 있는 것을 볼 수 있다. 이제 크롬을 켜서 localhost:6060/ping으로 가면  Go server가 잘 돌아가고 있는 것을 볼 수 있다. 됐다. 고 서버를 도커 이미지화 하는 방법은 알았다. 이제 이걸 자동화 해보자. 여담   docker rm &lt;container id&gt; - 로 실행되고 있는 container를 없앨 수 있다. 경우에 따라 --force를 해야 할 수 있다  docker rmi &lt;image id&gt; - 로 저장된 도커 이미지를 지울 수 있다. 마찬가지로 --force를 써야 할 수도 있다Github Actions Github Actions는 사실 CI/CD 용으로 만들어진 툴이 아니다. 개발자들의 요청으로 Github Actions로 CI/CD가 가능하게 되었다. Github Actions는 특정 event 발생 -&gt; 특정 작업 수행의 구조를 가지고 있다. 이것을 사용해서 개발자가 repo 에 코드를 push 하면 Github Actions가 알아서 코드를 test 할 수 있게 할 수 있다. 이게 곧 CI에 기본이 되는 flow다. 이 mediumclone-go에는 자동화 해야 할 부분이 다음과 같다.   main, develop branch에 코드 push, pull_request 시 테스트 자동화  main branch에 코드 push, pull_request 시 Docker image 생성 및 Docker hub으로 푸시  배포 (어디로 배포할지 정해야 한다)일단 처음 1. 2.번만 시도하도록 하자. 공식 가이드 를 보면서 workflow를 만들어 보도록 하겠다. 제일 처음해야 할 것은 프로젝트의 root 경로에 .github/workflows 폴더를 생성해야 하는 것이다. 그 후 &lt;이름&gt;.yml 파일을 만들고 특정 workflow를 이 파일안에 작성하면 된다. 아래는 test-server.yml의 코드다. name: test-serveron:  push:    branches: ['main', 'develop']  pull_request:    branches: ['main', 'develop']jobs:  build:    strategy:      matrix:        os: ['ubuntu-latest', 'macos-latest', 'windows-latest']    runs-on: $    steps:    - name: Testing on ($)      uses: actions/checkout@v2        - name: Setup Go      uses: actions/setup-go@v2      with:        go-version: 1.15        - name: Build      run: go build -v ./...        - name: Test      run: go test -v ./...간단히 설명하면 main, develop branch에 push, pull_request가 생기면 macos, ubuntu, windows에서 mediumclone-go를 테스트하는 workflow다. 이제 이 코드를 commit 하고 push를 하자. 이후 repository에 Actions 탭에 가보면  이런 결과가 나와야 한다. 내친김에 Docker 이미지화 및 Docker Hub에 배포도 자동화 하자. 기존 파일에 이어서 작성하면 전체는 아래와 같다. 파일명을 ci-docker-cd.yml로 바꿨다. name: CI/Docker/CDon:  push:    branches: ['main', 'develop']  pull_request:    branches: ['main', 'develop']jobs:  build-and-test:    strategy:      matrix:        os: ['ubuntu-latest', 'macos-latest', 'windows-latest']    runs-on: ${지우기{ matrix.os }}    steps:    - name: Testing on (${지우기{ matrix.os }})      uses: actions/checkout@v2        - name: Setup Go      uses: actions/setup-go@v2      with:        go-version: 1.15        - name: Build      run: go build -v ./...        - name: Test      run: go test -v ./...  push-docker-image:    # run when build is successful    needs: [build-and-test]    runs-on: ['ubuntu-latest']    name: Push Docker image to Hub    steps:    - name: Checkout      uses: actions/checkout@v2    - name: Set up Docker Buildx      uses: docker/setup-buildx-action@v1      with:        driver: docker    - name: Login to Docker      uses: docker/login-action@v1      with:        username: ${지우기{ secrets.DOCKER_HUB_USERNAME }}        password: ${지우기{ secrets.DOCKER_HUB_PASSWORD }}        - name: Build and push      id: docker_build      uses: docker/build-push-action@v2      with:        context: ./        file: ./Dockerfile        load: true        tags: json9512/mediumclone-go:latest # docker repo    - name: Push      run: docker push json9512/mediumclone-go:latest        - name: Image digest      run: echo ${지우기{ steps.docker_build.outputs.digest }}살펴보면 ${지우기{ secrets.XXXX }} 형식이 보일것이다. (지우기 는 지워주자) 이 secrets는 Github repository내에 Setting에서 설정해 줄 수 있다. 물론 지금 만든 Dockerfile 이나 ci-docker-cd.yml은 추후에 여러가지가 더해지고 없어지고 하면서 더 복잡해질 것이다. 하지만 미리 뼈대를 잡아놓으면 나중에 변경을 할 때 더 쉽다. 마무리 . . . 정리를 하자면   Docker Image화를 위한 Dockerfile을 만들었고  테스트/Docker image를 Hub에 push하는 Github Actions workflow를 만들었다.다음 포스트에서는 어떤 방식으로 서버를 배포할 것인지를 정하자. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-7/"
      },{
        "title": "비트 연산",
        "excerpt":"출처: HackerEarth 1학년 때 배우고 쓰지 않아서 다시 복기 할 겸 비트 연산에 대해 알아보자. Bit manipulation (HackerRank)   비트 개발자가 사용하는 모든 것은 bit로 이루어져있다. Bit를 는 0, 1로 표현되고 1 byte는 8 bit로 이루어져 있다. 컴퓨터에서 모든 integer 또는 character는 이 bit로 표현된다. 이 표현 방식은 binary form이고 binary form은 base 2를 가진다. # 숫자 14, binary form = 111014 = (1 * 2^3) + (1 * 2^2) + (1 * 2^1) + (0 * 2^0)character는 ASCII 표현식을 사용하고, ASCII 표현식은 integer를 사용하기 때문에 bit 표현 방식은 같은 원리다. Two’s complement bit로 Positive number를 표현하는 방식은 알았다. 그러면 Negative Number는 어떻게 표현될까? 2’s Complement를 사용하면 된다. 2’s Complement는 하나의 bit를 positive를 뜻하는 0, negative를 뜻하는 1로 정하는 것이다. 8 bit중 8번째 비트가 1이면 negative를 뜻한다. 8 bit로 표현된 숫자 14를 -14로 표현해보자. 방법은 아래와 같다:   현재 bit를 flip 한다. 0 -&gt; 1로 1 -&gt; 0으로 바꾼다  2^0 자리에 1을 더한다  마지막 비트가 1이어야 한다.예를 들면 # 14는 1110 이다.# 8 bit를 다 풀어서 쓰면 00001110 이다.# # 이것을 Negative로 바꾸려면# 1. 00001110 을 flip 하자# -&gt; 11110001# 2. 2^0 자리에 1을 더하자# -&gt; 11110010 # 11110010이 -14다위 처럼 계산이 가능하다. 하지만 이걸 python 에서 써보면 예상과는 다른 값이 나온다. print(int(\"11110010\", 2))# 242왜 242가 나올까? 이는 11110010 이 242를 bit로 표현한 것이기 때문이다. 즉 11110010로 2가지의 숫자, 242와 -14를 표현해야한다. Python에서는 직관적으로 더 쉽게 이해를 돕기 위해 원래 숫자의 bit 표현식에 - 표식을 넣는 것으로 표현했다. print(14)print(\"{0:08b}\".format(14))print(-14)print(\"{0:08b}\".format(-14))# 14# 00001110# -14# -0001110오 그러면 float은 어떻게 표현하지? 는 여기에 있다. 비트 연산 Bit에 대해 알아봤으니 이제 Bit operator에 대해 알아보자. 총 6가지가 있다.   NOT (~) - 주어진 bits를 flip한다. 0 -&gt; 1, 1 -&gt; 0     # a: 00001111 # ~ a: # 11110000        AND (&amp;) - 2 개의 bits (같은 길이) 가 주어졌을 때, 각 bit 자리가 둘 다 1이면 1을, 아니면 0으로 바꾼다.     # a: 00001111 # b: 00001100 # a &amp; b: # 00001100        OR (|) - 2 개의 bits (같은 길이) 가 주어졌을 때, 각 bit 자리가 둘 다 0이면 0을, 아니면 1로 바꾼다     # a: 00001111 # b: 00001100 # a | b # 00001111        XOR (^) - 2개의 bits (같은 길이) 가 주어졌을 때,각 bit 자리가 둘 다 1, 혹은 0이면 0을, 하나만 1이면 1으로 바꾼다     # a: 00001111 # b: 00001100 # a &amp; b # 00000011        Left Shift (&lt;&lt;) - 왼쪽으로 주어진 횟수 만큼 비트를 움직이고 공백에는 0을 채운다. N 번의 비트를 움직인다고 가정 할 때, 2^N 을 곱하는 것과 같다.     x = 0b1111 print(int(str(\"{:08b}\".format(x)), 2)) # 15 print(\"{:08b}\".format(x)) # 00001111 # 4번 왼쪽으로 밀기 x = x &lt;&lt; 4 print(int(str(\"{:08b}\".format(x)), 2)) # 240 print(\"{:08b}\".format(x)) # 11110000         Right Shift (&gt;&gt;) - 오른쪽으로 주어진 횟수 만큼 비트를 움직이고 공백에는 0을 채운다. N 번의 비트를 움직인다고 가정 할 때, 2^N 을 나누는 것과 같다.     x = 0b1111 print(int(str(\"{:08b}\".format(x)), 2)) # 15 print(\"{:08b}\".format(x)) # 00001111 # 2번 오른쪽으로 밀기 x = x &gt;&gt; 2     print(int(str(\"{:08b}\".format(x)), 2)) # 3 print(\"{:08b}\".format(x)) # 00000011      비트 연산에 대해 알아보았다. 이제 이런 것을 활용한 코드를 봐도 당황하지 말자. ","categories": [],
        "tags": ["CS"],
        "url": "https://json9512.github.io/blog/CS-%EA%B8%B0%EC%B4%88-%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0/"
      },{
        "title": "Shell Sort",
        "excerpt":"출처: GeeksforGeeks 쉘 정렬에 대해 알아보자   삽입정렬을 살짝 바꾼 알고리즘  Gap을 이용해서 정렬을 한다.  Gap을 어떻게 정하는지에 따라 속도가 조금씩 차이가 난다.  Stable 하지 않다Time complexity   Worst Case: O(n ^ 2)Space complexity   O(1)Shell sort visualization   Python def shellSort(arr):    # Set gap    N = len(arr)    gap = N // 2    # perform insertion sort with gap    while gap &gt; 0:        for i in range(gap, N):            # store item at i index            temp = arr[i]            # shift already sorted items            j = i            while j &gt;=  gap and arr[j - gap] &gt; temp:                arr[j] = arr[j - gap]                j -= gap                        # put ith item in correct position            arr[j] = temp                # reduce the gap by half of its size        gap //= 2        # O(n^2) for this version    # O(1)    # not stablearr = [5, 2, 3, 1, 16, 4, 7]shellSort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Shell-Sort/"
      },{
        "title": "Activity Selection",
        "excerpt":"출처: GeeksforGeeks Activity Selection에 대해 알아보자   그리디 알고리즘  N개의 activity의 시작 시간과 끝나는 시간이 있을때, 한 사람이 activity를 수행 할 수 있는 최대 횟수를 구하는 것  단, 사람은 같은 시간에 딱 하나의 activity만 수행 할 수 있다.알고리즘   주어진 N개의 activity를 끝나는 시간을 기준으로 오름차순 정렬한다  제일 첫 번째 activity를 결과 값에 저장한다  나머지 activity는:          현재 activity의 시작 시간이 전의 activity의 끝나는 시간과 같거나 크다면, 현재 activity를 결과 값에 저장한다.      Python def acitivty_selection(arr: list) -&gt; list:    '''Returns number of activities in list'''    # sort the items by finish time    arr.sort(key=lambda x: x[1])    # add the first item to the answer    answer = []    answer.append(arr.pop(0))    prev_item = answer[0]    # compare the current item's start time with    # the previous item's end time    for i in range(len(arr)):        curr_item = arr[i]        if curr_item[0] &gt;= prev_item[1]:            answer.append(curr_item)            prev_item = curr_item    return answer# create activity array# (start time, finish time)activities = [    (1, 2),    (3, 4),    (0, 6),    (5, 7),    (8, 9),    (5, 9)]ans = acitivty_selection(activities)print(ans)# [(1, 2), (3, 4), (5, 7), (8, 9)]Activity Selection을 사용한 문제   백준 1931번 회의실 배정  Leetcode 452번  Minimum Number of Arrows to Burst Balloons  Leetcode 1326번 Minimum Number of Taps to Open to Water a Garden  Leetcode 435번 Non-overlapping Intervals","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Activity-Selection/"
      },{
        "title": "Comb Sort",
        "excerpt":"출처: GeeksforGeeks Comb 정렬에 대해 알아보자   Bubble Sort를 살짝 바꾼 알고리즘  Gap을 이용해서 정렬을 한다.  Gap은 decrease factor 1.3씩 줄어든다  Stable 하지 않다Time complexity   Worst Case: O(n^2)Space complexity   O(1)Comb sort visualization   Python def comb_sort(arr):    def get_next_gap(gap):        '''Helper function to get next gap using the decrease factor'''        gap = (gap*10) / 13        if gap &lt; 1:            return 1        return int(gap)    # get length    length = len(arr)    gap = length    swapped = True    while gap != 1 or swapped == True:        # find next gap        gap = get_next_gap(gap)        swapped = False        for i in range(0, length-gap):            if arr[i] &gt; arr[i+gap]:                arr[i], arr[i+gap] = arr[i+gap], arr[i]                swapped = True     # O(n^2), O(1), not stablearr = [5, 2, 3, 1, 16, 4, 7]comb_sort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Comb-Sort/"
      },{
        "title": "PEP 8",
        "excerpt":"파이썬 개발자라면 알아야 할 PEP 8 코드 가이드 사실 파이썬을 주로 쓰지만 PEP 8에 맞춰서 코드를 짠 적이 없다 이번 기회에 알아보자 출처: PEP 8 코드의 일관성은 중요하다   PEP 8은 기본적으로 사용되는 파이썬 코드 스타일 가이드다  이유가 있다면 꼭 PEP 8을 고수할 필요는 없다Code Layout Indentation   4 번의 스페이스로 Indentation을 표시하자  (), {}, [] 사용 시 줄 바꿈을 해야 한다면, 표현식은 다음과 같다.                   # GOOD # 여는 부호 (, {, [ 줄에 맞춰서 element를 적고  # (), {}, [] 안에 element를 수직 정렬 시킨다 foo = long_function_name(var_one, var_two,                          var_three, var_four)         # BAD # 수직 정렬을 사용하지 않으면 # 여는 부호 (, {, [ 와 함께 변수명을 적으면 안된다 foo = long_function_name(var_one, var_two va_three, var_four)                             # GOOD # 4번의 스페이스를 넣어서 인자와 나머지를 구분한다. def long_function_name(         var_one, var_two, var_three,         var_four):     print(var_one)         # BAD def long_function_name(     var_one, var_two, var_three,     var_four):     print(var_one)                      if 문과 관련해서는 다음과 같이 사용할 수 있다.                    # GOOD  # 여백 없이 사용 (수직 정렬은 맞춰야한다.)  if (condition_a and      condition_b):      do_something()          # Comment를 작성해서 시각적으로 구분  if (condition_a and      condition_b):      # 컨디션이 둘 다 True 하니, 다음을 실행      do_something()          # condition에 여백을 넣어준다  if (condition_a          and condition_b):      do_something()                      multiline construct에서 닫는 부호 ], }, )의 위치는 다음과 같다.                    # 부호 안에 있는 첫 번째 변수에 수직 정렬한다  my_list = [      1, 2, 3,      4, 5, 6,      ]  result = some_function(      'a', 'b', 'c',      'd', 'e', 'f',      )          # 혹은 multiline construct의 시작 부분에 맞춰서 정렬한다   my_list = [      1, 2, 3,      4, 5, 6,  ]  result = some_function(      'a', 'b', 'c',      'd', 'e', 'f',  )                    TAB/SPACE?   이미 기존 코드가 TAB을 사용하고 있다면 TAB으로 코드를 작성한다  TAB 대신에 4번의 스페이스 공백을 기본으로 한다최대 라인 길이   모든 라인은 최대 79자로 한다  Flowing long blocks of comments나 docstring은 72자로 한다  최대 라인 길이를 준수하기 위해 \\도 다음과 같은 상황에서는 사용 가능하다                    # 바뀐 줄은 수직 정렬을 맞춰야한다  # \\ 이후에 공백은 안된다  with open('/path/to/some/file/you/want/to/read', 'r') as file_ 1 \\       open('/path/to/some/file/being/written', 'w') as file_2:      file_2.write(file_1.read())                    줄 바꿈은 이항연산 (binary operator)자 전/후? # GOOD# 연산자 전 줄 바꿈income = (gross_wages          + taxable_interest          + (dividends - qualified_dividends)          - ira_deduction          - student_loan_interest)# BAD# 연산자 후 줄 바꿈 (연산자가 정렬이 되지 않음)income = (gross_wages +          taxable_interest +          (dividends - qualified_dividends) -          ira_deduction -          student_loan_interest)Blank lines # Some code written here# Top level 함수와 class는 앞/뒤로 2줄def top_level_function():    passclass SomeClass():    # Class 안에 함수는 앞/뒤로 1줄    def class_method():        pass    def another_method():        pass# 함수 내에 logical section을 나눌 때 공백 사용def some_function():    some_task_a    some_task_b    some_task_cSource file encoding   Python 2는 (ASCII), Python 3은 UTF-8을 기본으로 한다  예외는          Non-ASCII 기능을 test하는 test case      코드 작성자의 이름      Import   하나의 import는 한 줄에          # GOOD      import os      import sys      # BAD      import os,sys      # GOOD      from subprocess import Popen, PIPE        import 항상 파일의 가장 위에 위치한다.  기본 라이브러리, 연관된 제 3 라이브러리, 로컬 라이브러리 순으로 나열한다  from &lt;something&gt; import *는 사용하지 말자  Absolute import를 권장한다.          # Good      import mypkg.sibling      from mypkg import sibling      from mypkg.sibling import exmple        하지만 Absolute import 를 쓰는 것이 복잡함을 초래하거나 패키지 자체가 Absolute import을 사용하기에 너무 복잡하면 relative import을 사용해도 된다          # Example      from . import sibling      from .sibling import example        패키지에서 class를 import할 때 아래와 같이 사용할 수 있다          # Good      from myclass import MyClass      from foo.bar.yourclass import YourClass        만약 위의 방법이 local class와 Naming 에러를 초래하면 다음과 같이 사용할 수 있다.          import myclass      import foo.bar.yourclass      # use myclass.Myclass or foo.bar.yourclass.YourClass      Module level Dunder names   모듈의 Dunder (‘something‘로 같은 것들) 이름들은 Docstring 과 __future__ 패키지 import 문 바로 다음에 와야 한다      \"\"\"This is a module level docstring  This module does something  \"\"\"  from __future__ import barry_as_FLUFL  __all__ = ['a', 'b', 'c']  __version__ = '0.1'  __author__ = 'someone'  import os  import sys      String Quotes   \"\", '' 중 하나를 정해서 사용  \"' '\", '\" \"' 같은 것도 방식을 정해서 사용  단 3중 quoted string(\"\"\", ''')은 \"\"\"를 쓸것Whitespace in Expressions and Statements # 잉여 whitespace를 만들지 말 것# Goodspam(ham[1], {eggs: 2})# Badspan( ham[ 1 ], { eggs: 2} )# trailing comma# Goodfoo = (0,)# Badbar = (0, )# , ; : 전은 공백없이# Goodif x == 4: print x, y; x, y = y, x# Badif x == 4 : print x , y ; x , y = y , x# Slice의 :는 binary operator처럼# 양쪽 공백은 같아야함# Goodham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset]# Badham[lower + offset:upper + offset]ham[1: 9], ham[1 :9], ham[1:9 :3]ham[lower : : upper]ham[ : upper]# Function Call 전에는 공백이 없어야 함# 마찬가지로 indexing, slicing전에도 없어야함# Goodspam(1)dct[\"key\"] = lst[index]# Badspam (1)dct [\"key\"] = lst [index]# 이런 것도 안됨# Good x = 1y = 2long_variable = 3# Badx             = 1y             = 2long_variable = 3# 다음과 같은 연산자 양 옆은 한 칸씩 띄우자# assignment =, +=, -=, *=, **=, /=, //=# comparison ==, &lt;, &gt;, &lt;=, &gt;=, in, not in, is, is not# boolean and, or, not# binary operator가 여러 개면, 가장 낮은 우선 순위를 가진 것을 공백 처리하자# Goodi = i + 1submitted += 1x = x*2 - 1hypo2 = x*x + y*yc = (a+b) * (a-b)# Badi=i+1submitted +=1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b)# Function Annotation은 기본 : 의 룰을 따르고# -&gt; 가 있다면 앞 뒤로 한 칸씩 띄우자# Gooddef something(input: AnyStr): ...def something() -&gt; PosInt: ...# Baddef something(input:AnyStr): ...def something()-&gt;PosInt: ...# Keyword argument나 unannotated parameter의 값을 정해주는 =는 띄우지 말자# Gooddef complex(real, image=0.0):    return magic(r=real, i=image)# Baddef complex(real, image = 0.0):    return magic(r = real, i = image)# Annotated parameter에 default값을 정해주는 경우 =는 한 칸씩 띄우자# Gooddef complex(image: Image = None): ...# Baddef complex(image: Image=None) ...# 한 줄에 여러 개의 statement는 쓰지 말자# Goodif foo == 'blah':    do_blah_thing()do_one()do_two()# Badif foo == 'blah': do_blah_thing()do_one(); do_two()When to use trailing commas # 1개의 아이템을 가진 tuple을 만들 때# goodFILES = (\"config.yml\",)# badFILES = \"config.yml\",# 아이템이 더 추가될 여지가 있을 때# 복수의 아이템이 들어있을 때는 # trailing comma 후 줄 바꿈 뒤 닫는 부호를 넣어야 한다# goodFILES = [    \"config.yml\",    \"setup.py\",]initialize(FILES,          error=True,          )# badFILES = [\"config.yml\", \"setup.py\",]initialize(FILES, error=True,)Comments   코드와 일치하지 않는 comment는 있으나마나다. 코드가 바뀌면 Comment도 업데이트하자.  inline comment는 당연한 것을 적으면 의미가 없다.  모든 public module, function, class, method에는 Docstring comment를 작성해야 한다.```pythondef something():  “\"”This is one liner”””  passclass Something():    “\"”This is some public class creates something\"\"\"pass ```Naming conventions   b = single lowercase letter  B = single uppercase letter  lowercase          Package      Module      Functions/Methods      variable names        lowercase_with_underscores          Module 은 가독성을 높이면 사용      Functions/Methods      Module Global variable      variable names        UPPERCASE          Constant        UPPERCASE_WITH_UNDERSCORES          Constant        CapitalizedWords          ClassName      Type Var      Exception Names, “Error”를 끝에 사용해야함      약어는 다 CAP으로 해주는 것이 좋음. eg: HTTPStatus O, HttpStatus X        mixedCase  Capitalized_Words_With_Underscores  _single_leading_underscore          “weak internal use”. eg: from M import * 는 underscore로 시작하는 것들은 import하지 않는다        single_trailing_underscore_          파이썬 기존 명칭과 겹치지 않게하기 위해 사용. eg: tkinter.Toplevel(master, class_='ClassName')        __double_leading_underscore          class attribute를 만들 때 사용        __double_leading_and_trailing_underscore__          user controlled space에 있는 “magic” 객체. 있는 것만 사용할 것 eg. __init__, __import__        I (아이), O (오), l (엘) 단일 letter로 쓰지 말자.  모든 instance 함수에는 self를 쓸 것  모든 classmethod 에는 cls를 쓸 것  인자명이 겹치면 _를 하나 붙이는 것이 나을 수 있음  non-public method와 instance는 앞에 _로 시작Inheritance를 생각하고 설계한다면:   class의 함수와 변수가 public 한지 non-public 한지 결정. 모르겠다면 non-public하게 만들어라.  private은 사용하지 않는다. Python에서는 private은 없다.      class Foo:      def __init__(self):          self.__bar = \"hello\"      print(Foo().__bar) # name error  print(Foo()._Foo__bar) # hello        Public attribute는 _로 시작하면 안된다  만약 public attribute가 다른 것과 이름이 같다면, 끝에 _를 붙이는 것이 약자로 만드는 것보다 낫다.  Public data attribute는 getter/setter를 만들지 않는 것이 낫다. 만약 기능적으로 무언가가 추가되어야 한다면, 외부에 노출되지 않게 @property를 사용해서 getter/setter를 만들어라. 단, 기능을 너무 많이 추가하지는 말자 (캐싱 같은 것은 괜춘).  만약 class 가 subclass (다른 class가 상속을 받음) 가능하면, 현재 class에서 subclass가 쓸 수 없는 변수, 함수는 __ 를 붙이자.      class Foo:      def __init__(self):          self.price = 0          self.__profit = 12      def show_my_profit(self):          return self.__profit  class Bar(Foo):      def __init__(self):          super(Bar, self).__init__()      # Override show_my_profit      # Otherwise,       # Bar.show_my_profit() remembers      # Foo's __profit      def show_my_profit(self):          return self.__profit  y = Foo()  print(y.show_my_profit())  # 12  x = Bar()  print(x.price)  # 0  # AttributeError: 'Bar' object has no attribute '_Bar__profit'  print(x.show_my_profit())      Public and internal interfaces   Backwards 호환성은 public interface에만 해당된다  public 과 internal interface를 쉽게 구분 할 수 있게 하는 것은 중요하다  보편적으로 _ 로 시작하는 것들은 internal 하다고 볼 수 있다  모든 public interface에는 코멘트가 있어야한다  __all__을 사용해 public API의 이름을 지정해야한다Programming Recommendations   다른 버전의 파이썬에 악영향이 없도록 코드를 짜야한다 (PyPy, Jython, IronPython, Cython, Psyco, etc)          예를 들면 CPython의 string concatenation 연산자 a += b에 의존하지 말고 \"\".join() 형식을 사용하자        None과 같은 singleton과의 비교는 == 대신 is, is not을 사용하자                    # Good  if x is not None:  if x is None:  # Bad  if x == None:  if not x is None: # 이런 식도 헷갈리니 사용하지 말자                      ordering operation을 수정 할 때는 6개 모두 수정하는 것이 좋다          __lt__, __le__, __gt__, __ge__, __eq__, __ne__      functools.total_ordering() decorator를 사용해도 된다        변수에 lambda를 사용해 함수를 만들지 말고 def로 선언하자                    # Good  def f(x):      return x          # Bad  f = lambda x: x                      Exception을 만들 때, BaseException 말고 Exception으로 부터 상속받자  Exception chaining은 적절한 이유가 있을 때만 사용하자. Python3 에서는 raise X from Y를 사용해서 기존 Exception에 대한 정보를 유지하자  Exception을 catch 할 때, 정확한 Exception 명을 잡도록 하자                    try:      import platform_specific_module  except ImportError:      platform_specific_module = None                    except 만 사용할 때는 logging이 제대로 될 때 사용하자        잡은 Exception에 이름을 줄 때는 Python 2.6에서 도입된 syntax를 활용하자                    try:      process_data()  except Exception as exc:      raise DataProcessingFailedError(str(exc))                      try, except 문을 사용할 때 try 구간 코드를 최대한 적게 작성하자  with를 사용해 resource를 닫자. Resource에 대한 권한을 얻는 것 외에는 Context manager는 함수를 사용해야 한다                    # Good  with conn.begin_transaction():      do_somein()          # Bad  with conn:      do_somein                      모든 경우 일관성있게 return 하도록 코드를 짜자                    # Good  def foo(x):      if x &gt;= 0:          return math.sqrt(x)      else:          return None          def bar(x):      if x &lt; 0:          return None      return math.sqrt(x)          # Bad  def foo(x):      if x &gt;= 0:          return math.sqrt(x)          def bar(x):      if x &lt; 0:          return      return math.sqrt(x)                      string module 보다 string method를 사용하자  string slicing보다 ''.startswith(), ''.endswith() 로 prefix와 suffix를 확인하자                    # Good  if foo.startswith('bar'):  # Bad  if foo[:3] == 'bar':                      type comparison을 할 때는 isinstance()를 사용하자                    # Good  if isinstance(obj, foo):  # Bad  if type(obj) is type(1):                      sequence (string, list, tuple)의 존재 여부를 확인 할 때는 아래와 같이 하자                    # Good  if seq:  if not seq:  # Bad  if len(seq):  if not len(seq)                          boolean 도 True 와 False 와 비교하지 말자                    # Good  if boolean:  if not boolean:  # Bad  if boolean == True:  if boolean == False:  # Worse  if boolean is True:                      flow control statement continue, break, return 등은 try … finally 문에 finally 블록에는 쓰지 말자          이유는 예외처리가 제대로 안되고 넘어가지기 때문이다.                # Bad  def foo():  try:      1 / 0  finally:      return 43          print(foo()) # prints 43 without error                      function annotation def foo(abc: int) -&gt; int, variable annotation code: int 등은 사용 가능하나 사용하지 않아도 무방하다","categories": [],
        "tags": ["python"],
        "url": "https://json9512.github.io/blog/%ED%8C%8C%EC%9D%B4%EC%8D%AC-PEP-8/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -8",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   Docker 이미지화  Github Actions로 테스트/Docker Hub 자동화이 포스트는 . . .   서버 배포 할 곳 정하기서버 배포 할 곳 정하기 AWS, GCP, Microsoft Azure가 대세지만 다른 몇 가지를 알아보고 가장 최적의 조합을 찾자.   내 컴퓨터, 기기 (라즈베리 파이)등을 상시 켜놓고 서버를 실행한 후 NAT설정으로 외부에서 연결 가능하게 하는 방법  PaaS를 사용하는 방법 (Heroku, Netlify)  IaaS를 사용하는 방법 (AWS, GCP, Azure)  서버를 구매 후 사용하는 방법정하는 기준은 다음과 같다.   요금  자동화가 가능한지  현재 앱 아키텍쳐가 가능한지11번의 경우 가능은 하지만 내가 컴퓨터를 직접적으로 사용하는데 불편함이 있으니까 패스하겠다. 2번의 경우는 상당히 간편한 방법이다. 요금도 무료인 곳이 많다. 단점은 서버가 한국에 없어서 느리다는 것 정도다. 3번. 확장성, 기능면에서 내가 원하는대로 할 수 있는게 가장 큰 장점이다. 역시 대세는 거스를 수 없나보다. 4번은 돈이 남아 돌면 하자. 서버 한 대가 얼만데.. 2번과 3번 중에서 정하면 된다. 조금 더 자세히 알아보자. 2번. PaaS   요금: 무료  자동화가 가능한지: 가능하다  아키텍쳐 호환성: 가능하다일단 사용한다면 Heroku를 사용할 것이다. 좋은 점은 앱을 만드는 것만 신경쓰고 나머지는 Heroku가 알아서 다 해준다. 즉 Infrastructure를 신경 쓸 필요가 없다. 그리고 PSQL 호환성 또한 좋다. 3번. IaaS   요금: 무료/유료  자동화가 가능한지: 가능하다  아키텍쳐 호환성: 가능하다IaaS는 AWS를 사용하겠다. 이유는 기능도 많고 커뮤니티도 커서 제일 정보를 구하기가 쉽다. 일단 Free Tier가 적용돼서 무료로 사용가능하다. Docker Image를 배포 할 ECR과 Fargate를 사용하거나 EC2를 사용할 것 같다. 무엇보다 다른 Micro service들을 더하는 것이 가능하다. 단점은 처음 설정하는 것이 어려울 수 있다. 3번 으로 결정하겠다. AWS 이제 컴퓨팅 리소스를 정해 볼 차례다. 그전에 AWS에는 어떤 것들이 있는지 알아보자. 주로 사용 할 것들만 모아봤다.   EC2 - 컴퓨터라고 보면된다, OS 설치 후 쓰고 싶은 용도로 사용하면 된다. 단 OS의 GUI는 기본적으로 없다.  Fargate - 특정 Container를 실행 시키는 기기라고 생각하면 된다. 서버를 띄울수도 있고, 함수를 돌려도 되고 개발자 마음이다.  ECS - Container 관리 툴이다. 보통 이거랑 Fargate/EC2 조합으로 컨테이너 관리를 할 수 있다. 새로운 서비스 배포 시 블루/그린2 방식으로 배포한다.  ECR - 이미지 Registry다. Docker Hub과 같다고 생각하면 된다.  S3 - 데이터 저장소다, 간단하게 Key/value 형식을 가지고 있다.  RDS - 관계형 데이터 저장소다, PSQL, MySQL등이 구동 가능하다.  AWS API Gateway - API 관리를 쉽게 해주는 Gateway다. 외부에서는 API Gateway의 주소로 접속을 하게 되고 API Gateway는 접속하는 경로에 따라 다른 URI로 돌려줄 수도 있고, 연결된 AWS lambda를 실행 시킬 수 있다.현재 AWS Free tier로 12개월 동안은 EC2, Lambda, RDS, API Gateway등 다 무료다. Free tier를 지원 안하는 것은 Fargate 밖에 없다. 이제 mediumclone-go를 어떤 조합으로 배포 가능한지 알아보자.   아 몰라 EC2 조합:          데이터베이스: EC2에 PSQL 구동      Go 서버: 다른 EC2에 Docker 설치 후 Container 구동        요즘 핫한 serverless 조합:          데이터베이스: RDS 구동      Go 서버: Endpoint 별로 AWS Lambda로 작성      추가요소: AWS API Gateway        무난무난한 조합:          데이터베이스: RDS 구동      Go 서버: EC2 구동      추가요소: ECR에 Docker 이미지 저장 후 ECS로 컨테이너 관리      아 몰라 EC2 조합 가장 쉽다. 그냥 EC2 두 개만 띄워서 하나는 PSQL을 구동 시키고 다른 하나는 Go 서버를 구동 시키면 된다. 문제는 자동화가 불가능 할 수도 있다. EC2는 특성상 새로 생성이 되면 임의의 ip, dns가 생성이 되는데 Go 서버와 PSQL을 서로 연결 시키려면 상당히 삽질을 많이 해야 할 수도 있다. 요즘 핫한 serverless 조합 데이터베이스는 제공되는 AWS RDS를 사용한고 Go 서버를 함수 단위로 나눠서 AWS Lambda로 돌리는 방식이다. 구조를 간략히 설명하자면:  이런 식으로 AWS API Gateway의 ip로 외부에서 접속을 하게되면, Gateway가 각 경로에 맞게 AWS Lambda를 실행 시키는 방법이다. 장점은 서버가 필요 없다는 점이고 단점은 처음 Go로 RESTful한 API를 만들려고한 목적이 살짝 애매해 질 수 있다. 원래는 하나의 서버를 생각했었기 때문이다. 이 조합은 Lambda가 설정만 돼있으면 API Gateway만 자동화 시키면 되기 때문에 쉬울 것 같다. (Lambda 변경 시 자동으로 반영 되는지는 아직 모른다) 무난무난한 조합 위와 비슷한 방법으로는 ECS + ECR + Fargate/EC2가 있다.  이런 식으로 AWS ECR에서 이미지를 불러와서 ECS가 알아서 Fargate나 EC2 인스턴스를 구동시키는 것이다. EKS를 써도 되지만 컨테이너는 어차피 1개 ~ 2개 쓸거기 때문에 너무 과도한 것 같아서 ECS를 쓰겠다. 데이터베이스는 AWS RDS로 구동한다. 이 조합은 Github Actions로 자동화가 가능할 것 같다. 결정 요즘 핫한 serverless 조합이 끌리기는 하지만 이번에는 무난무난한 조합으로 가도록 하겠다. 마무리 정리를 하자면:   서버 배포 방법을 AWS ECS + ECR + EC2 + RDS 조합으로 결정했다다음 포스트는 이것을 AWS를 이용해 구성하는 방법에 대해 알아보자.             이전 포스트에서 “Monolithic” 한 아키텍쳐를 사용한다고 했다. 하지만 인증/인가를 Oauth2로 정함과 동시에 “Monolithic”한 아키텍쳐는 아니라고 볼 수 있다. 이렇게 된 거 데이터베이스도 따로 만들려고 한다. 이유는 하나의 인스턴스에 Go server와 Postgresql을 같이 만들게 되면 인스턴스가 “stateful” 하게 된다. 즉, 이 인스턴스가 꺼지면 Postgresql에 저장된 정보도 날아간다. 현재 아키텍쳐를 다시 나열 하자면 아래와 같다:1. Go 서버2. 인증/인가 서버 (외부: 아마도 구글)3. Database (이것도 PSQL을 쓸지 딴 것을 쓸지 고민을 해야한다)4. 나중에 만들 Frontend &#8617;               새로 서비스가 배포 될 때 기존 서비스의 트래픽을 새 서비스로 향하게 하고, 기존 서비스를 종료시키는 배포 방식. &#8617;       ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-8/"
      },{
        "title": "Job sequencing algorithm",
        "excerpt":"출처: GeeksForGeeks Job sequencing, deadline scheduling 알고리즘에 대해 알아보자   그리디 알고리즘  N 개의 [일 ID, 마감일, 이윤]가 주어 질 때, 최대 마감일이 되었을 때 최대 이윤을 구하는 알고리즘.  마감일은 1 이상이고 마감일 전에 일을 끝내야 이익을 얻을 수 있다.  시간은 unit time이다. (eg. 1 = 1일)방법   모든 데이터를 이윤을 기준으로 내림차순 정렬을 한다  데이터를 iterate하면서 다음을 반복한다:          빈 시간 i를 찾는다. 찾는 기준은 i &lt; deadline이면서 데이터 중에서 i가 가장 커야한다.      i를 빈 자리에 넣고 표시를 한다      조건에 맞는 i가 없으면 넘어간다      Python def jobsequencing(jobs, time):    # 이윤을 기준으로 내림차순으로 정렬     # 데이터는 [job_id, deadline, profit]으로 됐다    jobs.sort(key=lambda x: x[2], reverse=True)    # 빈 자리를 표시하는 리스트    free_slots = [False] * time    # 결과 값을 저장하는 리스트    answer = [-1] * time    print(jobs)    # 주어진 jobs를 iterate한다    for i in range(len(jobs)):                # 이 일을 위한 다음 빈 자리를 찾는다        # 가능한 자리에서부터 시작한다        for j in range(min(time-1, jobs[i][1]-1), -1, -1):            # 빈자리 발견 시            if not free_slots[j]:                free_slots[j] = True                answer[j] = jobs[i][0] # job ID를 넣는다                break    return answerjobs = [    ['a', 2, 100],  # [job, deadline, profit]    ['b', 1, 19],     ['c', 2, 27],     ['d', 1, 25],     ['e', 3, 15]]# lambda function denotes the max function to find# the maximum value for deadlinejob_max_deadline = max(jobs, key=lambda x: x[1])ans = jobsequencing(jobs, job_max_deadline[1])print(ans) # ['c', 'a', 'e']Job sequencing을 사용하는 문제 Leetcode 1234번 Maximum profit in job scheduling ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Job-Sequencing-algorithm/"
      },{
        "title": "Pigeonhole Sort",
        "excerpt":"출처: GeeksforGeeks Pigeonhole 정렬에 대해 알아보자   특정 Range에 있는 아이템들을 정렬할 때 사용한다  Counting sort와 비슷하다  다른점은 Counting Sort는 아이템의 frequency를 저장한 counter로 정렬된 리스트에 아이템을 놓지만, Pigeonhole sort는 아이템 자체를 bucket에 복사한 후 다시 정렬된 리스트로 복사하는 방법이다.Time complexity   Worst Case: O(n+k) k가 인풋의 range, n이 인풋의 개수Space complexity   O(n+k)Pigeonhole sort visualization   Python def pigeonhole_sort(arr):    # Find the range of the items    min_val = int(min(arr))    max_val = int(max(arr))    range_of_val = max_val - min_val + 1    # create holes(buckets) to store the items    holes = [0] * range_of_val    # populate the pigeonholes    for value in arr:        holes[value-min_val] += 1        # place the items back to the array in order    i = 0    for count in range(range_of_val):        while holes[count] &gt; 0:            holes[count] -= 1            arr[i] = count + min_val            i += 1        # Time comp: O(n + k)    # Space comp: O(n + k)    # Stablearr = [5, 2, 3, 1, 16, 4, 7]pigeonhole_sort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Pigeonhole-Sort/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -9",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   서버 배포 방법을 정함이 포스트는 . . .   AWS로 서버 배포를 해보기AWS로 서버 배포를 해보기 AWS에서 사용할 서비스는 다음과 같다.   AWS RDS - Postgresql 배포  AWS ECR - Docker Image를 배포  AWS ECS - 컨테이너를 관리  AWS EC2 - 컴퓨팅 엔진 (컨테이너가 돌아가는 컴퓨터)각 서비스의 요금표는 다음과 같다.   AWS RDS - db.t2.micro 인스턴스 구동시 월 750시간 무료 (24/7 무료)  AWS ECR - 월별 500MB 스토리지  AWS ECS - 따로 청구되는 비용은 없음, EC2 요금  AWS EC2 - t2.micro 인스턴스 구동시 월 750시간 무료 (24/7 무료)정리를 하면, 프리티어가 끝날때까지 24/7 구동 가능한 것은 EC2 하나와 RDS 하나다. 이번 프로젝트를 위해서는 충분하다. AWS RDS with Postgresql 데이터베이스부터 구동을 해보자. AWS RDS 에서 천천히 가이드를 따라서 생성을 해보자. 중요한건 프리티어를 적용하고 만들고나서 Master와 비밀번호를 메모하자.  AWS ECR 이번에는 이미지 레지스트리 헙을 구동 시켜보자. 레지스트리 이름을 정하고 기본 값으로 구동시켰다. AWS CLI를 설치를 해주자. 이후 AWS CLI에 aws configure로 AWS 계정 정보를 입력한 뒤 ECR 푸시 명령에 따라서 푸시를 하면  푸시가 잘 된걸 볼 수 있다. 문제는 용량이 월 500MB 제한인데, 지금 아무것도 없는 서버가 355MB정도 하니까 제대로 서버를 만들고 올리면 걍 용량 초과할 것 같다. 일단 나중에 생각하기로 하자. AWS ECS 이미지도 ECR에 성공적으로 올렸으니 ECS로 컨테이너를 구동해보자. ECS에는 Cluster를 먼저 만들어야한다. Linux + EC2로 t2.micro를 사용하여 클러스터를 생성하자.  위에 8000번 포트를 80옆에 같이 적어준다. 8000번 포트에다가 도커 컨테이너 포트 매핑을 할 것이기 때문이다. 나는 이걸 까먹어서 EC2를 열어서 인바운드 규칙을 더해줬다. 클러스터는 이렇게 만들면 된다. 이후 새 작업정의를 EC2로 만들자. 기본 설정을 쭉 따라가다가 보면 컨테이너 추가란이 있다.  컨테이너 추가를 누른 뒤 튀어나오는 설정을 다 해주고 이미지란에 ECR 레퍼지토리에 있는 이미지의 URI를 복붙해주자.  포트 매핑도 해주자 8000번 포트 (EC2)에 8080번 포트(도커 컨테이너)를 매핑하자.  이제 아까 만든 클러스터로 돌아가서 서비스를 만들어 보자.  자동으로 방금 만든 작업이 기본값으로 설정돼있다. 작업 개수만 정하고 배포로 넘어가자.  전 포스트에서 배포 방식을 블루/그린으로 한다고 했던 거 같은데, 블루/그린 방식으로 배포를 하려면IAM Role이 필요하다. 아직은 IAM Role에 대해서 잘 모르니까 일단 롤링 업데이트1 형식으로 하자. 이후 Auto Scaling Group 설정이 나오지만 현재는 로드 밸런서가 필요가 없으니까 없음으로 하자. 로드 밸런싱 설정도 다 없음으로 하자. 이후 서비스를 생성하면 실행이 되는 것을 볼 수 있는데 도커 컨테이너가 담긴 EC2를 실행하기까지 시간이 좀 걸린다. 모든것을 다 정상적으로 처리를 하면 클러스터 서비스란에 다음과 같이 방금 만든 서비스가 RUNNING 상태로 변하는 것을 볼 수 있다.  이후 제공되는 DNS나 IPv4 주소로 /ping endpoint로 가보면:  위와 같이 잘 작동하는 것을 볼 수 있다. 마무리 . . . 정리를 하면:   전 포스트에서 설계한 배포 방식으로 AWS로 배포하는 것을 해봤다다음 포스트에서는 배포 자동화 방법에 대해 알아보자.             한 대씩 서버를 재시작 하는 방식이다. &#8617;       ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-9/"
      },{
        "title": "Minimum number of coins algorithm",
        "excerpt":"출처: GeeksForGeeks Minimum number of coins 알고리즘에 대해 알아보자   그리디 알고리즘  돈 V 가 주어졌을 때, 최소 개수의 동전/지폐로 거슬러 줄 수 있는 알고리즘  돈 V = 70이고 지폐 [50, 20, 10] 이 주어졌을 때, 최소 개수의 지폐는 [50, 20]다방법   내림차순으로 동전/지폐를 정렬  현재 돈 보다 적은 denomination을 찾는다  찾은 denomination을 결과값에 더해주고 현재 돈에서 denomination을 빼준다  현재 돈이 0이 될 때까지 반복Python def min_num_coin(value, coins):    # initialize ans list    ans = []    # sort the denominations, coins    coins.sort()    # traverse through all denominations (동전/화폐 단위)    # from the largest -&gt; smallest    i = len(coins) - 1    while i &gt;= 0:        # find denominations        while value &gt;= coins[i]:            value -= coins[i]            ans.append(coins[i])                i -= 1        return ans# Testvalue = 70coins = [5, 10, 50, 15, 20]print(min_num_coin(value, coins)) # [50, 20]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Minimum-number-of-coins-algorithm/"
      },{
        "title": "Cycle Sort",
        "excerpt":"출처: GeeksforGeeks Cycle 정렬에 대해 알아보자   Inplace한 알고리즘  stable하지 않은 알고리즘  아이템의 위치를 계속 찾으면서 최하 쓰기 횟수로 기존 array를 정렬하는 방식Time complexity   Worst Case: O(n^2)Space complexity   O(1)Cycle sort visualization   Python def cycle_sort(arr):    # loop through the array and find the cycles to rotate    for cycle_start in range(0, len(arr)-1):        item = arr[cycle_start]        # find where to place the item        pos = cycle_start        for i in range(cycle_start+1, len(arr)):            if arr[i] &lt; item:                pos += 1                # if pos is the start of cycle, skip        if pos == cycle_start:            continue                    # otherwise, place the item at pos or after any        # duplicate        while item == arr[pos]:            pos += 1                arr[pos], item = item, arr[pos]        # rotate the rest of the cycle        while pos != cycle_start:                        # find where to place the item            pos = cycle_start            for i in range(cycle_start+1, len(arr)):                if arr[i] &lt; item:                    pos += 1                        # place the item            while item == arr[pos]:                pos += 1                        arr[pos], item = item, arr[pos]        # O(n^2), O(1), not stablearr = [5, 2, 3, 1, 16, 4, 7]cycle_sort(arr)print(arr) # [1, 2, 3, 4, 5, 7, 16]","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Cycle-Sort/"
      },{
        "title": "Search algorithms",
        "excerpt":"출처: GeeksforGeeks 여러가지 Search 알고리즘에 대해 알아보자   Linear Search  Binary Search  Jump Search  Interpolation Search  Exponential Search  Ternary SearchLinear Search   제일 쉬운 알고리즘  O(n) 의 시간 복잡도를 가진다def search(arr, target=None):    if not target:        return -1        for i in range(len(arr)):        if arr[i] == target:            return i        return -1arr = [1, 5, 3, 2, 4]print(search(arr, 5)) # 1print(search(arr, 0)) # -1print(search(arr)) # -1Binary Search   이분탐색  각 iteration마다 탐색 해야 할 배열의 크기를 반으로 줄인다  단, 탐색해야 하는 배열이 이미 정렬이 되어야한다.  O(log n)의 시간 복잡도를 가진다def binary_search(arr, target=0):    arr.sort()    left = 0    right = len(arr) - 1    while left &lt;= right:        mid = (left+right) // 2        if arr[mid] == target:            return mid                if arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return -1arr = [1, 5, 3, 2, 4]print(binary_search(arr, 5)) # 4 because [1, 2, 3, 4, 5] -&gt; a[4] = 5print(binary_search(arr, 0)) # -1print(binary_search(arr)) # -1Jump Search   Linear 탐색과 비슷하지만 block을 정해서 문제의 단위를 줄이는 방식  배열은 정렬이 되어있어야 한다  O(√n)의 시간복잡도를 가진다  선형탐색 O(n)과 이분탐색 O(log n)사이다.import math def jump_search(arr, target=0):    arr.sort()    n = len(arr)    # jump를 할 step을 지정해준다    # jump와 jump사이가 하나의 block이 된다    step = math.sqrt(n)    # target이 있는 block을 찾아준다    prev = 0    while arr[int(min(step, n)-1)] &lt; target:        prev = step        step += math.sqrt(n)        if prev &gt;= n:            return -1        # 찾은 block에 Linear 탐색을 시작    i = prev    while arr[int(i)] &lt; target:        i += 1        # block의 끝이나 배열의 끝에 도달 했으면         # target은 없는 것        if i == min(step, n):            return -1        if arr[int(i)] == target:        return int(i)        return -1arr = [1, 5, 3, 2, 4]print(jump_search(arr, 5)) # 4 because [1, 2, 3, 4, 5] -&gt; a[4] = 5print(jump_search(arr, 0)) # -1print(jump_search(arr)) # -1Interpolation Search   배열이 정렬이 되어있어야 한다  균일한 분포를 가질 때 사용가능하다  찾아야할 타겟과 가까운 지점에서 탐색을 시작한다  O(n)의 시간복잡도를 갖지만 균일분포된 배열에서의 탐색은 O(log log n)이다def interpolation_search(arr, target=0):    arr.sort()    n = len(arr)    # low, high를 지정한다    low = 0    high = n - 1    # target은 low, high내에 있어야한다    while low&lt;=high and arr[low]&lt;=target&lt;=arr[high]:        if low == high:            if arr[low] == target:                return low            return -1                # 균일분포도를 고려해서 탐색위치를 지정한다        ceil = float(high-low) / (arr[high]-arr[low])        ceil *= (target-arr[low])        pos = low + int(ceil)        if arr[pos] == target:            return pos                if arr[pos] &lt; target:            low = pos + 1        else:            high = pos -1        return -1arr = [1, 5, 3, 2, 4]print(interpolation_search(arr, 5)) # 4 because [1, 2, 3, 4, 5] -&gt; a[4] = 5print(interpolation_search(arr, 0)) # -1print(interpolation_search(arr)) # -1Exponential Search   Jump 탐색처럼 탐색의 위치를 찾은 후, 그 block을 이분 탐색한다  이분탐색을 사용하여 탐색의 크기를 재귀적으로 줄인다  이분탐색보다 빠를 때도 있다          찾아야하는 위치가 배열의 앞쪽에 위치한다면 더 빠르게 탐색이 가능하다      탐색의 위치를 선형적으로 찾기 때문이다        O(log n)의 시간복잡도를 가진다def binary_search(arr, left, right, target):    while left &lt;= right:        mid = (left+right) // 2        if arr[mid] == target:            return mid        if arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return -1def exponential_search(arr, target=0):    arr.sort()    n = len(arr)    if arr[0] == target:        return 0        # 탐색할 위치를 찾는다    i = 1    while i&lt;n and arr[i]&lt;=target:        i *= 2        # 탐색의 시작과 끝 지점을 정한다    left = i // 2    right = min(i, n-1)    return binary_search(arr, left, right, target)arr = [1, 5, 3, 2, 4]print(exponential_search(arr, 5)) # 4 because [1, 2, 3, 4, 5] -&gt; a[4] = 5print(exponential_search(arr, 0)) # -1print(exponential_search(arr)) # -1Ternary Search   분할정복 알고리즘  배열은 정렬이 되어있어야 한다  이분탐색이 탐색 크기를 반으로 줄이는 것처럼, 삼분탐색은 3등분을 해서 찾는 알고리즘  O(log n)의 시간 복잡도를 가진다  이분탐색보다 느리다. 이유는 3등분으로 분할해서 탐색을 하다보니 비교 횟수가 높아지기 때문이다def ternary_search(arr, left, right, target=0):    arr.sort()    if left &lt;= right:        mid1 = left+(right-left) // 3        mid2 = mid1+(right-left) // 3        if arr[mid1] == target:            return mid1                if arr[mid2] == target:            return mid2                if arr[mid1] &gt; target:            return ternary_search(arr, left, mid1-1, target)                if arr[mid2] &lt; target:            return ternary_search(arr, mid2+1, right, target)        return -1arr = [1, 5, 3, 2, 4]print(ternary_search(arr, 0, len(arr)-1, 5)) # 4 because [1, 2, 3, 4, 5] -&gt; a[4] = 5print(ternary_search(arr, 0, len(arr)-1, 0)) # -1print(ternary_search(arr, 0, len(arr)-1)) # -1","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Search-algorithms/"
      },{
        "title": "백준 문제집",
        "excerpt":"2021 코딩테스트 준비 기초 2021 코딩테스트 준비 연습 2021 코딩테스트 준비 문제 2021 코딩테스트 준비 기초 수학             문제      풀이      완료                  10430번 - 나머지      풀이      ✔️              4375번 - 1      풀이      ✔️              1037번 - 약수      풀이      ✔️              17427번 - 약수의 합 2      풀이      ✔️              17425번 - 약수의 합      풀이      ❌              2609번 - 최대공약수와 최소공배수      풀이      ✔️              1978번 - 소수 찾기      풀이      ✔️              1929번 - 소수 구하기      풀이      ✔️              6588번 - 골드바흐의 추측      풀이      ✔️      브루트 포스             문제      풀이      완료                  2309번 - 일곱 난쟁이      풀이      ✔️              3085번 - 사탕 게임      풀이      ✔️              1476번 - 날짜 계산      풀이      ✔️              1107번 - 리모컨      풀이      ✔️              14500번 - 테트로미노      풀이      ✔️              6064번 - 카잉 달력      풀이      ✔️              1748번 - 수 이어 쓰기 1      풀이      ✔️              9095번 - 1, 2, 3 더하기      풀이      ✔️      브루트 포스 - N 과 M             문제      풀이      완료                  15649번 - N과 M (1)      풀이      ✔️              15650번 - N과 M (2)      풀이      ✔️              15651번 - N과 M (3)      풀이      ✔️              15652번 - N과 M (4)      풀이      ✔️              15654번 - N과 M (5)      풀이      ✔️              15655번 - N과 M (6)      풀이      ✔️              15656번 - N과 M (7)      풀이      ✔️              15657번 - N과 M (8)      풀이      ✔️              18290번 - NM과 K (1)      풀이      ❌      브루트 포스 - 재귀             문제      풀이      완료                  9095번 - 1, 2, 3 더하기      풀이      ✔️              1759번 - 암호 만들기      풀이      ✔️              14501번 - 퇴사      풀이      ✔️              14889번 - 스타트와 링크      풀이      ✔️              15661번 - 링크와 스타트      풀이      ❌              2529번 - 부등호      풀이      ✔️              1248번 - 맞춰봐      풀이      ✔️      브루트 포스 - 순열             문제      풀이      완료                  10972번 - 다음 순열      풀이      ✔️              10973번 - 이전 순열      풀이      ✔️              10974번 - 모든 순열      풀이      ✔️              10819번 - 차이를 최대로      풀이      ✔️              10971번 - 외판원 순회 2      풀이      ❌              6603번 - 로또      풀이      ❌      브루트 포스 - 비트 마스크             문제      풀이      완료                  11723번 - 집합      풀이      ❌              1182번 - 부분수열의 합      풀이      ❌              14889번 - 스타트와 링크      풀이      ❌              14391번 - 종이 조각      풀이      ❌      다이나믹 프로그래밍 part 1             문제      풀이      완료                  1463번 - 1로 만들기      풀이      ✔️              11726번 - 2×n 타일링      풀이      ✔️              11727번 - 2×n 타일링 2      풀이      ✔️              9095번 - 1, 2, 3 더하기      풀이      ✔️              11052번 - 카드 구매하기      풀이      ✔️              16194번 - 카드 구매하기 2      풀이      ✔️              15990번 - 1, 2, 3 더하기 5      풀이      ✔️              10844번 - 쉬운 계단 수      풀이      ❌              2193번 - 이친수      풀이      ❌              11053번 - 가장 긴 증가하는 부분 수열      풀이      ❌              14002번 - 가장 긴 증가하는 부분 수열 4      풀이      ❌              1912번 - 연속합      풀이      ❌              1699번 - 제곱수의 합      풀이      ❌              14501번 - 퇴사      풀이      ❌              2225번 - 합분해      풀이      ❌      다이나믹 프로그래밍 part 2             문제      풀이      완료                  15988번 - 1, 2, 3 더하기 3      풀이      ❌              1149번 - RGB거리      풀이      ❌              1309번 - 동물원      풀이      ❌              11057번 - 오르막 수      풀이      ❌              2156번 - 포도주 시식      풀이      ❌              1932번 - 정수 삼각형      풀이      ❌              11055번 - 가장 큰 증가 부분 수열      풀이      ❌              11722번 - 가장 긴 감소하는 부분 수열      풀이      ❌              11054번 - 가장 긴 바이토닉 부분 수열      풀이      ❌              13398번 - 연속합 2      풀이      ❌              2133번 - 타일 채우기      풀이      ❌      큐와 그래프             문제      풀이      완료                  10845번 - 큐      풀이      ✔️              10866번 - 덱      풀이      ✔️              13023번 - ABCDE      풀이      ✔️              1260번 - DFS와 BFS      풀이      ✔️              11724번 - 연결 요소의 개수      풀이      ✔️              1707번 - 이분 그래프      풀이      ✔️              2667번 - 단지번호붙이기      풀이      ❌              2178번 - 미로 탐색      풀이      ❌              7576번 - 토마토      풀이      ❌              7562번 - 나이트의 이동      풀이      ❌      BFS             문제      풀이      완료                  1697번 - 숨바꼭질      풀이      ✔️              13913번 - 숨바꼭질 4      풀이      ✔️              14226번 - 이모티콘      풀이      ✔️              13549번 - 숨바꼭질 3      풀이      ✔️              1261번 - 알고스팟      풀이      ❌      시뮬레이션과 구현             문제      풀이      완료                  16935번 - 배열 돌리기 3      풀이      ✔️              16926번 - 배열 돌리기 1      풀이      ✔️              16927번 - 배열 돌리기 2      풀이      ✔️              14499번 - 주사위 굴리기      풀이      ✔️              14890번 - 경사로      풀이      ❌              15662번 - 톱니바퀴 (2)      풀이      ✔️              14503번 - 로봇 청소기      풀이      ✔️              15685번 - 드래곤 커브      풀이      ❌              2290번 - LCD Test      풀이      ❌              16931번 - 겉넓이 구하기      풀이      ❌              1917번 - 정육면체 전개도      풀이      ❌              16967번 - 배열 복원하기      풀이      ❌              20327번 - 배열 돌리기 6      풀이      ❌              20055번 - 컨베이어 벨트 위의 로봇      풀이      ❌      2021 코딩테스트 준비 연습 브루트 포스 - 재귀             문제      풀이      완료                  6603번 - 로또      풀이      ❌              1182번 - 부분수열의 합      풀이      ❌              14225번 - 부분수열의 합      풀이      ❌              14888번 - 연산자 끼워넣기      풀이      ❌              15658번 - 연산자 끼워넣기 (2)      풀이      ❌              14500번 - 테트로미노      풀이      ❌              16198번 - 에너지 모으기      풀이      ❌              9663번 - N-Queen      풀이      ❌              2580번 - 스도쿠      풀이      ❌              4574번 - 스도미노쿠      풀이      ❌      브루트 포스 - 순열             문제      풀이      완료                  2529번 - 부등호      풀이      ❌              1339번 - 단어 수학      풀이      ❌              14888번 - 연산자 끼워넣기      풀이      ❌              14889번 - 스타트와 링크      풀이      ❌      브루트 포스 - 비트마스크             문제      풀이      완료                  14225번 - 부분수열의 합      풀이      ❌              1062번 - 가르침      풀이      ❌              13460번 - 구슬 탈출 2      풀이      ❌              12100번 - 2048 (Easy)      풀이      ❌      브루트 포스 - 기타             문제      풀이      완료                  2003번 - 수들의 합 2      풀이      ❌              1806번 - 부분합      풀이      ❌              1644번 - 소수의 연속합      풀이      ❌              1208번 - 부분수열의 합 2      풀이      ❌              2143번 - 두 배열의 합      풀이      ❌      그래프 알고리즘             문제      풀이      완료                  16929번 - Two Dots      풀이      ❌              16947번 - 서울 지하철 2호선      풀이      ❌              12946번 - 육각 보드      풀이      ❌              16940번 - BFS 스페셜 저지      풀이      ❌              16964번 - DFS 스페셜 저지      풀이      ❌      BFS 알고리즘             문제      풀이      완료                  16928번 - 뱀과 사다리 게임      풀이      ❌              16948번 - 데스 나이트      풀이      ❌              14502번 - 연구소      풀이      ❌              12886번 - 돌 그룹      풀이      ❌              2206번 - 벽 부수고 이동하기      풀이      ❌              16946번 - 벽 부수고 이동하기 4      풀이      ❌              14442번 - 벽 부수고 이동하기 2      풀이      ❌              16933번 - 벽 부수고 이동하기 3      풀이      ❌              16954번 - 움직이는 미로 탈출      풀이      ❌              16236번 - 아기 상어      풀이      ❌              6087번 - 레이저 통신      풀이      ❌              1963번 - 소수 경로      풀이      ❌              10026번 - 적록색약      풀이      ❌              14395번 - 4연산      풀이      ❌              5014번 - 스타트링크      풀이      ❌              9376번 - 탈옥      풀이      ❌              1600번 - 말이 되고픈 원숭이      풀이      ❌              17086번 - 아기 상어 2      풀이      ❌              4991번 - 로봇 청소기      풀이      ❌              2234번 - 성곽      풀이      ❌              12906번 - 새로운 하노이 탑      풀이      ❌              17141번 - 연구소 2      풀이      ❌              17142번 - 연구소 3      풀이      ❌      다이내믹 프로그래밍             문제      풀이      완료                  11048번 - 이동하기      풀이      ❌              11060번 - 점프 점프      풀이      ❌              10942번 - 팰린드롬?      풀이      ❌              15989번 - 1, 2, 3 더하기 4      풀이      ❌              11066번 - 파일 합치기      풀이      ❌              12865번 - 평범한 배낭      풀이      ❌              1495번 - 기타리스트      풀이      ❌              12869번 - 뮤탈리스크      풀이      ❌              10422번 - 괄호      풀이      ❌              2293번 - 동전 1      풀이      ❌              2294번 - 동전 2      풀이      ❌              11058번 - 크리보드      풀이      ❌              9251번 - LCS      풀이      ❌              9252번 - LCS 2      풀이      ❌              5582번 - 공통 부분 문자열      풀이      ❌              5557번 - 1학년      풀이      ❌      시뮬레이션과 구현             문제      풀이      완료                  16234번 - 인구 이동      풀이      ❌              16235번 - 나무 재테크      풀이      ❌              17144번 - 미세먼지 안녕!      풀이      ❌              17143번 - 낚시왕      풀이      ❌              17140번 - 이차원 배열과 연산      풀이      ❌              17780번 - 새로운 게임      풀이      ❌              17837번 - 새로운 게임 2      풀이      ❌              17822번 - 원판 돌리기      풀이      ❌              16939번 - 2×2×2 큐브      풀이      ❌              16974번 - 레벨 햄버거      풀이      ❌              20061번 - 모노미노도미노 2      풀이      ❌              19236번 - 청소년 상어      풀이      ❌              19237번 - 어른 상어      풀이      ❌      2021 코딩테스트 준비 문제 브루트 포스 파트 1             문제      풀이      완료                  16968번 - 차량 번호판 1      풀이      ❌              16917번 - 양념 반 후라이드 반      풀이      ❌              16922번 - 로마 숫자 만들기      풀이      ❌              16924번 - 십자가 찾기      풀이      ❌              16936번 - 나3곱2      풀이      ❌              16937번 - 두 스티커      풀이      ❌              16938번 - 캠프 준비      풀이      ❌              16943번 - 숫자 재배치      풀이      ❌              16637번 - 괄호 추가하기      풀이      ❌              15683번 - 감시      풀이      ❌              17088번 - 등차수열 변환      풀이      ❌              15686번 - 치킨 배달      풀이      ❌              2210번 - 숫자판 점프      풀이      ❌              2422번 - 한윤정이 이탈리아에 가서 아이스크림을 사먹는데      풀이      ❌              9944번 - NxM 보드 완주하기      풀이      ❌              17089번 - 세 친구      풀이      ❌              17406번 - 배열 돌리기 4      풀이      ❌              17135번 - 캐슬 디펜스      풀이      ❌              17281번 - ⚾      풀이      ❌      브루트 포스 파트 2             문제      풀이      완료                  17779번 - 게리맨더링 2      풀이      ❌              17070번 - 파이프 옮기기 1      풀이      ❌              17069번 - 파이프 옮기기 2      풀이      ❌              16638번 - 괄호 추가하기 2      풀이      ❌              17085번 - 십자가 2개 놓기      풀이      ❌              17825번 - 주사위 윷놀이      풀이      ❌              16987번 - 계란으로 계란치기      풀이      ❌              16988번 - Baaaaaaaaaduk2 (Easy)      풀이      ❌              15684번 - 사다리 조작      풀이      ❌              4902번 - 삼각형의 값      풀이      ❌              16945번 - 매직 스퀘어로 변경하기      풀이      ❌              16953번 - A → B      풀이      ❌              17136번 - 색종이 붙이기      풀이      ❌              17471번 - 게리맨더링      풀이      ❌      브루트 포스 파트 3             문제      풀이      완료                  16985번 - Maaaaaaaaaze      풀이      ❌              17090번 - 미로 탈출하기      풀이      ❌              12931번 - 두 배 더하기      풀이      ❌              16958번 - 텔레포트      풀이      ❌              12908번 - 텔레포트 3      풀이      ❌              16957번 - 체스판 위의 공      풀이      ❌              16971번 - 배열 B의 값      풀이      ❌              17472번 - 다리 만들기 2      풀이      ❌              14056번 - K번째 좋은 문자열      풀이      ❌      그래프 알고리즘             문제      풀이      완료                  2252번 - 줄 세우기      풀이      ❌              2056번 - 작업      풀이      ❌              14263번 - 카드 놓기      풀이      ❌      BFS 알고리즘             문제      풀이      완료                  8111번 - 0과 1      풀이      ❌              17071번 - 숨바꼭질 5      풀이      ❌              1525번 - 퍼즐      풀이      ❌              16973번 - 직사각형 탈출      풀이      ❌              1175번 - 배달      풀이      ❌              16959번 - 체스판 여행 1      풀이      ❌              16952번 - 체스판 여행 2      풀이      ❌              12851번 - 숨바꼭질 2      풀이      ❌              9328번 - 열쇠      풀이      ❌              16920번 - 확장 게임      풀이      ❌              15653번 - 구슬 탈출 4      풀이      ❌              15558번 - 점프 게임      풀이      ❌              1385번 - 벌집      풀이      ❌      다이내믹 프로그래밍             문제      풀이      완료                  1695번 - 팰린드롬 만들기      풀이      ❌              11049번 - 행렬 곱셈 순서      풀이      ❌              12969번 - ABC      풀이      ❌              14238번 - 출근 기록      풀이      ❌              12026번 - BOJ 거리      풀이      ❌              12996번 - Acka      풀이      ❌              3012번 - 올바른 괄호 문자열      풀이      ❌              2616번 - 소형기관차      풀이      ❌              1413번 - 박스 안의 열쇠      풀이      ❌              10564번 - 팔굽혀펴기      풀이      ❌              1970번 - 건배      풀이      ❌              2163번 - 초콜릿 자르기      풀이      ❌              12872번 - 플레이리스트      풀이      ❌      시뮬레이션과 구현             문제      풀이      완료                  1913번 - 달팽이      풀이      ❌              1952번 - 달팽이2      풀이      ❌              1959번 - 달팽이3      풀이      ❌              4577번 - 소코반      풀이      ❌              2064번 - IP 주소      풀이      ❌              3107번 - IPv6      풀이      ❌              2571번 - 색종이 - 3      풀이      ❌              1089번 - 스타트링크 타워      풀이      ❌              20056번 - 마법사 상어와 파이어볼      풀이      ❌              20057번 - 마법사 상어와 토네이도      풀이      ❌              20058번 - 마법사 상어와 파이어스톰      풀이      ❌              20184번 - BOJ 대회 스코어보드      풀이      ❌              5373번 - 큐빙      풀이      ❌      ","categories": [],
        "tags": ["취준"],
        "url": "https://json9512.github.io/blog/%EC%B7%A8%EC%A4%80-%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%EC%A7%91/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -10",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   AWS로 서버를 배포 해봄이 포스트는 . . .   배포 과정을 자동화 시도Docker 이미지 배포 방법 현재까지는 Docker Hub에 이미지를 자동배포를 했었다. 하지만 전 포스트에서 AWS ECR로 이미지를 배포하는 방법을 알았으니 CI/CD에서도 AWS ECR로 자동 배포를 하려고 한다. 아마존 블로그 글을 참고를 하자. 이미 잘 설명이 돼있다. AWS 개인 정보를 secrets에 저장 시킨 뒤 ci-docker-cd.yml에서 AWS ECR로 이미지를 배포하도록 수정을 했다. AWS 배포 자동화 하루 정도의 시간을 투자한 결과, Github Actions로 AWS에 서버 배포 자동화를 성공 시켰다.  간략하게 하루 동안 삽질했던 문제점들을 나열하자면:   Github Actions workflow에서 Docker 이미지내로 환경변수 전달하기  AWS RDS와 AWS EC2 연결하기  AWS RDS와 AWS EC2내에 Docker 컨테이너와 연결하기  새로운 commit push/pr 시, ECS에 기존 인스턴스가 남아 있어서 자동 배포 되지 않는 문제해결 방법 1. Github Actions workflow에서 Docker 이미지내로 환경변수 전달하기 자동화를 많이 해본 적은 없지만 현재까지 자동화를 하면서 가장 문제를 많이 일으켰던 부분은 환경변수를 설정하는 일이다. 현재 이 포스트를 작성하는 시점, 고 코드는 AWS RDS에 연결하는 기능까지 구현하고 난 직후다. 개발을하다가 보면 여러 환경변수를 사용해서 중요한 정보들을 관리한다. 동시에 Github에 push될 때 중요한 정보가 노출이 되지 않게 해야한다. 여기서 말하는 중요한 정보란, 외부에 노출이 되었을 때 서버에 막대한 피해를 끼칠 수 있는 정보를 뜻한다. 예를 들면 관리자 비밀번호, 개인정보, 기타등등 있겠다. 수정 전 중요한 정보를 취급하는 방식은 다음과 같았다.   viper.yml 파일에 중요한 정보를 저장한다  고 서버 내에서는 viper라는 패키지를 써서 저장된 viper.yml파일에서 환경변수를 읽는다  .gitignore에 viper.yml을 작성하여 Github에 중요한 정보가 노출되지 않게 한다.이렇게 정보를 관리하게되면 기존에 만들어 놓았던 Github Actions의 Workflow가 실패한다. 정확히는 각 OS에서 서버를 실행 시킬 때 문제가 생긴다. 이유는 viper.yml이 Github에 없기 때문이다.  이 문제를 해결하려면 다음과 같은 방식들이 있다:   viper.yml파일을 Github에 올려서 Github Actions가 쓸 수 있게함  코드를 수정해서 viper.yml 의존성을 없애고, 환경변수를 Github secret에 저장함  Dockerfile이나 ci-docker-cd.yml workflow 파일에서 환경 변수를 담은 viper.yml 파일을 생성함Github Actions workflow ci-docker-cd.yml파일에서 환경변수를 Github에 노출하지 않고 Dockerfile에 전달 하려면 Dockerfile 내에서 ENV를 쓰면 된다. 하지만 나는 혹시 몰라서 ARG로 필요한 변수들을 직접 다 생성해서 Dockerfile에 전달했다. 여러가지 시행착오 끝에 현재 해결안을 살펴보면 다음과 같다 (2번 방식을 택함).   viper 대신 godotenv 패키지를 활용해서 viper.yml 파일 의존성을 없앴다  Github Secrets에 환경변수 저장  workflow yaml 파일에서 secrets.XXX로 호출  Dockerfile 을 빌드 할 때 환경변수를 ARG로 주는 방식  유닛 테스트에 환경변수가 제대로 로드되는지 확인하는 테스트를 작성했다위 수정사항을 반영하는 시작점이 되는 commit이다. 그리고 테스트 결과를 보면 Workflow가 다시 잘 작동하는 것을 볼 수 있다.  위 유닛테스트는 CI/CD 파이프라인에서 코드만 테스트하는 것이다. 실제로 Docker 이미지가 생성된 후 컨테이너에서의 테스트는 하지 않았다. 지금은 하는 방법을 모른다 예시:   Github Secrets에 환경변수 설정:  Workflow yaml에서 secrets.XXX로 호출:  Dockerfile ARG, ENV 사용해서 환경변수 사용:물론 이보다 효율적인 방법이 있을 것이다. 가령 Github Actions job 환경에 혹은 global하게 변수를 선언 하는 방법있다. 2. AWS RDS와 AWS EC2 연결하기 AWS RDS와 AWS EC2간 연결이 자동으로 될 거라고 생각했지만 아니었다. 기본적으로 AWS RDS를 만들 때 Public Access가 가능하게 만들어야 외부에서 접속이 가능하다. 이 기능을 꺼 놓으면 같은 네트워크 안에 있는 instance들만 연결 할 수 있다고 한다. 그리고 포트 설정도 유심히 봐줘야한다. Postgresql 포트의 기본 값인 5432 포트를 사용했다. 이후 AWS RDS 와 AWS EC2의 보안 그룹에서 인바운드, 아웃바운드 규칙에 5432 포트를 통과 할 수 있게 설정을 해야한다. 3. AWS RDS와 AWS EC2내에 Docker 컨테이너와 연결하기 예상했던 것처럼 AWS RDS와 EC2내 Docker간 통신이 가장 큰 문제였다. AWS RDS와 컨테이너가 성공적으로 연결이 되는 것을 확인하려면 사실 ec2 내에서 터미널로 확인해야한다. 다른 방법으로는 배포된 컨테이너가 잘 작동하는지 브라우저나 AWS 콘솔을 통해 확인하는 방법이 있다. 나는 브라우저와 콘솔을 주로 사용하다가 도저히 디버깅이 안돼서 EC2에 SSH로 연결 후 터미널로 디버깅을 했다. 알고봤더니 Dockerfile에서 5432 포트를 열어 놓지 않아서 컨테이너 내에 Go 서버가 죽어있던 것이었다. (코드가 DB connection이 안되면 로그를 내뱉으면서 죽는 방식이기 때문이다) Dockerfile에 5432 포트를 열어주고 host EC2의 포트 역시 개방해주니 바로 해결됐다. 이 문제를 해결하는데 가장 오래 걸렸다. 4. 새로운 commit push/pr 시, ECS에 기존 인스턴스가 남아 있어서 자동 배포 되지 않는 문제 Github에 새로운 PR을 진행을 해봤는데 ECS에 있던 기존 인스턴스에 새로운 작업이 실행되지 않는 문제를 발견했다. 무슨 말이냐면, CI/CD 파이프라인이 제대로 구축이 됐다면 Github에 PR을 하는 순간 AWS ECR에 새로운 이미지가 배포되고 그 배포된 이미지를 사용해서 새로운 컨테이너가 EC2안에 구축이 돼야한다. 유저 입장에서는 Go 서버를 브라우저로 방문했을 때, 업데이트 된 서버가 응답을 해야하는 것이었다. 하지만 위 과정이 되지 않았다. 이 부분도 몇번의 구글링 끝에 ECS의 minimum healthy percent와 maximum percent 설정을 손보면 되는 것이었다. 내가 원하는 것은 ECS가 1개의 인스턴스를 구동하며, 새 이미지가 배포되면 기존 컨테이너를 없애고 새 컨테이너를 만드는 것이었다. 이 스택오버플로우 글을 참고해서 1개의 인스턴스로 롤링 배포를 원활하게 작동하게끔 구축했다. 마무리 정리를 하자면:   AWS ECR로 이미지 배포, AWS ECS로 EC2 구동 후 컨테이너 배포까지 Github Actions로 자동화 시켰다물론 지금 설정한 Workflow는 추후에 바뀔 가능성이 높다. 하지만 당분간은 개발에 집중해도 될 것 같다. 다음 포스트부터는 RESTful API를 만드는 과정에 대해 알아보자. 여담으로 개발자 친구에게 코드리뷰를 부탁했다. dojinkimm 👍👍 ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-10/"
      },{
        "title": "Min num of x required for y",
        "excerpt":"출처: GeeksforGeeks   y 라는 변수가 x라는 변수에 의존할 때, x가 필요한 최소 개수를 구하는 알고리즘  그리디 알고리즘예를 들면, 기차가 y 이고 x가 기차가 정차를 하는 플랫폼이라고 가정하자. 이때 기차가 플랫폼에 도착하는 시간 n과 플랫폼에서 기차가 출발하는 시간 m인 n, m 배열이 주어질 때, 최소한의 플랫폼 개수를 구하는 것이 목적이다. # 기차는 y, 플랫폼은 x# n은 기차들이 x에 들어오는 시간이 담긴 배열# m은 기차들이 x에서 출발하는 시간이 담긴 배열n = [\"9:00\", \"9:40\", \"9:50\", \"11:00\", \"15:00\", \"18:00\"]m = [\"9:10\", \"12:00\", \"11:20\", \"11:30\", \"19:00\", \"20:00\"]# 특정 시간에 최대 몇 대의 기차 y가 x에 들어와야 하는지를 계산하면# x가 최소한 몇 개가 필요한지가 나온다방법   주어진 n, m 배열을 정렬한다  플랫폼 개수를 세는 plat을 선언한 뒤 포인터 i, j를 선언하고 i&lt;n and j&lt;n 일때 룹을 돈다  n[i] 와 m[j]을 비교해서          n[i] &lt;= m[j]라면 plat의 개수를 1 더하고 i를 1 더해준다      반대라면 plat을 1 빼주고 j를 1 더해준다        룹이 종료되면 plat이 답이다Python def find_min_platform(arr, dep):    N = len(arr)    # 도착 시간 arr와 출발 시간 dep을 정렬한다    arr.sort()    dep.sort()    # counter들을 선언한다    plat = 1    i = 1    j = 0    min_num_of_plat = 1    # Loop 을 돈다    while i &lt; N and j &lt; N:        # 도착 시간이 출발 시간보다 낮거나 같으면        # 출발 하는 기차와 도착한 기차가 정차할        # 플랫폼의 개수가 늘어난다        if arr[i] &lt;= dep[j]:            i += 1            plat += 1        elif arr[i] &gt; dep[j]:            # 반대는 줄어든다            j += 1            plat -= 1        # min_num_of_plat의 값을 갱신해준다        if plat &gt; min_num_of_plat:            min_num_of_plat = plat    return min_num_of_platif __name__ == \"__main__\":    arrival = [900, 940, 950, 1100, 1500, 1800]    departure = [910, 1200, 1120, 1130, 1900, 2000]    print(        \"Min number of platform required and any given time is:\",        find_min_platform(arrival, departure)        )    # Min number of platform required and any given time is: 3기차와 플랫폼으로 예시를 들었지만 아무거나 가능하다. 렌터카 수, 식당 테이블 수, 최소 가동 돼야 할 기계/프로그램 등등 시간 복잡도는:   O(n) 만큼 loop이 돌고, O(n log n)으로 Sort을 한다  전체 시간 복잡도는 O(n log n)Space complexity는 O(1)이다 같은 문제를 O(n) 시간 복잡도와 O(n) 공간 복잡도로 풀 수 있다 방법   출발과 도착시간의 일시가 같다면, O(n)으로 계산이 가능하다  각 분 마다 필요한 플랫폼의 개수를 계속 세면 된다def find_min_platform(arr, dep):    N = len(arr)    arr.sort()    dep.sort()    # 각 분마다 platform의 개수를 세는 배열    platforms = [0] * 2361 # 2361은 시간:분 최대치다    required_plat = 1    for i in range(N):        # 기차가 들어오면 플랫폼이 필요하니 1을 더 하자        platforms[arr[i]] += 1        # 기차가 나가면 플랫폼에서 제외하자        platforms[dep[i]+1] -= 1        # 하루에 최대 플랫폼 개수가 몇 인지 세자    for i in range(1, len(platforms)):        # 누적 합계를 계속 세자        platforms[i] += platforms[i-1]        required_plat = max(required_plat, platforms[i])        return required_platif __name__ == \"__main__\":    arrival = [900, 940, 950, 1100, 1500, 1800]    departure = [910, 1200, 1120, 1130, 1900, 2000]    print(        \"Min number of platform required and any given time is:\",        find_min_platform(arrival, departure)        )    # Min number of platform required and any given time is: 3","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Min-num-of-x-required-for-y/"
      },{
        "title": "Dynamic Programming",
        "excerpt":"출처: GeeksforGeeks 다이나믹 프로그래밍에 대해 알아보자 다이나믹 프로그래밍이란 복잡한 문제를 더 작은 문제로 쪼개서 최적의 해를 구하는 방법이다. 작은 문제들의 답을 저장하여 재계산을 하지 않는 것이 중요하다. 그리디 알고리즘과 다이나믹 프로그래밍의 다른 점? 그리디 알고리즘은 작은 문제에서 최적의 답안을 찾아서 복잡한 문제를 다 풀 때까지 반복하는 것이다. 그래서 작은 문제에서 최적의 답을 찾았다면 다른 선택사항은 고려하지 않는다. 복잡한 문제를 전체적으로 봤을 때 최적의 답이 안 나올 수 있다. 반면 다이나믹 프로그래밍은 작은 문제를 해결 할 때 이전에 풀었던 작은 문제의 답을 불러올 수 있기 때문에 다른 선택사항들도 고려한다. 즉 다이나믹 프로그래밍으로 문제를 풀게 되면 복잡한 문제를 전체적으로 보았을 때 가장 최적의 답안이 나온다. 예를 들면, A에서 B로가는 가장 최단 거리를 계산하는 문제라고 가정해보자. 그래프는 다음과 같은 형식이다 # A --2- C ---# |           1# 1           |# |           v# D --- 5 --- B여기서 그리디 알고리즘을 사용하면, 현재 위치에서 가장 작은 거리 값을 반복해서 고르기 때문에 최단 거리는 A-&gt;D (1) + D-&gt;B (5) = 6이 된다. 하지만 다이나믹 프로그래밍을 사용하면 A-&gt;C (2) + C-&gt;B (1) = 3이 되면서 원했던 최단 거리를 구할 수 있게 된다. 언제 다이나믹 프로그래밍을 쓸 수 있나? 주어진 문제에 아래의 3가지 특징이 있다면 다이나믹 프로그래밍으로 풀 수 있다.   Overlapping sub-problems: 동일한 작은 문제를 지속적으로 풀어야 하는 상황이 있을 때  Optimal substructure: 문제의 최적의 해결법에 작은 문제의 최적의 해결법이 포함이 될 때  Simple sub problems: 주어진 복잡한 문제를 같은 형태의 더 작은 문제로 나눌 수 있어야 한다Memoization 과 Tabulation Memoization을 사용하면 Top-down 방식으로 다이내믹 프로그래밍을 구현할 수 있다. 방법은 다음과 같다.   작은 문제들의 해결안을 담을 lookup table을 만든다  작은 문제들을 해결 할 때 마다,          현재 작은 문제가 lookup table에 없으면                  작은 문제를 해결한 뒤 lookup table에 저장한다                    있으면 해결 값을 불러와서 사용한다      Fibonacci 수열을 Memoization을 활용해서 사용하면 다음과 같다 def fibo(n, lookup):    if n == 0 or n == 1:        lookup[n] = n        # lookup table에 계산된 값이 없으면, 현재 문제를     # 계산해서 넣어 준다    if lookup[n] is None:        lookup[n] = fibo(n-1, lookup) + fibo(n-2, lookup)        return lookup[n]if __name__ == \"__main__\":    n = 34    # lookup table 선언    lookup = [None] * 100    print(fibo(n, lookup))Tabulation 방식을 사용하면 Bottom-Up 방식으로 다이내믹 프로그래밍을 구현 할 수 있다. Memoization과 다른 점은, Tabulation 방식은 답에 도달 할 때까지 계속해서 sub-problem을 구하는 것이다.답에 도달 했다면, table에 마지막 값이 답이 되는 것이다. 같은 Fibonacci 수열 문제를 Tabulation으로 구현하면 다음과 같다. def fibo(n):    # table 선언    f = [0] * (n+1)    # 피보나치 수열의 base case 작성    f[1] = 1    # 답에 도달 할 때까지 계속해서 문제를 푼다    for i in range(2, n+1):        f[i] = f[i-1] + f[i-2]            return f[n]if __name__ == \"__main__\":    n = 34    print(fibo(n))Memoization과 Tabulation중 어떤 것을 써야하나?   Memoization은 재귀적 호출을 기반으로 한다  Tabulation은 Iterative하게 문제를 푼다  Memoization은 굳이 모든 sub problem의 해결안을 구하지 않는다. 필요한 부분만 구하기 떄문이다  Tabulation은 모든 sub problem의 해결안을 구한다  Memoization의 재귀 호출은 컴퓨터가 실제로 스택내에 새로운 메모리 위치에 함수와 인자 값을 저장하기 때문에 같은 조건의 iterative 한 방식보다 더 느릴 수 있다알아서 상황에 맞게 쓰도록 하자. ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dynamic-Programming/"
      },{
        "title": "깊이 넓이 우선 탐색",
        "excerpt":"출처: GeeksforGeeks, 잔재미코딩 그래프 알고리즘의 기초 BFS, DFS에 대해 알아보자 BFS, DFS visualization   BFS Breadth first search   너비 우선 탐색  그래프에서 노드를 탐색할 때, 옆에 연결 된 노드들을 우선적으로 탐색하는 알고리즘  Time complexity: O(V+E) V가 노드, E가 edge일때  queue와 visited 배열로 탐색해야 할 노드들과, 이미 탐색한 노드들에 대한 기록을 저장하면서 탐색을 한다data = [    # 시작, 도착    ('a', 'b'),    ('a', 'c'),    ('b', 'a'),    ('b', 'd'),    ('c', 'a'),    ('c', 'g'),    ('c', 'h'),    ('c', 'i'),    ('d', 'b'),    ('d', 'e'),    ('d', 'f'),    ('e', 'd'),    ('f', 'd'),    ('g', 'c'),    ('h','c'),    ('i', 'c'),    ('i', 'j'),    ('j', 'i')]graph = dict()# 그래프 생성for start, end in data:    if start in graph:        graph[start].append(end)    else:        graph[start] = [end]위를 그림으로 표현하면 다음과 같다.  def bfs(graph, start):    # 탐색해야 할 노드와 이미 탐색한 노드의 정보를    # 저장 하는 배열을 선언하자    visited = []    queue = [start]    # 탐색해야 할 노드들이 있다면 반복하자    while queue:        # 큐에서 제일 앞쪽 노드를 꺼낸다         node = queue.pop(0)        # 노드가 이미 봤던 것이 아니라면        if node not in visited:            # 탐색한 노드 배열에 담자            visited.append(node)            # 이 노드와 연결 된 다른 노드를            # 탐색 해야 할 큐에 담자            queue.extend(graph[node])    # 탐색한 노드 정보를 담고 있는 배열이 곧    # 탐색한 순서가 된다    return visitedprint(bfs(graph, 'a'))# ['a', 'b', 'c', 'd', 'g', 'h', 'i', 'e', 'f', 'j']BFS 탐색을 그림으로 표현하면 다음과 같다. 시작점은 ‘a’다  DFS Depth first search   깊이 우선 탐색  그래프에서 노드를 탐색할 때, 자식 노드들을 우선적으로 탐색하는 알고리즘  Time complexity: O(V+E) V가 노드, E가 edge일때  queue와 visited 배열로 탐색해야 할 노드들과, 이미 탐색한 노드들에 대한 기록을 저장하면서 탐색을 한다# 위와 같은 그래프를 사용했을 때def dfs(graph, start):    # 탐색해야 할 노드와 이미 탐색한 노드의 정보를    # 저장 하는 배열을 선언하자    visited = []    queue = [start]    # 탐색해야 할 노드들이 있다면 반복하자    while queue:        # 큐에서 제일 뒤쪽 노드를 꺼낸다         node = queue.pop()        # 노드가 이미 봤던 것이 아니라면        if node not in visited:            # 탐색한 노드 배열에 담자            visited.append(node)            # 이 노드와 연결 된 다른 노드를            # 탐색 해야 할 큐에 담자            queue.extend(graph[node])    # 탐색한 노드 정보를 담고 있는 배열이 곧    # 탐색한 순서가 된다    return visitedprint(dfs(graph, 'a'))# ['a', 'c', 'i', 'j', 'h', 'g', 'b', 'd', 'f', 'e']보다 시피 다른 것은 queue에서 어떤 노드를 먼저 꺼내냐 차이다. DFS를 그림으로 보면 다음과 같다.  ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B9%8A%EC%9D%B4-%EB%84%93%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"
      },{
        "title": "백준 10430번",
        "excerpt":"주어진 설명을 따라서 출력하면 된다 import sysdef solution():    # 받을 값을 integer 타입의 a, b, c로 선언한다    a, b, c = map(int, sys.stdin.readline().strip().split(\" \"))    print((a+b)%c)    print(((a%c) + (b%c))%c)    print((a*b)%c)    print(((a%c) * (b%c))%c)    if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10430%EB%B2%88/"
      },{
        "title": "백준 4375번",
        "excerpt":"처음에는 문제가 이해가 안됐다. 풀이를 하자면,   주어진 n 의 배수 중 1로 이루어진 가장 작은 수의 자리수  예: n = 3 이면 3의 배수를 계속 찾다가 나오는 111이 가장 작은 수다  111의 자리수는 3이니까 3을 출력해결 방법은 이 분 것을 참고했다.간단하게 설명하면:   num 1, 11, 111, 1111 식으로 값이 바뀌는 변수를 선언하고  counter로 num에 자리수가 하나씩 더해질 때를 센다  반복문을 돌면서 num에 자리수를 더해주고  새로운 num이 주어진 n과 나뉘어 떨어지면 num은 n의 배수니까 답을 출력한다def solution():    # 입력 테스트 케이스가 안 주어지기 때문에 무한 반복해야 한다    while True:        # 배수: multiple        # 3 = 111 이니까 3이 출력        try:            input_n = int(input())        except EOFError:            break        if input_n == 1:            print(1)            continue        # 자리수 1을 계속 더해줄 num를 선언        num = 1        counter = 1        while True:            # 1의 자리수를 더해준다            num = num*10 + 1            counter += 1            # 나누어 떨어지면 출력            if (num%input_n) == 0:                print(counter)                breakif __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-4375%EB%B2%88/"
      },{
        "title": "TCP UDP",
        "excerpt":"출처: 위키피디아, guru99, tutorialspoint TCP UDP에 대해 알아보자. TCP - Transmission control protocol 간략한 설명:   connection oriented (연결지향) 프로토콜이다. 네트워크에서 프로토콜이란 정해진 통신 방식을 의미한다  데이터가 전송되기전 client와 server간 연결이 됨  server는 client의 request를 듣고 있어야 한다 (passive open)  client는 3-way-handshake (active open)로 server와 연결을 한다  연결된 client와 server는 서로 데이터를 주고 받을 수 있다  연속성보다 신뢰성이 중요할 때 사용한다. ex. 파일 전송  패킷 하나의 최대 사이즈는 64KB (65535 bytes)지만 여러개의 패킷이 연관될 수 있기 때문에 데이터의 총량은 무제한이다.특징:   3 way handshake  packet retransmission (패킷 재전송) mechanism  error detection mechanism  위 특징들이 신뢰성을 더해준다  위 특징들 때문에 상대적으로 느리다네트워크 기능   Transport layer는 application과 Internet protocol 간 통신을 이어준다. Application 레벨에서는 다른 host와 통신하는데 어떤 네트워크 기능들을 사용해야 하는지 알 필요가 없다. Transport layer에서 네트워크 통신에 필요한 것들을 abstract 해준다.이때 traffic load balancing, network congestion 등 여러가지 이유로 패킷이 유실, 중복, 늦게 도착 할 수 있는데 TCP는 이런 문제점들을 분별할 수 있고 패킷이 정상적으로 모두 도착하지 않으면 다시 전송 (retransmission)을 해달라고 요청한다. 또한 TCP는 무분별하게 들어온 패킷을 재정렬한다. 만약 끝까지 패킷을 다 받지 못하며, 보낸 host에게 전송 실패를 알려준다. 모든 패킷을 성공적으로 재정렬 시키면 application에게 보내준다. 통상적으로 TCP는 Web, email, FTP 등에서 많이 쓰인다. TCP는 앞서 말한 패킷 재전송 요청을 기다리기 때문에 상대적으로 더 많은 소요시간이 필요하다. 하지만 TCP는 모든 패킷을 보냈던 순서대로 온전히 받아낼 수 있기 때문에 신뢰성이 더 높은 통신 방식이다. TCP는 positive acknowledgement with retransmission이라는 방식으로 모든 패킷을 받을 수 있다. 그 과정은 다음과 같다.   받는 쪽은 받았다는 acknowledgement 메세지를 보낸 쪽에 전달 해준다  보낸 쪽은 패킷을 보낼 때 보낸 패킷이 언제 전송이 되었는지 기록한다. 만약 정해진 시간 내에 acknowledgement 메세지를 받지 못하면, 패킷을 재차 전송한다. 이는 패킷 유실이나 패킷 손실 또한 방지할 수 있는 메커니즘이다IP layer가 실질적인 패킷 전송을 담당하지만 TCP는 segment 정보를 가지고 있게된다. segment란 보낼 데이터를 나눈 데이터 유닛을 말한다. 데이터를 더 작게 나누는 이유는 라우팅을 더 효과적으로 하기 위함이다. TCP segment 구조 Transport layer에서 데이터를 받을 때, TCP는 받은 데이터를 나눈 후, 각 segment에 TCP header를 붙인다. 이후 이 TCP segment는 IP layer에서 IP header를 더한 후 패킷으로 전송이 되게 된다.    Source port (16 bits): 보내는 host의 port  Destination port (16 bits): 받는 host의 port  Sequence number (32 bits):          두 가지 특성이 있다.                  SYN flag가 켜져 있으면 (1 이면), 이 sequence number는 첫 번째 sequence number다.          SYN flag가 꺼져 있으면 (0 이면), 이 sequence number는 현재 세션의 누적 sequence number 데이터다                      Acknowledgement Number (32 bits):          만약 ACK flag가 켜져 있으면 이 값은 ACK를 보낸 쪽이 받아야할 sequence number다. 이는 곧 그 전의 데이터를 다 받았다는 의미를 가지고 있다.        Data offset (4 bits):          TCP header의 크기를 32 bit words 로 지정한다. 최소 값은 5 words고 최대 값은 15 words다.        Reserved (3 bits): 추후에 사용하기 위해 비워뒀다. 3 bit 모두 0이어야 한다.  Flags (9 bits): 1이 켜져있음, 0 이 꺼져 있음          NS: ECN-nonce - concealment protection      CWR: CWR flag는 ECE flag가 설정된 TCP segment를 받았을 때, network congestion control에 대응했다고 보낸 쪽에 알리기 위해 켠다.      ECE: ECN-Echo는 SYN flag에 따라서 2가지 기능이 있다.                  SYN이 1이면, TCP peer가 ECN을 사용할 수 있다를 뜻한다          SYN이 0이면, 데이터 통신 중 IP header에 Congestion experience flag (ECN=11)가 켜진 packet을 받게되면, 보낸 쪽에게 network congestion이 일어났거나 일어날 것임을 뜻한다                    URG: Urgent Pointer 필드가 중요함을 뜻한다      ACK: Acknowledgement 필드가 중요함을 뜻한다. 제일 첫 번째 sequence number를 가진 패킷 전송 이후에 통신되는 모든 패킷에 ACK 값이 켜져 있어야 한다      PSH: 받는 쪽 application으로 데이터 버퍼를 push 하라는 뜻이다      RST: 연결을 reset하라는 뜻이다      SYN: Synchronize sequence numbers. 통신에서 양쪽이 보내는 제일 첫번째 패킷에만 이 값이 켜져 있어야한다. 다른 flag들이 이 값에 영향을 받는다      FIN: 보내는 쪽이 이 패킷이 마지막임을 뜻할때 쓴다        Window size (16 bits)          receive window의 크기. 보낸 사람이 받을 수 있는 window size unit을 뜻한다        Checksum (16 bits):          TCP header, payload, IP pseudo-header의 error checking을 위해 쓰인다. pseudo-header에는 source IP address, destination IP address, protocol number (TCP=6), TCP header와 payload의 길이 정보가 있다        Urgent Pointer (16 bits):          만약 URG flag가 켜져 있으면, 이 Urgent pointer는 sequence number에서의 offset이며 가장 종단에 있는 urgent data byte를 뜻한다        Options (0-320 bits, in units of 32 bits):          Options의 길이은 data offset의 값에 따라 달라진다. 총 3가지 필드가 있다.                  Option-Kind (1 byte): 필수          Option-Length (1 byte): 1번에 따라 선택적          Option-data (variable): 1번에 따라 선택적                      Padding: TCP header와 data간에 32 bit 단위로 경계를 구분하기 위해 0으로 이루어진 padding을 넣을 때도 있다.프로토콜 시행방식 TCP 프로토콜 시행 방식은 3 단계로 나뉘어진다.   Connection Establishment - 3 way handshake로 데이터를 전송하기전 서버, 클라이언트간 연결을 성립하는 단계  Data transfer - 연결 성립 후 데이터를 전송하는 단계  Connection Termination - 모든 데이터 전송이 끝난 후 연결을 종결시키는 단계TCP 연결은 Internet socket에 의해 관리되고 연결 동안에 여러 상태를 가지게 된다.             상태      Endpoint      설명                  LISTEN      Server      아무 TCP endpoint로 부터의 연결 요청을 기다린다              SYN-SENT      Client      연결 요청을 보낸 후 돌아오는 요청을 기다린다              SYN-RECEIVED      Server      연결 요청을 받고 보내 쪽으로 연결 요청을 보낸 후 acknowledgement (승인)을 기다린다              ESTABLISHED      Server and Client      연결 된 상태. 받은 데이터를 사용자에게 보내 줄 수 있다. 데이터 전송 단계의 기본 상태              FIN-WAIT-1      Server and Client      Remote TCP로부터 연결 종결 요청이나 이미 보낸 연결 종결 승인을 기다리는 상태              FIN-WAIT-2      Server and Client      Remote TCP로부터 연결 종결 요청을 기다리는 상태              CLOSE-WAIT      Server and Client      로컬 사용자로부터 연결 종결 요청을 기다리는 상태              CLOSING      Server and Client      Remote TCP로부터 연결 종결 요청에 대한 acknowledgement (승인)을 기다리는 상태              LAST-ACK      Server and Client      Remote TCP로부터 연결 종결 승인을 기다리는 상태              TIME-WAIT      Server or Client      Remote TCP가 연결 종결 승인을 받을 때까지 어느정도의 시간을 기다리는 상태              CLOSED      Server and Client      아무 상태도 아님      Connection Establishment 단계 연결을 하기 위해서 Server와 Client가 TCP 3 way handshake 과정을 거쳐야 한다. 먼저 Server는 특정 포트에 TCP 연결을 듣고 있어야한다 (Passive Open). Passive open이 성립이되면 Client에서 (Active Open) 3 way handshake를 요청 할 수 있다.   SYN - Client가 서버로 SYN flag가 1이고 아무 sequence number A를 가진 패킷을 보낸다  SYN-ACK - Server는 SYN과 ACK flag가 1이고 acknowledgement number가 받은 sequence number A에 1을 더한 숫자와 아무 sequence number B를 가진 패킷을 Client에게 보낸다  ACK - Client가 ACK flag가 1이고 받은 acknowledgement number A + 1를  sequence number로 사용하고 acknowledgement number 를 받은 sequence number B에 1을 더한 숫자를 사용해 마지막 패킷을 Server로 보낸다이 과정을 거치면 Client와 Server 모두 ACK (승인)을 받은 상태가 되고 양 방향 통신이 성립된다. Connection Termination 연결 종결은 기본적으로 4 way handshake 방식이다. 연결을 끝내고자 하는 기기에서 FIN 패킷을 보내고 반대 쪽기기가 ACK 패킷으로 답을 하면 어느정도의 시간이 흐른 뒤 연결이 종결된다. 이 부분을 3 way handshake로 단축시키는 방법이 있는데, 처음 FIN 패킷을 받은 쪽이 ACK 와 FIN을 동시에 보내면 된다.   연결을 끝내고자 하는 쪽 (A)에서 FIN 패킷을 보낸다  FIN 패킷을 받은 쪽 (B)이 ACK와 FIN 패킷을 보낸다  A에서 ACK로 승인한다 리소스 사용 대부분 특정 TCP 세션을 프로세스에 매핑한 테이블을 구현한다. TCP 패킷에는 session identifier가 없기 때문에 양 끝단 (클라이언트와 서버)은 클라이언트의 주소와 포트로 세션을 분별한다. TCP 패킷이 들어올 때마다 session: process 매핑 된 테이블에서 session을 찾아서 process에 정보를 전달하는 방식이다. 이 테이블에 들어있는 하나의 entry는 Transmission Control Block (TCB)이다. TCB에는 양 끝단의 IP와 포트, 연결 상태, 교환되는 데이터 정보, 보내고 받는 데이터 버퍼가 하나의 정보로 저장되어있다. 서버 쪽에서 세션을 유지 할 수 있는 최대치는 서버가 허용하는 메모리 용량만큼이다. 하지만 클라이언트는 TCP 연결을 하려면 특정 포트에서 연결을 3 way handshake로 열고 연결이 종결 될 때까지 해당 포트에서 모든 것을 관리한다. 이는 곧 클라이언트 컴퓨터에서 TCP 연결 개수를 관리할 수 있게 해준다. 만약 특정 앱이 TCP 연결을 제대로 종결하지 못하면, 이후 다른 앱에서 TCP 연결이 불가능 할수도 있다. (포트가 없기 때문에) 또한 양끝단은 식별되지 않은 패킷과 받았지만 읽지 않은 패킷을 위한 공간도 확보해야한다. 데이터 전송방식 특징   데이터 정렬: 받는 쪽이 받은 segment들을 sequence number에 맞게 정렬을 시켜서 보냈을 때의 데이터 순서를 맞춘다  손실 패킷 재전송: 받았다는 승인이 돌아오지 않는 패킷은 재전송을 한다  error-free 전송  flow 컨트롤: 안전한 데이터 전송을 위해 보내는 쪽의 전송 속도/양을 제한하는 방식. 받는 쪽에서 보내는 쪽에게 패킷을 얼마나 더 받을 수 있는지 알려준다. 만약 받은 쪽의 버퍼가 가득 차면, 다음 acknowledgement 값은 0이며 데이터 전송을 잠시 멈추라는 신호이기도 하다. 이후 버퍼에 있는 데이터를 다 처리한 후에 다시 데이터를 받는 방식이다.  congestion control (혼잡제어)TCP 취약점   Denial of Service (DOS): 서버의 자원을 쓰게 하는 방식의 공격. 임의의 IP에서 SYN과 ACK 패킷을 지속적으로 통신하는 방식. SYN Flood 공격이라고도 한다.  Connection Hijacking: TCP session에 eavesdrop 및 패킷을 redirect 할 수 있는 공격자가 sequence number를 알아내서 malformed 패킷을 보내주는 방식. 이때 패킷을 승인하게 되면 기존에 연결 요청 했던 호스트가 아닌 공격자와 연결을 이어간다  TCP veto: TCP session에서 패킷의 sequence number와 다음 패킷 사이즈를 알 수 있다면 공격자가 malformed 패킷을 보낼 수 있다. 공격자는 sequence number를 보고 다음에 호스트에 와야할 패킷을 미리 보낼 수 있다. 이때 패킷의 payload에는 악성 코드를 집어 넣을 수 있다. 호스트는 이 패킷을 문제 없이 받게 되고 이후 보내는 호스트가 제대로 된 패킷을 보내도 받는 호스트에서 같은 sequence number를 가진 패킷이 있기 때문에 제대로 된 패킷을 드랍한다. Connection Hijacking과 다른 점은, Host간 통신이 끊기지 않는다는 것이다. 공격자는 TCP 통신에 대한 권한은 제한되지만 malformed 패킷이 잘 들키지 않고 공격 대상에게 들어간다는 것이 중요하다. 또한 보내는 Host는 이 공격을 절대 알 수가 없다.UDP - User datagram protocol 간략한 설명:   통신 채널을 위해 사전에 호스트간 통신이 필요없다. (핸드쉐이크)  비연결형 프로토콜  데이터그램 이라는 유닛을 사용한다  checksum을 활용해 최소한의 data integrity 만 보장한다  전송, 정렬을 보장하지 한고 중복방지 매커니즘도 없다  하나의 UDP 패킷은 다른 UDP 패킷과 연관성이 없다  하나의 패킷이 독립적이기 때문에 최대 데이터크기는 64KB (65535 bytes)다  TCP 보다 신뢰성은 떨어진다  TCP 보다 빠르다  신뢰성 보다 연속성이 중요할 때 사용된다. ex. VOIP, video stream특징 / 사용처   Transaction-oriented이라서 query-response protocol에 적합하다 ex. Domain Name System 이나 Network Time Protocol  datagram을 사용해서 다른 프로토콜을 모델링 할때 쓰인다. ex. IP tunneling, remote procedure call, 이나 network file system  간단해서 bootstraping이나 완전한 프로토콜이 존재하지 않는 다른 작업에 쓰인다. ex. DHCP 혹은 Trivial File Transfer Protocol  stateless해서 다수의 client와 통신하는데 적합하다. ex streaming media in IPTV  재전송 딜레이가 없기에 real time 앱에 적합하다. ex. VOIP, online game, Real Time Streaming Protocol  multicast가 가능하기에 네트워크내에 통신 가능한 디바이스를 찾거나 정보를 공유하는 프로토콜에 적합하다. ex. Precision Time Protocol, Routing Information ProtocolUDP Datagram Structure  UDP 데이터그램은 header 부분과 data 부분으로 구성된다. header는 4개의 필드로 구성되고 각 필드의 길이는 2 bytes다 (16 bits). 헤더 다음에는 data section이 위치한다. source port number - 패킷을 보내는 기기의 port다. 만약 패킷을 받은 기기가 응답을 보내야 한다면 이 포트로 가게된다. 사용되지 않을 시에는 0이어야 하고 클라이언트가 사용하면 임의 포트일 가능성이 높다. 서버가 사용한다면 이미 잘 알려진 UDP port 숫자를 사용할 것이다. destination port number - 받는 기기의 port다. length - udp header + data section의 길이를 명시한다. 최소 길이는 헤더만 존재하는 값이기 때문에 8 bytes다. 이론적으로 최대 크기는 65535 bytes (헤더 8 bytes + data 65527 bytes)로 data section에 65227 bytes를 쓸 수 있을 것 같지만 IPv4 protocol에 의한 실제 data section의 최대 크기는 65507 bytes(65535 - 헤더 8 bytes - IPv4 header 20 bytes)다. checksum - header 와 data section에 데이터의 에러 확인용으로 사용된다. IPv4에서는 선택적이고 IPv6에서는 필수적이다. 사용되지 않으면 16 bit 모두 0의 값을 가진다 TCP UDP 차이점 TCP:   연결 지향 방식  end-to-end 통신 성립 이전에 handshake가 필요하다 (3-way-handshake 참고)  통신이 성립되면 양방향으로 데이터 전송이 가능하다  신뢰성:          메세지 재전송      메세지 acknowledgement      시간초과 기능        정렬:          보낸 데이터 순서 그대로 받을 수 있다      각 패킷에 순서를 표시하는 데이터가 있다      순서가 섞이면 다시 정렬하는 메커니즘이 있다        overweight:          통신을 성립하기전에 적어도 3개의 패킷을 먼저 보내야 한다      신뢰성과 congestion control(혼잡제어)을 할 수 있다        streaming:          데이터는 bytes 스트림으로 읽히고 데이터 사이에 경계가 없다      UDP:   비연결 지향 방식  상대방이 받을 준비가 되어 있지 않아도 패킷을 전송할 수 있다  신뢰성이 떨어진다:          패킷이 잘 도착했는지 검증하는 메커니즘이 없다        정렬 없음:          보낸 순서대로 패킷이 도착하지 않을 수 있다        Lightweight:          메세지 순서를 정렬하거나 손실된 패킷을 재전송하는 메커니즘이 없어서 더 가볍다        Datagrams:          각 패킷은 독립적이고 도착시 checksum을 활용한 최소한의 검증만 거친다. 각 패킷은 구분이 확실하다        혼잡 제어 없음  Broadcast:          같은 네트워크내 모든 기기에 broadcast 할 수 있다        multicast:          하나의 데이터그램 패킷이 구독된 모든 기기에 multicast돼서 전송 될 수 있다      ","categories": [],
        "tags": ["Network"],
        "url": "https://json9512.github.io/blog/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-UDP/"
      },{
        "title": "백준 1037번",
        "excerpt":"일단 약수가 뭔지 몰랐다. 한국어로 수학 용어를 모르는게 문제를 더 어렵게 만든다. 처음에는 문제의 진짜 약수는 1과 구해야 하는 숫자 N 이면 안 된다에만 너무 집중해서 실패했다. 이후 구글링을 통해 알아본 결과 주어지는 값은 그냥 다 진짜 약수 라서 굳이 진짜 약수인지 확인 할 필요가 없었다. 문제를 좀 더 제대로 보는 것이 중요한 것 같다. import sysdef solution():    tc = int(sys.stdin.readline().strip())    real_n = list(map(int, sys.stdin.readline().strip().split(\" \")))        # 모든 것이 진짜 약수다    # 문제를 좀 더 다방면으로 생각하자    # 여기서 답을 구하는 방법은, 가장 작은 약수 * 가장 큰 약수다    real_n.sort()    print(real_n[0]*real_n[-1])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1037%EB%B2%88/"
      },{
        "title": "백준 17427번",
        "excerpt":"수학 쪽 문제는 너무 어렵다. 일단 문제 정의를 따라서 1부터 주어지는 N까지 모든 수의 약수를 구하고 그 합을 더하는 알고리즘을 짰다.처음에는 O(n^2) 이었다가 후에 O(n sqrt(n))으로 짰는데 계속 시간 초과가 떴다. 몇 분의 구글링 끝에 문제를 잘 설명해 놓으신 이 글 을 보고 풀었다. 수학이 중요하다. import sysimport mathdef solution():    n = int(sys.stdin.readline().strip())    gx = 0    # 약수(divisor)의 합을 구하는 것이 아닌    # n 이하의 i의 배수(multiple)를 구해 i를 곱한 값을 누적한다    # n 이하의 i의 배수는 floor(n/i) 다    for i in range(1, n+1):        gx += math.floor(n/i) * i    print(gx)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-17427%EB%B2%88/"
      },{
        "title": "백준 2309번",
        "excerpt":"쓸데없이 문제를 복잡하게 생각하는 경향이있다. 결국 내가 못 풀고 구글을 하고 나서야 풀었다. 이 포스트를 참고했다. def solution():    heights = []    for _ in range(9):        height = int(sys.stdin.readline())        heights.append(height)    heights.sort()    height_total = sum(heights)    for i in range(len(heights)):        for j in range(i+1, len(heights)):            if height_total-heights[i]-heights[j] == 100:                for k in range(len(heights)):                    if k!=i and k!=j:                        print(heights[k])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-2309%EB%B2%88/"
      },{
        "title": "백준 2609번",
        "excerpt":"최소 공배수 (LCM) 과 최대 공약수 (GCD)를 구하는 문제다 import sysdef gcd(a, b):    while b:        a, b = b, a % b        return adef lcm(a, b):    return int(abs(a*b) / gcd(a, b))def solution():    num_a, num_b = map(int, sys.stdin.readline().split(\" \"))    print(gcd(num_a, num_b))    print(lcm(num_a, num_b))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-2609%EB%B2%88/"
      },{
        "title": "백준 3085번",
        "excerpt":"처음에는 각 사탕 마다 상하좌우를 비교해야 되는 줄 알고 한 번에 짜려다 보니 실패했다. 결국 정해놓은 시간안에 못 풀어서 구글링을 했는데 처음 생각했던 접근 방법과 비슷했지만 결과적으로 나는 구현에 실패했다. 문제를 더 많이 풀어보자. 참고한 블로그다. import sysdef edible_candies(matrix):    counter = 0    for i in range(len(matrix)):        row_counter = 1        col_counter = 1        for j in range(len(matrix)-1):            # 양옆            if matrix[i][j] == matrix[i][j+1]:                row_counter += 1            else:                counter = max(counter, row_counter)                row_counter = 1            # 위 아래            if matrix[j][i] == matrix[j+1][i]:                col_counter += 1            else:                counter = max(counter, col_counter)                col_counter = 1        counter = max(counter, col_counter, row_counter)    return counterdef solution():    # 바꾼 사탕을 굳이 먹어야하지는 않다    tc = int(sys.stdin.readline())    matrix = [list(map(str, sys.stdin.readline().strip())) for _ in range(tc)]    result = 0    for i in range(len(matrix)):        for j in range(len(matrix)-1):            # 양옆            if matrix[i][j] != matrix[i][j+1]:                matrix[i][j], matrix[i][j+1] = matrix[i][j+1], matrix[i][j]                result = max(result, edible_candies(matrix))                matrix[i][j], matrix[i][j+1] = matrix[i][j+1], matrix[i][j]            # 위 아래            if matrix[j+1][i] != matrix[j][i]:                matrix[j][i], matrix[j+1][i] = matrix[j+1][i], matrix[j][i]                result = max(result, edible_candies(matrix))                matrix[j][i], matrix[j+1][i] = matrix[j+1][i], matrix[j][i]    print(result)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-3085%EB%B2%88/"
      },{
        "title": "백준 1476번",
        "excerpt":"year - criterion 을 정해진 MAX_of_criterion과 modulo 연산을 했을 때, 그 값이 0이 나와야한다. 모든 단위 (지구, 태양, 달)가 0으로 나누어 떨어질 때가 답이다. import sysdef solution():    earth, sun, moon = map(int, sys.stdin.readline().strip().split(\" \"))    year = 1    while True:        if ((year-earth) % 15 == 0            and (year-sun) % 28 == 0            and (year-moon) % 19 == 0):            # 모든 조건이 맞을 때, 원하는 연도가 나옴            print(year)            break        year += 1if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1476%EB%B2%88/"
      },{
        "title": "백준 1978번",
        "excerpt":"에스트라노스의 체를 사용하면 쉽게 풀 수 있는 문제다 def is_prime(n, primes):    p = 2    while p*p &lt;= n:        if primes[p]:            for i in range(p*2, n+1, p):                primes[i] = False        p += 1        primes[0] = False    primes[1] = False    return primes[n]    def solution():    primes = [True for i in range(1001)]    _ = int(input())    ans = map(int, input().split(\" \"))    ans = [num for num in ans if is_prime(num, primes)]    print(len(ans))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1978%EB%B2%88/"
      },{
        "title": "백준 1107번",
        "excerpt":"정해놓은 시간에 못 풀어서 구글링을 했다. 참고한 블로그 def solution():    usable_keys = {str(i) for i in range(10)}    goal = int(input())    broken = int(input())    if broken &gt; 0:        # 고장난 버튼은 제거하기        usable_keys -= set(map(str, input().split(\" \")))    # case 1: 100번에서 -,+로만 움직일 때    min_cnt = abs(100 - goal)    # case 2: brute force    for num in range(1000001):        num = str(num)        for j in range(len(num)):            if num[j] not in usable_keys:                break            elif j == len(num) - 1:                min_cnt = min(min_cnt, abs(goal - int(num)) + len(str(num)))        print(min_cnt)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1107%EB%B2%88/"
      },{
        "title": "백준 1929번",
        "excerpt":"에스트라노스의 체를 사용하면 쉽게 풀 수 있다. import sysdef sieve_of_e(n):    primes = [True for i in range(1000001)]    p = 2    while p*p &lt;= n:        if primes[p]:            for i in range(p*2, n+1, p):                primes[i] = False                p += 1        primes[0] = False    primes[1] = False    return primesdef solution():    m, n = map(int, sys.stdin.readline().strip().split(\" \"))    primes = sieve_of_e(n)    for num in range(m, n+1):        if primes[num]:            print(num)        if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1929%EB%B2%88/"
      },{
        "title": "백준 10845번",
        "excerpt":"처음에는 따로 클래스를 만들어서 큐를 구현했는데 시간 초과가 떴다. 그래서 그냥 리스트로 구현을 해봤는데 성공했다. 클래스를 만드는 오버헤드 조차 용납하지 않는 엄격한 백준이다. import sysdef solution():        tc = int(sys.stdin.readline())    q = []    for _ in range(tc):        command = sys.stdin.readline().split()        if len(command) &lt; 2:            if command[0] == \"front\":                print(q[0] if q else -1)            elif command[0] == \"back\":                print(q[-1] if q else -1)            elif command[0] == \"size\":                print(len(q))            elif command[0] == \"empty\":                print(1 if not q else 0)            elif command[0] == \"pop\":                print(q.pop(0) if q else -1)        else:            q.append(command[1])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10845%EB%B2%88/"
      },{
        "title": "백준 6588번",
        "excerpt":"에스트라노스의 체를 사용하면 풀 수 있다. 처음 접근 방식은 소수를 먼저 구한 후 모든 2자리 조합을 비교하며 가장 큰 difference 값을 가진 두 수를 추출하는 것이었다. 비교 함수까지 직접 만들어서 문제를 풀었지만 시간초과가 떠서 실패했다. 직접 비교함수를 구현하고 모든 조합을 찾는 과정이 O(n^2)까지 걸려서 그런 것 같다. 구글링 후 주어진 num 보다 작은 소수열에서 왼쪽과 오른쪽이 동시에 소수인 것을 찾으면 답이라는 것을 깨닫고 코드를 수정했는데 성공했다. 소수를 먼저 구해 놓는 것이 핵심이다. 참고한 블로그 def find_largest_combination(num, primes):    left = 0    right = num    fin = False        # 왼쪽과 오른쪽에서 소수인 것을 찾으면 답이다    for _ in range(1000000):        if primes[left] and primes[right]:            print(\"{} = {} + {}\".format(num, left, right))            fin = True            break        left += 1        right -= 1        if not fin:        print(\"Goldbach's conjecture is wrong.\")def get_primes(num):    # 에스트라노스의 체    primes = [True] * num        m = int(num ** 0.5)    for i in range(2, m + 1):        if primes[i]:            for j in range(i+i, num, i):                primes[j] = False    primes[0] = False    primes[1] = False    return primesdef solution():    # 미리 모든 소수를 구한다    primes = get_primes(1000001)    while True:        num = int(input())        if num == 0:            break                find_largest_combination(num, primes)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-6588%EB%B2%88/"
      },{
        "title": "백준 14500번",
        "excerpt":"주어진 지문 그대로 구현하면 되는 문제다. 쉬운 문제인 것 같다. 시간 복잡도는 O(N*M) 이다. import sysdef stick(x, y, matrix, maximum):    # 회전이나 대칭이 가능하다    # 막대기 2가지 있음    # ㅣ    if y + 3 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+2][x] + matrix[y+3][x]        maximum = max(maximum, temp)    # ㅡ    if x + 3 &lt; len(matrix[0]):        temp = matrix[y][x] + matrix[y][x+1] + matrix[y][x+2] + matrix[y][x+3]        maximum = max(maximum, temp)        return maximumdef square(x, y, matrix, maximum):    # 정사각형    if x + 1 &lt; len(matrix[0]) and y + 1 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+1][x+1] + matrix[y][x+1]        maximum = max(maximum, temp)        return maximumdef l_shape(x, y, matrix, maximum):    # L 8 가지 있음    # L 과 대칭    if x + 1 &lt; len(matrix[0]) and y + 2 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+2][x] + matrix[y+2][x+1]        maximum = max(maximum, temp)        temp = matrix[y][x+1] + matrix[y+1][x+1] + matrix[y+2][x+1] + matrix[y+2][x]        maximum = max(maximum, temp)    # ㄱ 과 대칭    if x + 2 &lt; len(matrix[0]) and y + 1 &lt; len(matrix):        temp = matrix[y][x] + matrix[y][x+1] + matrix[y][x+2] + matrix[y+1][x+2]        maximum = max(maximum, temp)        temp = matrix[y][x] + matrix[y+1][x] + matrix[y][x+1] + matrix[y][x+2]        maximum = max(maximum, temp)    # ㄴ 과 대칭    if x + 2 &lt; len(matrix[0]) and y + 1 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+1][x+1] + matrix[y+1][x+2]        maximum = max(maximum, temp)        temp = matrix[y+1][x] + matrix[y+1][x+1] + matrix[y+1][x+2] + matrix[y][x+2]        maximum = max(maximum, temp)    # 길이가 길고 넓이가 짧은 ㄱ 모양과 대칭    if x + 1 &lt; len(matrix[0]) and y + 2 &lt; len(matrix):        temp = matrix[y][x] + matrix[y][x+1] + matrix[y+1][x+1] + matrix[y+2][x+1]        maximum = max(maximum, temp)        temp = matrix[y][x] + matrix[y][x+1] + matrix[y+1][x] + matrix[y+2][x]        maximum = max(maximum, temp)        return maximumdef zig_zag(x, y, matrix, maximum):    # ㄹ 과 대칭    if x + 2 &lt; len(matrix[0]) and y + 1 &lt; len(matrix):        temp = matrix[y+1][x] + matrix[y+1][x+1] + matrix[y][x+1] + matrix[y][x+2]        maximum = max(maximum, temp)        temp = matrix[y][x] + matrix[y][x+1] + matrix[y+1][x+1] + matrix[y+1][x+2]        maximum = max(maximum, temp)    # 세운 ㄹ 과 대칭    if x + 1 &lt;len(matrix[0]) and y + 2 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+1][x+1] + matrix[y+2][x+1]        maximum = max(maximum, temp)        temp = matrix[y+1][x] + matrix[y+2][x] + matrix[y+1][x+1] + matrix[y][x+1]        maximum = max(maximum, temp)        return maximumdef t_shape(x, y, matrix, maximum):    # T 와 ㅗ    if x + 2 &lt; len(matrix[0]) and y + 1 &lt; len(matrix):        temp = matrix[y][x] + matrix[y][x+1] + matrix[y+1][x+1] + matrix[y][x+2]        maximum = max(maximum, temp)        temp = matrix[y+1][x] + matrix[y+1][x+1] + matrix[y][x+1] + matrix[y+1][x+2]        maximum = max(maximum, temp)        # ㅏ ㅓ    if x + 1 &lt; len(matrix[0]) and y + 2 &lt; len(matrix):        temp = matrix[y][x] + matrix[y+1][x] + matrix[y+1][x+1] + matrix[y+2][x]        maximum = max(maximum, temp)        temp = matrix[y][x+1] + matrix[y+1][x+1] + matrix[y+1][x] + matrix[y+2][x+1]        maximum = max(maximum, temp)        return maximumdef tetronomio(x, y, matrix, maximum):    maximum = stick(x, y, matrix, maximum)    maximum = square(x, y, matrix, maximum)    maximum = l_shape(x, y, matrix, maximum)    maximum = zig_zag(x, y, matrix, maximum)    maximum = t_shape(x, y, matrix, maximum)    return maximumdef solution():    # 판의 크기를 구한다    N, M = map(int, sys.stdin.readline().split())    matrix = []    for _ in range(N):        nums = list(map(int, sys.stdin.readline().split()))        matrix.append(nums)        maximum = 0    for row in range(len(matrix)):        for col in range(len(matrix[row])):            maximum = max(maximum, tetronomio(col, row, matrix, maximum))        print(maximum)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14500%EB%B2%88/"
      },{
        "title": "백준 15649번",
        "excerpt":"permutations를 사용하면 쉽게 풀 수 있다. import sysfrom itertools import permutationsdef solution():    N, M = map(int, sys.stdin.readline().split())    sequence = [i for i in range(1, N+1)]    perms = permutations(sequence, M)        for comb in perms:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15649%EB%B2%88/"
      },{
        "title": "Medium 클론 백엔드를 만들어보자 -11",
        "excerpt":"목차   Medium 클론 백엔드를 만들어보자 -1  Medium 클론 백엔드를 만들어보자 -2  Medium 클론 백엔드를 만들어보자 -3  Medium 클론 백엔드를 만들어보자 -4  Medium 클론 백엔드를 만들어보자 -5  Medium 클론 백엔드를 만들어보자 -6  Medium 클론 백엔드를 만들어보자 -7  Medium 클론 백엔드를 만들어보자 -8  Medium 클론 백엔드를 만들어보자 -9  Medium 클론 백엔드를 만들어보자 -10  Medium 클론 백엔드를 만들어보자 -11이전 포스트에서 . . .   배포 과정을 자동화이 포스트는 . . .   중간 점검현재 진행 상황 한동안 글을 쓰지 않아서 중간 점검할 겸 작성하는 포스트다. 현재 TDD 방식으로 테스트케이스를 먼저 작성하고 로직 코드를 짜는 방식으로 프로젝트를 진행 중에 있다. 그 동안 구현한 것들을 나열하자면:   DB에 users 와 posts 테이블을 구현하고 실제로 데이터를 삽입/삭제/업데이트 할 수 있도록 한 것  /users, /posts, /login, /logout 등 api endpoint들을 하나씩 간단하게나마 테스트코드와 함께 구현 한 것  리팩토링처음 디자인과 바뀐 점 프로젝트를 진행하면서 처음 설계 미스로 수정해야 할 몇 가지 부분이 생겼다. AWS RDS 일단 AWS RDS가 월 750시간 인 줄 알았는데 프리티어 기간 (12개월) 전체 동안 750시간 인 것 같다. 아직 월 사용량이 안 찍혀서 잘 모르겠지만 문득 12개월에 750시간인 것 같아서 배포 할 때만 RDS 켜고 그 외에는 꺼 놓는 방식으로 프로젝트를 진행 중이다. Oauth2.0가 아닌 JWT를 이용한 유저 인증/인가 Oauth2를 구현하려고 했는데 굳이 필요가 없다는 느낌을 받았다. Oauth2의 메리트는 제 3자의 유저 인증과 소셜 로그인이 가능하다는 것인데 현재 이 클론 프로젝트는 제 3자의 유저 인증과 소셜 로그인이 필요 없는 것 같아서 빼기로 결정했다. 이후 다른 인가 방식 중에 Bearer authentication을 JWT를 사용해 구현하는 방법이 있어서 시도하는 중이다. JWT를 전달하는 방식은 httpOnly cookie로 유저에게 전달한다. httpOnly로 토큰을 쿠키에 저장시켜서 전달하게 되면, 유저쪽에서 Document.Cookie로 쿠키에 저장된 토큰을 사용할 수 없다. 하지만 JWT는 기본적으로 해독이 가능하기 때문에 HTTPS가 필수적이다. 현재는 HTTP 기반이지만 JWT를 사용해서 유저를 인증/인가 시키기로 결정했다. 이유는 토큰 방식 인증/인가를 써본 적이 없고 배우고 싶어서가 제일 큰 이유고 현재 API에 Oauth2는 필요 없다고 생각하기 때문이다. 앞으로 해야 할 것들 아직 구현해야 할 것들은 많이 있다.   JWT로 유저 인가/인증  /posts의 실질적인 데이터로 CRUD를 구현  네거티브 테스트 케이스 작성  tag/author 기반 posts 찾기 등  리팩토링현재까지 느낀 점 처음 설계한 대로 RESTful API는 잘 만들고 있는 것 같다. TDD 방식도 잘 유지 중이다. 하지만 공부해야 할 것들이 더 있다는 것을 느꼈다. 기본적으로 부족하다고 느낀 것은 다음과 같다. DB 설계 능력 부족. 현재 users 와 posts 테이블이 있고 관계형 DB를 사용하고 있지만 두 테이블 사이 연관점을 잇는 방법을 모른다. Foreign Key를 사용하면 되는 것을 어렴풋이 알고만 있을뿐이다. 현재 서비스가 작아서 망정이지 만약 더 많은 테이블과 연관관계를 다뤄야하는 서비스를 만들어야 한다면 DB 공부는 필수라는 것을 알았다. 또한 DB 관련된 기본적인 부분이 부족하다. Indexing, transaction, pool, join, cartesian product 같이 다 한번 씩 들어는 보았지만 정확히는 모르는 상태다. 공부의 필요성을 느꼈다. 비효율적인 개발 습관 나의 개발 습관은 다음과 같다.   아이디어를 일단 코드로 구현한다. 이때는 모든 코드가 한 파일에 있거나, 작은 부분적인 코드들은 중복이 되거나 하는 편이다  기능 구현에 막히면 공식 문서/스택오버플로우 등을 참고한다  이후 기능을 성공적으로 구현을 하면 구닥다리 코드를 리팩토링한다  파일로 나누고 객체화를 하는 등 좀 더 관리가 용이하게 바꾼다위의 과정을 계속 거치다 보니까 불필요하게 코드 파일이 커진다. 예를 들면 하나의 테스트 과정을 한 파일에 다 때려박아 넣어놓은 것도 있다. 개발 방식을 바꿔야한다는 느낌이 들었다. 하지만 이것은 곧 경험/지식과도 연관이 되는 것 같다. 디자인 패턴 등을 알아야 아이디어를 구현하는 단계에서 범용성있는 코드를 짤 수 있다는 것을 느꼈다. 디자인 패턴의 부재 백엔드의 디자인 방식이 RESTful인것은 좋지만 Creational, Structural, Behavioral 등 프로그래밍의 디자인 패턴을 몰라서 코드가 더 난잡해지고 있다는 느낌이 들었다. 디자인 패턴을 좀 공부를 해야지 될 것 같다. 결론적으로 기본을 좀 더 공부해야한다. 마무리 정리를 하자면:   몇가지 변경사항이 있었지만 개발은 잘 하고 있는 중이다  기본적인 CS 지식이 부족하다는 것을 느꼈다다음 포스트는 백엔드를 완료하고 후기 형식으로 작성할 것이다. ","categories": [],
        "tags": ["project"],
        "url": "https://json9512.github.io/blog/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Medium-%ED%81%B4%EB%A1%A0-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-11/"
      },{
        "title": "백준 15650번",
        "excerpt":"combinations를 사용하면 쉽게 풀 수 있다. import sysfrom itertools import combinationsdef solution():    N, M = map(int, sys.stdin.readline().split())    sequence = [i for i in range(1, N+1)]    combs = combinations(sequence, M)        for comb in combs:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15650%EB%B2%88/"
      },{
        "title": "백준 6064번",
        "excerpt":"LCM을 활용하면 풀 수 있다. 이런 문제가 어렵다. 결국 블로그를 보고 풀었다. import sysdef gcd(x, y):    while y:        x, y = y, x % y    return xdef lcm(x, y):    return (x*y) / gcd(x, y)def solution():    tc = int(sys.stdin.readline())    for _ in range(tc):        m, n, x, y = map(int, sys.stdin.readline().split())        max_year = int(lcm(m, n)) # LCM이 멸망년이다        while True:            # 멸망년을 벗어나거나            # x, y를 만족하는 년도를 찾는다            if x &gt; max_year or (x-1) % n + 1 == y:                break            # 계속 m을 더해준다            x += m        if x &gt; max_year:            print(-1)        else:            print(x)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-6064%EB%B2%88/"
      },{
        "title": "Process 와 Thread",
        "excerpt":"출처: 프로세스 - 위키피디아, 스레드 - 위키피디아 프로세스와 스레드에 대해 알아보기 전에 프로그램이 어떻게 실행되는지를 알아보자. 컴퓨터에서 크롬을 실행시킨다고 생각해보자. 크롬은 프로그램이고 프로그램이란 특정 task를 수행하기 위한 컴퓨터 명령어들의 집합체다. 프로그램은 프로그래밍 언어로 쓰여지고 Disk나 비휘발성 메모리에 저장된다. 크롬은 C++을 기반으로 쓰여졌다. 이후 이 명령어들의 집합체를 0과1로 컴퓨터가 이해 할 수 있도록 저장시켜놓는 방식 (compiled)이 있고 프로그램이 실행 될 때 0과1로 변환시키는 방식(interpreted)이 있다. 아무튼, 크롬을 클릭하면 컴퓨터는 크롬이란 프로그램의 명령어들을 이진수의 형태로 컴퓨터의 메모리에 저장하게된다. 프로세스 메모리에 저장된 이진수 코드를 실행 시키기위해 OS는 프로세스라는 것을 만든다. 프로그램을 실행 시키기 위해 복수의 프로세스가 필요할 수도 있다. OS는 프로세스에게 프로세스 정보, 레지스터, 카운터, 스택, 힙, 실행될 코드를 배분해준다. 이를 PCB (Process control block)라고도 한다.   프로세스 정보:          프로세스 아이디      프로세스 상태            레지스터: CPU와 관련된 정보를 담고있다. Instruction, storage address 등 프로세스와 관련된 정보를 가장 빠르게 읽어 볼 수 있는 위치에 저장한다.         카운터: 포인터라고도 한다. 현재 프로그램이 어디쯤 실행됐는지 혹은 다음 실행 구간이 어딘지를 가르킨다.         스택: 함수, 함수 인자, 리턴 값, 로컬 변수 등 빠르게 읽고 쓰여야 할 정보를 저장한다.         힙: dynamic allocated 메모리다.     실행될 코드: 프로세스가 실행해야할 프로그램의 코드 일부분이다.이 외에도 I/O 상태 정보나 스케쥴링 정보 등 더 있다. 위키피디아를 참고하자. 각 프로세스는 다른 프로세스와 분리되어 있다. 프로세스간 스위칭을 하게 될 때, 프로세스의 상태, 자원 등을 저장하고 로딩해야 되기 때문에 일정 시간이 소요된다. 프로세스는 경우에 따라 Concurrent 또는 Parallel하게 실행 될 수 있다.   Concurrency (병행성) 과 Parallel (병렬)   Concurrency는 논리적 (코드로 인해)으로 하나의 코어/스레드에서 Context switching을 하면서 일렬의 명령어를 실행하는 것. Eg. 한 명의 고수 체스 플레이어가 20명의 상대를 상대한다고 생각해보자. 20개의 테이블에 고수가 직접 돌아다니면서 20개의 게임을 5초씩 처리하는 것이라고 보면 된다.Parallel 처리는 물리적으로 복수의 코어/스레드가 동시에  Task를 수행하는 것이다.Eg. 20명의 고수가 20명의 선수를 각 각 상대하는 것. 다시 크롬을 생각해보자. 이제 크롬 창이 열렸다고 생각하고 새로운 탭을 켜면, 새로운 프로세스가 시작되는 것이다. 프로세스간 분리되어 있어야하는 이유는 특정 프로세스가 먹통이 되면 전체 프로그램을 먹통으로 만들게 될 수 있기 때문이다. 만약 크롬 탭 중에 하나가 응답이 없다고 나머지 탭들도 응답을 하지 않는다면 상당히 짜증날 것이다. (IE 7까지만 해도 흔한 상황이었다.) 스레드 크롬에서 구글을 사용한다고 가정해보자. 크롬 창에 보여지는 탭과 옵션, 북마크, 크롬 익스텐션, 네트워크 통신 기능 등 크롬이란 프로그램에는 여러가지 기능들이 있다. 이 프로그램에는 여러개의 프로세스가 돌아가고 있다. 그리고 각 프로세스는 스레드라는 것이 있다. 프로세스 내에 스레드의 개수는 최소 하나다. 스레드는 프로세스의 자원을 공유한다. 각 스레드는 자기만의 레지스터와 스택을 가지게 되고 힙 메모리와 프로세스에 할당 된 실행코드를 나눠쓰게 된다. 스레드는 힙 메모리를 공유하고 있기 때문에 하나의 스레드에서 실행되는 코드가 다른 스레드의 코드에 영향을 줄 수 있다. 이는 장점이 되기도하고 단점이 되기도 한다.             Process      Thread                  실행까지 소요시간이 상대적으로 길다      실행까지 소요시간이 상대적으로 짧다              프로세스는 자기만의 메모리 공간을 가진다      스레드는 프로세스가 사용하는 메모리 공간을 사용한다              프로세스간 통신은 상대적으로 느리다      스레드간 통신은 상대적으로 빠르다. 메모리를 공유하기 있기 때문              Context Switching시 더 많은 시간과 자원이 필요하다      Context Switching시 더 적은 시간과 자원이 필요하다              프로세스간 메모리를 공유하지 않는다      같은 프로세스에 있는 스레드간 메모리를 공유한다      ","categories": [],
        "tags": ["CS"],
        "url": "https://json9512.github.io/blog/CS-%EA%B8%B0%EC%B4%88-Process-%EC%99%80-Thread/"
      },{
        "title": "백준 15651번",
        "excerpt":"itertools.product를 사용하면 쉽게 풀 수 있다. import sysfrom itertools import productdef solution():    num, length = map(int, sys.stdin.readline().strip().split())    arr = [i for i in range(1, num+1)]    ans = product(arr, repeat=length)    for comb in ans:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15651%EB%B2%88/"
      },{
        "title": "백준 1748번",
        "excerpt":"처음엔 \"\".join[str(i) for i in range(1, num+1)] 으로 도전했지만 역시나 메모리 초과가 떴다. 이후 자릿수를 기준으로 더해지는 수를 구하는 방식으로도 풀었지만 시간초과가 떴다. 결국 정해놓은 시간에 못 풀어서 구글의 도움을 받았다. import sysdef solution():    num = sys.stdin.readline().strip()    ans = 0    for i in range(len(num)):        ans += 9 * (10**i) * (i+1)    ans += (int(num) - (10 ** len(num)-1)) * (len(num))    print(ans)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1748%EB%B2%88/"
      },{
        "title": "Context Switching 이란",
        "excerpt":"출처: Context Switch - 위키피디아 Context Switching에 대해 알아보자. 줄여서 CS라고 하겠다. CS는 process 혹은 thread의 상태를 저장해서 추후에 다시 저장한 곳을 불러와 작업을 이어가는 것을 뜻한다. 즉 CS는 컴퓨터가 1개 이상의 process나 thread를 번갈아가면서 작업할 때 사용되는 process/thread 관리 기법이다. 이 밖에 interrupt의 형식으로도 일어난다. 예를 들면 task가 dist storage를 사용해야 할 때, CPU를 다른 task가 쓸 수 있도록 해준다. 어떤 OS들은 user mode 와 kernel mode task간 CS를 해야한다. 기본적으로 CS는 overhead가 발생한다. Processor 간 CS가 Thread 간 CS보다 overhead가 크다. 이유는 Process Control Block (PCB)가 Thread Control Block (TCB) 보다 더 많은 데이터를 다루고 있기 때문이다. ","categories": [],
        "tags": ["CS"],
        "url": "https://json9512.github.io/blog/CS-%EA%B8%B0%EC%B4%88-Context-Switching%EC%9D%B4%EB%9E%80/"
      },{
        "title": "백준 15652번",
        "excerpt":"A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 확인하는 함수를 만들고 itertools.product를 사용해서 풀었는데 시간 초과가 떴다. 찾아보니 itertools.product는 주어진 arr에대한 모든 조합을 결과 값으로 준다. 예를 들면: 인풋: \"[1, 2, 3] 3\"결과값: \"\"\"1 1 11 1 21 1 31 2 11 2 21 2 31 3 11 3 21 3 32 1 12 1 22 1 32 2 12 2 22 2 32 3 12 3 22 3 33 1 13 1 23 1 33 2 13 2 23 2 33 3 13 3 23 3 3\"\"\"문제를 살펴봤을 때 불필요한 연산이 많아서 itertools 라이브러리를 찾아보다가 itertool.combinations_with_replacement 함수로 시도하니까 풀렸다. itertool.combinations_with_replacement의 예시: 인풋: \"[1, 2, 3] 3\"결과값: \"\"\"1 1 11 1 21 1 31 2 21 2 31 3 32 2 22 2 32 3 33 3 3\"\"\"답안: import sysfrom itertools import combinations_with_replacementdef solution():    num, length = map(int, sys.stdin.readline().strip().split())    arr = [i for i in range(1, num+1)]    ans = combinations_with_replacement(arr, length)    for comb in ans:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15652%EB%B2%88/"
      },{
        "title": "백준 9095번",
        "excerpt":"1, 2, 3으로 주어진 N을 만드는 모든 조합은 N에 도달 할때까지 x+1, x+2, x+3을 지속적으로 하면된다. x = 0x의 경우의 수: [x+1], [x+2], [x+3] # 1stx = 1, 2, 3x의 경우의 수: [1+1], [1+2], [1+3] | [2+1], [2+2], [2+3] | [3+1], [3+2], [3+3] # 2nd....x == N 이 될 때까지 반복위 아이디어를 구글링을 통해 알게 되었고 재귀적으로 구현했다. import syscounter = 0def recur(val, num):    global counter    if val &gt; num:        return    elif val == num:        counter += 1        recur(val+1, num)    recur(val+2, num)    recur(val+3, num)def solution():    tc = int(sys.stdin.readline())    global counter     for _ in range(tc):                counter = 0        num = int(sys.stdin.readline())        recur(0, num)            print(counter)        if __name__ == \"__main__\":    solution()DP로 다시 풀기 다시 이 문제를 접했을 때 전에 했던 방식 (위의 예제)이 브루트 포스로 풀었다고 생각해서 DP로 풀어보려고 했다. 근데 답이 안나와서 구글링을 했더니 위의 예제와 같은 답이 나왔다. import sysdef recur(num):    if num == 1:        return 1    elif num == 2:        return 2    elif num == 3:        return 4    else:        return recur(num-1) + recur(num-2) + recur(num-3)def solution():    t = int(sys.stdin.readline())    for _ in range(t):        n = int(sys.stdin.readline())        print(recur(n))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-9095%EB%B2%88/"
      },{
        "title": "백준 15654번",
        "excerpt":"문제는 permutations을 이용하면 쉽게 풀린다. 주의 해야 할 것은 숫자를 string으로 읽었을 때 \"3, 11\" 을 정렬하면 \"11, 3\" 으로 나오기 때문에 틀린 답안이 나온다. 숫자를 int로 만들고 정렬 후 결과 값에서 다시 string으로 변환 시켜주면 된다. import sysfrom itertools import permutationsdef solution():    N, M = map(int, sys.stdin.readline().strip().split())    nums = list(map(int, sys.stdin.readline().strip().split()))    nums.sort()    combs = permutations(nums, M)    for comb in combs:        if len(comb) &lt;= N:            print(\" \".join(map(str, comb)))        if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15654%EB%B2%88/"
      },{
        "title": "백준 1759번",
        "excerpt":"접근방식은 문제가 없었지만 결과값에 공백을 끼워넣는 바람에 1시간 정도 왜 틀린지 몰랐던 문제다. 난 바보가 분명하다. import sysfrom itertools import combinationsdef solution():    L, C = map(int, sys.stdin.readline().strip().split())    letters = sys.stdin.readline().strip().split()    letters.sort()        combs = combinations(letters, L)    for comb in combs:        vow = 0        for letter in comb:            if letter in \"aeiou\":                vow += 1                if 1 &lt;= vow &lt;= l-2:            print(\"\".join(comb))        if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1759%EB%B2%88/"
      },{
        "title": "백준 15655번",
        "excerpt":"15654번 문제와 같은 맥락이다. permutations를 combinations로 바꿔주면된다. import sysfrom itertools import combinationsdef solution():    N, M = map(int, sys.stdin.readline().strip().split())    nums = list(map(int, sys.stdin.readline().strip().split()))    nums.sort()    combs = combinations(nums, M)    for comb in combs:        if len(comb) &lt;= N:            print(\" \".join(map(str, comb)))        if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15655%EB%B2%88/"
      },{
        "title": "백준 14501번",
        "excerpt":"정해놓은 시간안에 못 풀어서 구글링 후 풀었다. 재귀적으로 구현하려다 보니 계속 틀려서 좀 힘들었다. 참고한 블로그 import sysmax_profit = 0def check(idx, money, times, profits, n):    global max_profit    if idx &gt; n:        return        if idx == n:        max_profit = max(max_profit, money)        return    check(idx + times[idx], money + profits[idx], times, profits, n)    check(idx+1, money, times, profits, n)  def solution():    tc = int(sys.stdin.readline())    profits = []    times = []    for _ in range(tc):        time, profit = map(int, sys.stdin.readline().split())        times.append(time)        profits.append(profit)    check(0, 0, times, profits, tc)    print(max_profit)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14501%EB%B2%88/"
      },{
        "title": "백준 15656번",
        "excerpt":"Cartesian product를 찾는 문제다. itertools.product를 사용해서 풀었다. import sysfrom itertools import productdef solution():    N, M = map(int, sys.stdin.readline().split())    arr = list(map(int, sys.stdin.readline().split()))    arr.sort()    combs = product(arr, repeat=M)    for comb in combs:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15656%EB%B2%88/"
      },{
        "title": "백준 14889번",
        "excerpt":"주어진 지문을 따라서 구현하면 풀리긴한다. 문제 자체는 어렵지 않다. 접근 방식은 브루트 포스다   주어진 N 만큼의 indices array를 만든다. ex. N = 4, arr = [0, 1, 2, 3].  arr로 N//2 (정확히 반으로 나눌 수 있다고 했으니) 만큼 만들 수 있는 모든 조합을 찾는다  각 조합마다 조합내의 다른 객체와 짝을 지어 볼 수 있는 모든 조합을 찾는다ex.          N = 6 arr = [0, 1, 2, 3, 4, 5]      combs = [[0, 1, 2] , [3, 4, 5] ... etc]      comb = [0, 1, 2]      comb내 모든 조합 [0, 1], [1, 2]        matrix 에 idx 값을 넣고 능력치를 더한다  링크 팀과 스타트 팀의 능력치 difference를 구한다  구한 diff 가 현재 min_diff 보다 낮으면 min_diff를 업데이트한다import sysfrom itertools import combinationsdef calc_diff(arr, comb, matrix):    a_team = comb    b_team = []    for i in arr:        if i not in comb:            # b team            b_team.append(i)        a_team_combs = list(combinations(a_team, 2))    b_team_combs = list(combinations(b_team, 2))    # sum diff    a_team_point = 0    b_team_point = 0    for i in range(len(a_team_combs)):        a_team_point += matrix[a_team_combs[i][0]][a_team_combs[i][1]] + matrix[a_team_combs[i][1]][a_team_combs[i][0]]        b_team_point += matrix[b_team_combs[i][0]][b_team_combs[i][1]] + matrix[b_team_combs[i][1]][b_team_combs[i][0]]    bigger = max(a_team_point, b_team_point)    smaller = min(a_team_point, b_team_point)    return bigger - smallerdef solution():    N = int(sys.stdin.readline())    matrix = []    for _ in range(N):        arr = list(map(int, sys.stdin.readline().split()))        matrix.append(arr)        # 팀이 될 수 있는 모든 조합    indicies = [i for i in range(N)]    combs = combinations(indicies, N//2)    min_diff = 9999999    for comb in combs:        diff = calc_diff(indicies, comb, matrix)        if diff &lt; min_diff:            min_diff = diff    print(min_diff)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14889%EB%B2%88/"
      },{
        "title": "백준 15656번",
        "excerpt":"itertools.combinations_with_replacement를 사용해서 풀었다. 파이썬은 내장함수로 combinations, permutations를 쉽게 구현할 수 있다. 하지만 내부적으로 이것들이 어떻게 돌아가는지 알아야 할 것 같다. import sysfrom itertools import combinations_with_replacementdef solution():    N, M = map(int, sys.stdin.readline().split())    arr = list(map(int, sys.stdin.readline().split()))    arr.sort()    combs = combinations_with_replacement(arr, M)    for comb in combs:        print(*comb)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15657%EB%B2%88/"
      },{
        "title": "백준 18290번",
        "excerpt":"현재 방식은 시간초과가 뜬다. 접근 방식은 브루트포스인데 좀 비효율적인 방식인 것 같다.   각 숫자를 [x, y, value] 로 리스트에 저장한다  combinations를 통해 K 조합을 찾아낸다  각 조합을 iterate하면서 주어진 위, 오른쪽, 왼쪽, 아래 조건을 만족시키는 K 숫자를 고른다  숫자의 합을 구하고 이미 가진 숫자의 합 보다 크면 저장한다생각해낸 방식이 틀리지는 않지만 반복적인 작업이 많고 불필요한 부분이 있어서 수정이 필요하다. 검색을 해보니 DFS 와 백트래킹으로 풀 수 있다고 한다. 다음 번에 다시 도전 해보려고 한다. import sysfrom itertools import combinationsdef check(comb):    for i in range(len(comb)):        for j in range(len(comb)-1):            if ((comb[j][0]+1 == comb[j+1][0] and comb[j][1] == comb[j+1][1])                or (comb[j][1]+1 == comb[j+1][1] and comb[j][0] == comb[j+1][0])                or (comb[j][0]-1 == comb[j+1][0] and comb[j][1] == comb[j+1][1])                or (comb[j][1]-1 == comb[j+1][1] and comb[j][0] == comb[j+1][0])):                return False    return Truedef summed(comb):    return sum([comb[i][2] for i in range(len(comb))])def solution():    N, M, K = map(int, sys.stdin.readline().split())    matrix = []    for i in range(N):        temp_arr = []        data = list(map(int, sys.stdin.readline().split()))        for j in range(M):            d = (i, j, data[j])            temp_arr.append(d)                matrix.extend(temp_arr)    max_val = -30001    combs = combinations(matrix, K)    for c in combs:        if check(c):            temp_val = summed(c)            if max_val &lt; temp_val:                max_val = temp_val    print(max_val)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-18290%EB%B2%88/"
      },{
        "title": "그리디 알고리즘",
        "excerpt":"그리디 알고리즘이란 “매 순간 최선의 선택”을 하는 알고리즘이다. 어떤 문제가 그리디 알고리즘이 되려면 다음과 같은 특징이 있어야 한다.   큰 문제에서 작은 문제를 도출해 낼 수 있어야하고  작은 문제의 최적의 해를 반복적으로 구하면, 큰 문제의 최적의 해를 구할 수 있어야한다가장 기본적인 예시로 “거스름 돈 구하기” 가 있다. 60 달러를 화폐 단위 [1, 5, 10, 20] 으로 거슬러 주려고 한다. 주어진 화폐 단위를 사용해서 60 달러를 만들 수 있는 가장 적은 화폐 개수를 구하는 문제다. Ex. 60 달러 = [20, 20, 20] 파이썬 구현 import sysdef solution():    # 입력값 읽기    dollar = int(sys.stdin.readline())    changes = list(map(int, sys.stdin.readline().split()))    # 화폐를 정렬 해준다.    changes.sort(reverse=True) # O(n log n)    ans = {}    # 돈이 다 거슬러 질 때까지 반복한다    for c in changes: # O(n)        num_c = dollar // c        dollar -= c * num_c        ans[c] = num_c        print(ans)    # worst/avg/best: O(n) time, O(n) aux space if __name__ == \"__main__\":    solution()# 입력 값# 60# 1 5 10 20# 결과 값: {20: 3, 10: 0, 5: 0, 1: 0}그리디 알고리즘은 최적의 수를 구하기 때문에 정렬을 통해 어떤 요소의 최소 값, 최대 값을 사용하는 경우가 많다. 그리디 알고리즘을 사용하는 알고리즘은 많다.   다익스트라 최단 거리  Activity selection  Travelling salesman problem  Huffman coding  크루스칼, 프림의 MST","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
      },{
        "title": "다이나믹 프로그래밍",
        "excerpt":"다이나믹 프로그래밍이란 큰 문제를 반복적인 작은 문제로 나눈 뒤 작은 문제를 해결함으로써 큰 문제의 최적의 해를 구하는 방식이다. 이때 작은 문제의 결과값을 캐싱해서 재사용 하는 것이 핵심이다. 다이나믹 프로그래밍에는 2가지 기법이 있다. Memoization과 Tabulation이 있는데 간단히 보면 Memoization은 Top down 방식으로 위에서 아래로 DP를 수행하는 것이고 Tabulation은 밑에서 위로 DP를 수행하는 것이다. 조금 더 자세한 설명은 이 포스트에 작성해놨다. 문제를 작은 문제로 쪼개어 푸는 방식이 그리디 알고리즘과 유사하지만 그리디 알고리즘은 현재 고를 수 있는 최적의 방법을 구하는 방면 다이나믹 프로그래밍은 문제 전체를 보았을 때 최적의 방법을 구하는 알고리즘이다. DP 문제 중 흔히 접하는 0-1 Knapsack 문제를 알아보자. 0-1 Knapsack 문제에서 주어지는 입력 값은 특정 아이템의 값어치와 아이템의 무게다. 이 아이템들을 무게 제한이 있는 가방에 담는다고 생각해보자. 이때 무게에 맞게 가방에 아이템들을 담았을 때 최대 값어치를 구하는 것이다. Ex. values = [1, 10, 5], weight = [1, 50, 10], 가방의 무게제한 = 10 =&gt; 답: 10의 무게와 5의 값어치를 가진 아이템을 담는다 파이썬 구현 import sysdef knapsack(weights, limit, values, N):    dp = [[0 for _ in range(limit+1)] for _ in range(N+1)]    # Bottom up 방식으로 0에서부터 DP 테이블을 채워 나간다    for i in range(N+1):        for w in range(limit+1):            if i == 0 or w == 0:                dp[i][w] = 0            elif weights[i-1] &lt;= w:                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])            else:                dp[i][w] = dp[i-1][w]        return dp[N][limit]def solution():    # 입력값 읽기    values = list(map(int, sys.stdin.readline().split()))    weights = list(map(int, sys.stdin.readline().split()))    limit = int(sys.stdin.readline())    N = len(values)    print(knapsack(weights, limit, values, N))if __name__ == \"__main__\":    solution()# 입력 값: # 60 100 120# 10 20 30# 50# 결과 값: 220DP를 잘 풀기 위해서는 작은 문제를 푸는 점화식 (recurrence relation)을 찾는 것이 중요하다. 물론 이것은 경험을 통해서 쌓이는 것 같다. ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"
      },{
        "title": "백 트랙킹",
        "excerpt":"백 트랙킹 알고리즘이란 특정 조건에 부합하는 모든 조합의 수를 살펴보는 알고리즘이다. 특정 조건에 부합하지 않는 조합은 연산을 하지 않고 넘어가는 방식으로 코드를 짜는 것이다. 대표적인 문제로 N-Queens 문제가 있다. 참고   N*N 체스판에 최대한 많은 Queen을 놓아야한다. 단, 서로 공격이 불가능한 자리에 놓고 싶다. 위의 문제를 브루트포스로 풀 수는 있겠지만 비효율적이다. 가령 N = 8 이라고 가정을 해보자. 8x8 체스판에 퀸을 놓을 수 있는 자리는 총 64개다. 즉 C(64, 8) 이라고 볼 수 있다. 이를 조합의 수를 구하는 공식 C(n, r) = n! / (r! (n-r)!) 에 넣어서 계산을 해보면 대략 45억개의 조합이 나온다. 45억개의 조합을 브루트포스로 연산을 하려하면 대부분의 코테에서 시간초과가 뜰 것이다. 보다 효율적인 방법이 바로 백 트랙킹 알고리즘이다. 위의 문제를 백트랙킹 기법으로 풀고자 하면 퀸을 특정 칸에 놓을 때 마다 조건에 부합한지 판단을 하기 때문에 45억개의 조합을 연산하는 것보다 훨어어어얼씬 더 적은 연산을 하게 된다. 접근 방식은 다음과 같다   왼쪽 열에서 시작한다  모든 퀸이 보드에 배치됐으면 True를 반환한다  현재 열의 모든 행 칸에 다음을 시도한다          현재 칸에 퀸을 배치할 수 있으면, 현재 칸 [row, column]을 답안에 저장하고 재귀적으로 모든 퀸이 배치가 됐는지 확인한다      현재 칸에 퀸을 배치했을 때 모든 퀸이 배치가 된 것이면 True 를 반환한다      현재 칸에 퀸을 배치할 수 없으면 현재 [row, column]을 표시하지 않고 다음 row (행)으로 넘어가서 3. 을 반복한다        모든 행을 시도했는데 퀸을 배치할 수 없다면, False를 반환해서 백 트랙킹을 한다파이썬 구현 import sysdef can_place(board, row, col, N):    \"\"\"        퀸을 주어진 위치에 놓을 수 있는지 확인한다.        이 함수는 퀸이 배치된 후에 호출이 되기 때문에        왼쪽에 다른 퀸이 있는지만 확인하면 된다    \"\"\"    # 왼쪽을 확인한다    for i in range(col):        if board[row][i] == 1:            return False    # 왼쪽 대각선 위를 확인한다    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):        if board[i][j] == 1:            return False        # 왼쪽 대각선 아래를 확인한다    for i, j in zip(range(row, N, 1), range(col, -1, -1)):        if board[i][j] == 1:            return False        return Truedef backtrack(board, col, N):    # 조건부 확인    # 모든 퀸이 배치가 됐으면, True를 반환한다    if col &gt;= N:        return True        # 현재 열에서 모든 행에 퀸을 놓을 수 있는지 확인한다    for i in range(N):        if can_place(board, i, col, N):            # 보드[i][j]에 퀸을 배치한다            board[i][col] = 1            # 나머지 퀸을 배치하기 위해 재귀 호출을 한다            if backtrack(board, col+1, N) == True:                return True                        # 만약 현재 위치에 퀸을 배치하는 것이 답을 도출해 낼 수 없으면            # 현재 배치한 퀸을 지운다            board[i][col] = 0        # 만약 모든 퀸을 배치 할 수 없으면 False를 반환한다    return Falsedef solution():    # 입력값 읽기    N = int(sys.stdin.readline())    # N * N 크기의 보드를 초기화 한다.    board = [[0 for _ in range(N)] for _ in range(N)]    if not backtrack(board, 0, N):        print(\"Solution does not exist\")    else:        print(board)if __name__ == \"__main__\":    solution()# 입력 값: 8# 결과 값: [#    [1, 0, 0, 0, 0, 0, 0, 0], #    [0, 0, 0, 0, 0, 0, 1, 0], #    [0, 0, 0, 0, 1, 0, 0, 0], #    [0, 0, 0, 0, 0, 0, 0, 1], #    [0, 1, 0, 0, 0, 0, 0, 0], #    [0, 0, 0, 1, 0, 0, 0, 0], #    [0, 0, 0, 0, 0, 1, 0, 0], #    [0, 0, 1, 0, 0, 0, 0, 0]#    ]개인적으로 재귀 함수를 활용한 알고리즘이 나오면 어렵다. 어찌보면 백 트랙킹과 DP는 유사한 점이 많다. 어떤 알고리즘을 사용해야 할지 판단하는 것은 역시 문제를 많이 풀어보는 방법 밖에 없다. 백트랙킹을 활용한 문제는 다음과 같다.   The Knights tour  Rat in a Maze  N Queen  Subset sum  m coloring  Hamiltonian cycle  sudoku  Cryptarithmetic Puzzle  Magnet Puzzle","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%ED%8A%B8%EB%9E%99%ED%82%B9/"
      },{
        "title": "알고리즘 공부법",
        "excerpt":"알고리즘을 효율적으로 공부하는 방법은 무엇일까? 사람마다 개인 차가 있지만 단순히 문제를 많이 푸는 것보다 주관적인 기준으로 더 효율적인 공부법을 찾아봤다. 현재 진행 방식은 “문제를 많이 푸는 것” 이다. 확실히 문제를 많이 풀어보니 지문만 읽어도 기존에 풀었던 문제와 유사하면 풀이를 유추하는 것은 어렵지 않았다. 하지만 문제는 기존에 풀어봤던 알고리즘이 아닌 새로운 방식을 요하는 문제가 나오면 막히고 구글링에 의존하고 의지가 꺾여서 어느 순간 멈춰버리는 현상이 근 1달간 반복됐다. 이것을 피하고자 새로운 공부법을 시도해보려고 한다. 생각해낸 공부법은 일단 코테에 많이 나오는 알고리즘을 위주로 가장 기본적인 문제들을 하나씩 풀고 풀이법을 외운다. 이후 새로운 문제를 풀 때 다음과 같이 진행한다.   어떤 알고리즘을 써야 풀릴지 이미지 트레이닝을 해본다  효율적인지 생각한다  답안을 보고 맞는지 확인한다. (전체 코드가 아닌 알고리즘을 훑는 방식으로 본다)  답안의 알고리즘과 맞다면 구현해본다  Edge 케이스를 생각하고 시간/공간 복잡도를 생각해본다자주 나오는 알고리즘   그리디  백트랙킹  다이나믹 프로그래밍  구현  트리 알고리즘  그래프 알고리즘  DFS/BFS  비트  문자열  완전탐색 / 브루트포스데이터 구조   어레이/리스트  Singly linked list  Doubly linked list  Hash table  Tree  Queue  Stack","categories": [],
        "tags": ["algorithm","취준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B3%B5%EB%B6%80%EB%B2%95/"
      },{
        "title": "DFS, BFS",
        "excerpt":"코테에서 자주 사용되는 DFS, BFS다. DFS와 BFS는 그래프 혹은 트리와 같은 노드와 간선이 존재하는 데이터 타입에서 모든 노드를 탐색하는 알고리즘이다. Depth First Search는 깊이 우선 탐색이다. 말 그대로 시작점과 연결된 노드를 탐색하면서 노드의 끝까지 우선적으로 탐색하는 방식이다.  Breadth First Search는 넓이 우선 탐색이다. 시작점과 연결된 노드와 그에 인접한 노드를 탐색하는 방식이다.  이미지 출처: 위키미디아 파이썬 구현 import sysfrom collections import dequedef bfs(graph, start, N):    visited = [False] * (N+1)    queue = deque([start])    traversal = []    while queue:        node = queue.popleft()                if not visited[node]:            visited[node] = True            traversal.append(node)            queue.extend(graph[node])    return traversaldef dfs(graph, start, N):    visited = [False] * (N+1)    queue = deque([start])    traversal = []    while queue:        node = queue.pop()                if not visited[node]:            visited[node] = True            traversal.append(node)            queue.extend(graph[node])        return traversaldef solution():    # 입력값 읽기    K, N = map(int, sys.stdin.readline().split())    graph = [[] for _ in range(K+1)]    for _ in range(N):        start, dest = map(int, sys.stdin.readline().split())        graph[start].append(dest)    print(dfs(graph, 1, N))    print(bfs(graph, 1, N))if __name__ == \"__main__\":    solution()# 그래프:#    1 ㅡ 2#    | \\  | \\ #    7   3   4#      \\ | \\#        5   6## 입력 값:# 7 8# 1 7# 1 3# 1 2# 2 3# 2 4# 7 5# 3 5# 3 6# [1, 2, 4, 3, 6, 5, 7] DFS# [1, 7, 3, 2, 5, 6, 4] BFS더 자세한 방법은 포스트를 참고하자 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-DFS,-BFS/"
      },{
        "title": "구현",
        "excerpt":"구현/시뮬레이션은 아이디어를 코드로 작성할 수 있는지를 확인하는 문제다. 이 분류의 문제는 정말 많이 풀어보는 수 밖에 없다. 사고력과 사용하는 개발 언어에 친숙하다면 문제를 푸는 것은 어렵지 않다. 문제 리스트를 참고하자 ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84/"
      },{
        "title": "그래프 알고리즘",
        "excerpt":"그래프란 노드와 노드를 연결하는 간선으로 이루어진 (abstract) 추상적 데이터 구조다. 종류 그래프에 방향성이 있으면, ex. A to B, Directed 그래프고 없으면 Undirected 그래프다. 노드간 간선에 값이 있으면, ex. A to B 는 5 값이 필요하다, Weighted 그래프다. 노드 간 연결이 회전을 이루게 되면 사이클이 형성이 된다. ex. A -&gt; B -&gt; C -&gt; A 그래프내에 Spanning tree 란 최소한의 간선으로 모든 노드를 연결한 부분 그래프다. N개의 노드가 있을 때 최소 간선 개수는 N-1개다. MST와 최단거리 Minimum Spanning Tree란 Weighted 그래프에서 간선의 값의 합이 최소인 Spanning Tree를 뜻한다. 코테에서 MST를 이용한 알고리즘인 프림, 크루스칼 이 종종 나오기도 한다. 주로 A 지점에서 K지점까지 최단 거리를 구하는 문제가 나온다. (다익스트라 최단거리 구하기) 혹은 이의 응용 문제가 나온다. 이 포스트를 참고하자 Topological sort Topological Sort이란 Directed Acyclic (방향성이 있고 사이클이 없는) 그래프에서 노드 u 와 노드 v 를 표현하는 (u, v) 가 있을 때, 노드 u가 노드 v 보다 앞에 배치되도록 하는 정렬 방식이다. 예를 들면 A -&gt; B, A -&gt; C, C -&gt; B 라는 그래프가 있다면, Topological ordering을 한 결과는 A, C, B 가 된다. B에는 A, C에서 오는 두 개의 간선이 있기 때문에 A, C가 B 보다 먼저 배치 되어야 한다. 마찬가지로 C 는 A 에서 오는 간선이 있기 때문에 A 가 C 보다 먼저 배치 되어야 한다. ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
      },{
        "title": "문자열 알고리즘",
        "excerpt":"문자열 알고리즘은 사실 코테에서 내장 함수를 사용하면 되기 때문에 그렇게 큰 비중이 있지는 않지만 면접에서 나올 수 있기 때문에 복습을 해보자 문자열 알고리즘은 여러가지 있지만 Naive algorithm, KMP, Boyer Moore, Trie, Rabin Karp algorithm 을 알아보도록 하자 Naive algorithm Naive algorithm 방식은 문자열의 각 글자를 비교하며 찾아야 하는 패턴을 찾는 식이다. 패턴의 첫 글자를 문자열에서 찾고, 첫 글자가 있으면 그 다음 글자를 찾는 식이다. Best Case는 패턴의 첫 글자가 문자열에 없을 때 O(n) 비교를 하고 알고리즘이 끝난다. Worst Case는 패턴의 모든 글자 혹은 마지막 글자를 제외한 모든 글자가 문자열과 같다면 O(m*(n - m + 1)) 만큼 비교를 하게 된다. 파이썬 구현 import sysdef search(pattern, text):    M = len(pattern)    N = len(text)    for i in range(N - M + 1):        j = 0        # 현재 i 와 패턴이 맞는지 확인        while (j &lt; M):            if text[i + j] != pattern[j]:                break            j += 1                if j == M:            print(\"Pattern found at index: \", i)def solution():    # 입력값 읽기    text = sys.stdin.readline().strip()    pattern = sys.stdin.readline().strip()    search(pattern, text)if __name__ == \"__main__\":    solution()# AAAAAAAVAAVAVAVAVAVA# VAVA# Pattern found at index:  10# Pattern found at index:  12# Pattern found at index:  14# Pattern found at index:  16Knuth Morris Pratt Algorithm KMP 알고리즘은 찾고자 하는 패턴을 윈도우로 활용해서 문자열에서 결과 값을 찾는 방식이다. 핵심은 패턴의 모든 문자와 문자열의 모든 문자를 비교하는 방식이 아닌 필요한 부분만 비교하는 것이다. 이를 위해 패턴의 어떤 글자에서 비교를 할 것인지 기록하는 새로운 배열이 필요하다. KMP 알고리즘의 최악의 시간 복잡도는 O(n)이다. 출처: geeksforgeeks 비교하는 문자를 소문자로 표현하겠다txt[] = \"AAAAABAAABA\" pat[] = \"AAAA\"lps[] = {0, 1, 2, 3} i = 0, j = 0txt[] = \"aAAAABAAABA\" pat[] = \"aAAA\"txt[i] and pat[j] match, do i++, j++i = 1, j = 1txt[] = \"AaAAABAAABA\" pat[] = \"AaAA\"txt[i] and pat[j] match, do i++, j++i = 2, j = 2txt[] = \"AAaAABAAABA\" pat[] = \"AAaA\"pat[i] and pat[j] match, do i++, j++i = 3, j = 3txt[] = \"AAAaABAAABA\" pat[] = \"AAAa\"txt[i] and pat[j] match, do i++, j++i = 4, j = 4Since j == M, print pattern found and reset j,j = lps[j-1] = lps[3] = 3Here unlike Naive algorithm, we do not match first three characters of this window. Value of lps[j-1] (in above step) gave us index of next character to match.i = 4, j = 3txt[] = \"AAAAaBAAABA\" pat[] =  \"AAAa\"txt[i] and pat[j] match, do i++, j++i = 5, j = 4Since j == M, print pattern found and reset j,j = lps[j-1] = lps[3] = 3Again unlike Naive algorithm, we do not match first three characters of this window. Value of lps[j-1] (in above step) gave us index of next character to match.i = 5, j = 3txt[] = \"AAAAAbAAABA\" pat[] =   \"AAAa\"txt[i] and pat[j] do NOT match and j &gt; 0, change only jj = lps[j-1] = lps[2] = 2i = 5, j = 2txt[] = \"AAAAAbAAABA\" pat[] =    \"AAaA\"txt[i] and pat[j] do NOT match and j &gt; 0, change only jj = lps[j-1] = lps[1] = 1 i = 5, j = 1txt[] = \"AAAAAbAAABA\" pat[] =     \"AaAA\"txt[i] and pat[j] do NOT match and j &gt; 0, change only jj = lps[j-1] = lps[0] = 0i = 5, j = 0txt[] = \"AAAAAbAAABA\" pat[] =      \"aAAA\"txt[i] and pat[j] do NOT match and j is 0, we do i++.i = 6, j = 0txt[] = \"AAAAABaAABA\" pat[] =       \"aAAA\"txt[i] and pat[j] match, do i++ and j++i = 7, j = 1txt[] = \"AAAAABAaABA\" pat[] =       \"AaAA\"txt[i] and pat[j] match, do i++ and j++We continue this way...파이썬 구현 import sysdef kmp_search(pattern, text):    M = len(pattern)    N = len(text)    # 패턴의 가장 긴 prefix 와 suffix를 담을     # lps 배열을 만든다    lps = [0] * M    j = 0 # 패턴 index    # pattern에서 lps 배열을 만든다    compute_lps(pattern, M, lps)    i = 0 # text index    while i &lt; N:        if pattern[j] == text[i]:            i += 1            j += 1                if j == M:            print(\"Pattern found at index: \", str(i-j))            j = lps[j-1]                # mismatch after j matches        elif i &lt; N and pattern[j] != text[i]:            # don't match lps characters,            # they will match anyways            if j != 0:                j = lps[j-1]            else:                i += 1def compute_lps(pattern, M, lps):    prev_long_len = 0 # length of previous longest prefix suffix    lps[0] = 0 # lps[0] is always 0    i = 1    # loop from i to M - 1    while i &lt; M:        if pattern[i] == pattern[prev_long_len]:            prev_long_len += 1            lps[i] = prev_long_len            i += 1        else:            if prev_long_len != 0:                prev_long_len = lps[prev_long_len-1]            else:                lps[i] = 0                i += 1def solution():    # 입력값 읽기    text = sys.stdin.readline().strip()    pattern = sys.stdin.readline().strip()    kmp_search(pattern, text)if __name__ == \"__main__\":    solution()# AAAAAAAVAAVAVAVAVAVA# VAVA# Pattern found at index:  10# Pattern found at index:  12# Pattern found at index:  14# Pattern found at index:  16Boyer Moore Algorithm Boyer Moore 알고리즘은 KMP 나 Naive 알고리즘과 비슷하게 패턴을 preprocess해서 Bad Character Heuristic과 Good Suffix Heuristic을 생성한다. 이후 패턴과 텍스트를 비교할 때 두개의 Heuristic 중 더 적절한 것을 이용해서 비교를 한다. Boyer Moore 알고리즘은 다른 알고리즘과 다르게 패턴의 시작이 아니라 끝을 기준으로 비교를 한다. Worst case: 패턴의 모든 글자가 텍스트의 모든 글자와 같을 때 Time complexity: O(nm) Bad Character Heuristic Bad Character Heuristic 이란 패턴과 텍스트를 비교할때 특정 글자가 일치하지 않는 경우 패턴을 어떻게 움직일지 결정하는 것을 뜻한다. Bad Character Heuristic에서 2가지 경우가 있다.   불일치한 글자를 일치하도록 패턴을 움직인다 (패턴 내에 특정 글자가 있어야 한다)Text =      GCAATGCCTATGTGACCpattern =   TATGTG패턴의 끝에서부터 글자를 비교했을 때, 3번째 글자가 불일치 한다GCAaTGCCTATGTGACCTATgTG이때 패턴 내에 있는 \"A\"를 찾아서 패턴을 움직여 준다GCAaTGCCTATGTGACC  TaTGTG  불일치한 글자 다음에 패턴이 위치하도록 움직인다 (패턴 내에 특정 글자가 없을 경우)GCAATGCcTATGTGACC  TATGTg패턴의 끝에서 비교를 했을 때 \"g\" 와 \"c\" 가 불일치한다. 이때 \"c\" 가 패턴에 없으니패턴을 \"c\" 다음에 오도록 움직인다GCAATGCcTATGTGACC        TATGTG 파이썬 구현 (Bad character heuristic) 출처: geeksforgeeks import sysdef create_bad_character_heuristic(pattern, M):    # 모든 글자 값을 -1로 초기화 한다    badChar = [-1] * 256 # 256은 최대 글자 값    # 값을 채운다    for i in range(M):        badChar[ord(pattern[i])] = i        return badChardef boyer_moore_search(pattern, text):    M = len(pattern)    N = len(text)    # Bad Character Heuristic 생성    badChar = create_bad_character_heuristic(pattern, M)    # Text를 기준으로 Pattern을 움직일 변수 s    s = 0    while s &lt;= N-M:        j = M - 1        # Text와 Pattern이 계속 일치하면        # j 를 감소시킨다        while j&gt;=0 and pattern[j] == text[s+j]:            j -= 1                # 만약 현재 위치에 패턴이 존재하면        # 위의 while 반복문 후 j의 값은 -1이다        if j &lt; 0:            print(\"Pattern occur at index: \", s)            # 다음 연산을 하기 위해 현재 찾은 위치 다음으로            # 패턴을 움직인다 (2번째 케이스)            # s+M &lt; N 은 패턴이 텍스트에 끝에서 발견 됐을때를 위한 조건이다            s += (M-badChar[ord(text[s+M])] if s+M &lt; N else 1)        else:            # 불일치한 글자를 패턴 내에 글자와 일치하도록             # 패턴을 움직인다 (1번째 케이스)            s += max(1, j-badChar[ord(text[s+j])])def solution():    # 입력값 읽기    text = sys.stdin.readline().strip()    pattern = sys.stdin.readline().strip()    boyer_moore_search(pattern, text)if __name__ == \"__main__\":    solution()# 입력 값:# ABAAABCD# ABC# 출력 값:# Pattern occur at index:  4","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
      },{
        "title": "트리",
        "excerpt":"트리란 Root 노드로 시작해서 노드들이 부모/자식의 관계를 가지고 있는 abstract data type이다. 트리의 종류는 여러가지고 흔히 코딩 테스트 문제에서 많이 나오는 트리는 이진트리다 (Binary tree). 트리라는 데이터 타입 자체는 자주 쓰이며 트리를 탐색하는 방법, 트리의 균형을 잡는 방법 등 여러가지 알고리즘이 존재한다. 코테에서는 이진 트리와 이진트리를 탐색하고 노드 삽입/삭제 시 어떻게 되는지 정도만 알고 있으면 되는 것 같다. 트리 Tree 구조에는 Root node가 있고 종속되어 있는 node들이 있다. 일반적인 트리는 하나의 node에 여러개의 node가 종속이 될 수 있고 이진 트리에는 하나의 node에 최대 2개의 node만 종속 될 수 있다. 완성된 트리는 실제 사용시 root node를 통해서 접근을 하게 된다. 트리의 leaf를 제외한 모든 node가 2개의 node를 가지고 있으면 full binary tree다. 트리의 마지막 level을 제외한 모든 node가 2개의 node를 가지고 있고 모든 노드가 좌측에서부터 시작하면 complete binary tree다. \"\"\" full binary tree          a        /   \\       b     c     /   \\  /  \\    d     e f   g    complete binary tree          a        /   \\       b     c     /   \\  /      d     e f   \"\"\"트리의 탐색 트리의 탐색에는 3가지가 있다.   Post-order (left, right, root)  In-order (left, root, right)  Pre-order (root, left, right)이진탐색 트리 이진 탐색트리란 이진 트리지만 아래의 조건을 만족 시키는 트리다.   부모 노드보다 작은 수는 왼쪽에 배치한다  부모 노드보다 큰 수는 오른쪽에 배치한다탐색 (search) 이진 탐색 트리에서 아이템을 찾고자 한다면:   root의 키와 찾고자 하는 아이템을 비교한다  root가 아이템이면 root를 반환한다  root 보다 아이템이 크면 오른쪽 subtree를 반복적으로 찾는다  root 보다 아이템이 작으면 왼쪽 subtree를 반복적으로 찾는다삽입 (insertion) 이진 탐색 트리에서 아이템을 삽입하고자 한다면:   아이템의 위치를 이진 탐색 트리에서 탐색한다  탐색한 위치의 노드의 자식 노드로 현재 아이템을 넣어준다삭제 (deletion) 이진 탐색 트리에서 아이템을 삭제하고자 한다면 3가지 경우가 있다:   자식 노드가 없는 노드를 지울 때          그냥 노드를 지우면 된다        자식 노드가 하나 있는 노드를 지울 때          노드를 지우고 연결된 자식 노드를 원래 노드의 위치로 옮겨준다        자식 노드가 두 개 있는 노드를 지울 때          노드의 오른쪽 subtree에서 가장 낮은 값 혹은 노드의 왼쪽 subtree에서 가장 높은 값을 지우고자 하는 노드의 위치로 옮기고 노드를 지운다      ","categories": [],
        "tags": ["algorithm"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8A%B8%EB%A6%AC/"
      },{
        "title": "백준 10866번",
        "excerpt":"deque를 사용하면 된다 import sysfrom collections import dequedef exec_command(command, dq):    if command[0] == \"push_front\":            dq.appendleft(command[1])    if command[0] == \"push_back\":        dq.append(command[1])        if command[0] == \"pop_front\":        if len(dq) == 0:            print(-1)        else:            print(dq.popleft())        if command[0] == \"pop_back\":        if len(dq) == 0:            print(-1)        else:            print(dq.pop())        if command[0] == \"size\":        print(len(dq))        if command[0] == \"empty\":        if len(dq) &gt; 0:            print(0)        else:            print(1)        if command[0] == \"front\":        if len(dq) &gt; 0:            print(dq[0])        else:            print(-1)        if command[0] == \"back\":        if len(dq) &gt; 0:            print(dq[-1])        else:            print(-1)def solution():    N = int(sys.stdin.readline())    dq = deque([])    for _ in range(N):        command = sys.stdin.readline().split()        exec_command(command, dq)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10866%EB%B2%88/"
      },{
        "title": "백준 1463번",
        "excerpt":"아직 DP 점화식을 찾는 것이 익숙하지 않다. 참고한 블로그 import sysdef solution():    N = int(sys.stdin.readline())    dp = [0] * (N+1)    for i in range(2, N+1):        dp[i] = dp[i-1] + 1                if i%2 == 0 and dp[i] &gt; dp[i//2]+1:            dp[i] = dp[i//2]+1                if i%3 == 0 and dp[i] &gt; dp[i//3]+1:            dp[i] = dp[i//3] + 1        print(dp[N])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1463%EB%B2%88/"
      },{
        "title": "백준 11726번",
        "excerpt":"처음엔 어떻게 풀어야 할지 감이 안 잡혀서 구글을 해봤더니 문제의 규칙을 찾으면 쉽게 풀 수 있는 문제였다. 피보나치 수열을 DP로 작성해주면 문제는 풀린다. import sysdef solution():    n = int(sys.stdin.readline())    dp = [0] * 1001    dp[1] = 1    dp[2] = 2    for i in range(3, n+1):        dp[i] = dp[i-1] + dp[i-2]        print(dp[n] % 10007)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-11726%EB%B2%88/"
      },{
        "title": "백준 16935번",
        "excerpt":"천천히 풀면 생각보다 쉬운 문제다. zip을 활용하면 코드를 길게 짜지 않아도 된다. zip을 사용하면 아래와 같은 작업이 수행된다 [a, b] -&gt; [a, c][c, d] -&gt; [b, d]그리고 list()[::-1] 으로 하면 해당 리스트를 soft copy(해당 데이터 구조만 복사하고 같은 element를 가리킨다)해서 역순으로 나열한다. x = [    [1, 2],    [3, 4]]print(list(zip(*x)))# [#    (1, 3),#    (2, 4)# ]print(list(zip(*x[::-1]))) # 시계 방향 회전# [#    (3, 1)#    (4, 2)# ]print(list(zip(*x))[::-1]) # 반 시계 방향 회전# [#    (2, 4),#    (1, 3)# ]시간 복잡도는 O(n*m)인 것 같다 import sysdef extract_block(matrix, n_start, n_end, m_start, m_end):    block = []    for i in range(n_start, n_end):        row = []        for j in range(m_start, m_end):            row.append(matrix[i][j])        block.append(row)    return blockdef extract_blocks(matrix):    a_block = extract_block(matrix, 0, len(matrix)//2, 0, len(matrix[0])//2)    b_block = extract_block(matrix,  0, len(matrix)//2, (len(matrix[0])//2), len(matrix[0]))    d_block = extract_block(matrix, len(matrix)//2, len(matrix), 0, len(matrix[0])//2)    c_block = extract_block(matrix, len(matrix)//2, len(matrix), len(matrix[0])//2, len(matrix[0]))    return a_block, b_block, c_block, d_blockdef upside_down(matrix):    return list(reversed(matrix))def symmetric_y_axis(matrix):    return [list(reversed(row)) for row in matrix]def rotate_right(matrix):    return [list(v) for v in zip(*matrix[::-1])]def rotate_left(matrix):    return [list(v) for v in zip(*matrix)][::-1]def shuffle_blocks_clockwise(matrix):    a, b, c, d = extract_blocks(matrix)    for i in range(len(d)):        d[i].extend(a[i])        c[i].extend(b[i])    temp = [*d, *c]    return tempdef shuffle_blocks_anti_clockwise(matrix):    a, b, c, d = extract_blocks(matrix)    for i in range(len(d)):        b[i].extend(c[i])        a[i].extend(d[i])    temp = [*b, *a]    return tempdef process_command(c, matrix):    if c == 1:        # 상하 반전        return upside_down(matrix)    if c == 2:        # 좌우 반전        return symmetric_y_axis(matrix)    if c == 3:        # 오른쪽으로 90도        return rotate_right(matrix)    if c == 4:        # 왼쪽으로 90도        return rotate_left(matrix)    if c == 5:        # group 1-&gt; 2-&gt; 3-&gt; 4-&gt; 1        return shuffle_blocks_clockwise(matrix)    if c == 6:        # group 1-&gt; 4-&gt; 3-&gt; 2-&gt; 1        return shuffle_blocks_anti_clockwise(matrix)def solution():    n, m, r = map(int, sys.stdin.readline().split())    matrix = [] * n    for _ in range(n):        row = list(map(int, sys.stdin.readline().split()))        matrix.append(row)            # run program    commands = list(map(int, sys.stdin.readline().split()))    for c in commands:        matrix = process_command(c, matrix)            for i in range(len(matrix)):        for j in range(len(matrix[i])):            print(matrix[i][j], end=\" \")        print() # 줄 바꿈if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-16935%EB%B2%88/"
      },{
        "title": "백준 1697번",
        "excerpt":"노드 정보가 없는데 그래프를 어떻게 만들지? 라는 생각을 먼저 했었다. 구글링을 빠르게 해보니 bfs를 하면서 노드를 생성하면 되는 것이었다. 참고한 블로그 import sysfrom collections import dequedef bfs(start, k, visited):    count = 0    queue = deque([[start, count]])        while queue:        start = queue.popleft()        position = start[0]        count = start[1]        if not visited[position]:            visited[position] = True            if position == k:                return count            count += 1            if (position*2) &lt;= 100000:                queue.append([position*2, count])            if (position+1) &lt;= 100000:                queue.append([position+1, count])            if (position-1) &gt;= 0:                queue.append([position-1, count])    return countdef solution():    n, k = map(int, sys.stdin.readline().split())    visited = [False] * 100001    print(bfs(n, k, visited))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1697%EB%B2%88/"
      },{
        "title": "백준 2529번",
        "excerpt":"처음 생각했던 접근방식이 한번에 통과돼서 당황했다. 접근 방식: 브루트포스   주어진 k+1 개의 숫자 조합으로 가능한 모든 k개 permutation을 구한다  각 permutation 마다 부호를 확인해서 조건에 부합하는 것만 possibilities 배열에 저장한다  possibilities 배열에서 가장 마지막이랑 첫 번째가 답이다만약 시간 초과가 떴다면 줄일 수 있는 곳:   모든 permutation을 구하는 것은 시간 낭비다. 백트래킹을 사용해서 조건에 맞는 조합만 찾으면 된다. (문제는 백트래킹을 아직 잘 못한다)  possibilities 배열을 가지고 있는 것 보다 제일 큰 조합, 작은 조합만 보유하면 된다시간 복잡도:   permutations 과정이 O(n!). n은 nums의 길이  이후 for loop이 O(m). m은 전체 조합의 개수  이후 print 에서 join 과 generator 문이 O(k). k는 possibilities[x] 의 길이  즉 전체 코드의 시간 복잡도는 O(n! + m + k) -&gt; O(n!)인 것 같다import sysfrom itertools import permutationsdef process_sign(sign, x, y):    if sign == \"&lt;\":        return x &lt; y    else:        return x &gt; ydef check_perm(perm, signs):    for i in range(1, len(perm)):        sign_idx = i-1        if not process_sign(signs[sign_idx], perm[i-1], perm[i]):            return False    return Truedef solution():    nums = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}    max_num = int(sys.stdin.readline())    signs = sys.stdin.readline().split()        perms = permutations(nums, max_num+1)    possibilities = []    for perm in perms:        if check_perm(perm, signs):            possibilities.append(perm)        print(\"\".join(str(v) for v in possibilities[-1]))    print(\"\".join(str(v) for v in possibilities[0]))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-2529%EB%B2%88/"
      },{
        "title": "백준 11727번",
        "excerpt":"일전에 풀었던 피보나치 수열 문제 와 비슷한 것 같아서 N 사이의 연관식을 중점으로 접근했다. 찾다보니 Jacobsthal Number라는 것이 존재했는데 여기서 나오는 공식 N = N-1 + (2*N-2)를 DP에 대입하면 풀리는 문제였다. import sysdef solution():    n = int(sys.stdin.readline())    if n == 1:        print(1)        return            dp = [0] * (n+1)    dp[1] = 1    dp[2] = 3        for i in range(3, n+1):        dp[i] = dp[i-1] + (2*dp[i-2])    print(dp[n] % 10007)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-11727%EB%B2%88/"
      },{
        "title": "백준 1248번",
        "excerpt":"문제가 이해가 안돼서 구글링을 했다. 참고한 블로그 로직을 그대로 구현해서 Python3로 제출했는데 시간초과가 뜨길래 PyPy3로 제출하니까 통과가 됐다. Python3가 느리다는 것을 다시 한 번 느꼈다. import sysans = []num = int(sys.stdin.readline())matrix = [[0] * num for _ in range(num)]commands = list(sys.stdin.readline())def possible(idx):    sum = 0    for i in range(idx, -1, -1):        sum += ans[i]        if matrix[i][idx] == \"+\" and sum &lt;= 0:            return False        if matrix[i][idx] == \"-\" and sum &gt;= 0:            return False        if matrix[i][idx] == \"0\" and sum != 0:            return False        return Truedef process(idx):    if idx == num:        print(\" \".join(map(str, ans)))        exit(0)        for i in range(-10, 11):        ans.append(i)        if possible(idx):            process(idx+1)                ans.pop()k = 0for i in range(num):    for j in range(i, num):        matrix[i][j] = commands[k]        k += 1process(0)","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1248%EB%B2%88/"
      },{
        "title": "백준 13023번",
        "excerpt":"처음엔 문제를 대충 봐서 Cycle을 찾는 문제인 줄 알았다. 다시 보니 깊이를 구하는 문제였다. 주어진 조건을 만족하려면 깊이가 4 이상이면 된다. import sysdef dfs(idx, number): # number가 깊이    if number == 4:        print(1)        exit(0)        for i in graph[idx]:        if not visited[i]:            visited[i] = True            dfs(i, number+1)            visited[i] = Falsedef solution():    global graph    global visited    nodes, relations = map(int, sys.stdin.readline().split())    graph = {i: [] for i in range(nodes)}     for _ in range(relations):        start, to = map(int, sys.stdin.readline().split())        graph[start].append(to)        graph[to].append(start)    visited = [False] * nodes    for i in range(nodes):        visited[i] = True        dfs(i, 0)        visited[i] = False    print(0)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-13023%EB%B2%88/"
      },{
        "title": "백준 10972번",
        "excerpt":"처음 접근 방식은 itertools.permutations를 써서 모든 순열을 구한 뒤 주어진 순열을 찾을 때까지 모든 순열을 반복문으로 탐색하고 결과값을 내는 방식을 사용했다. 이렇게 하려면 주어진 순열외에 같은 길이의 다른 순열이 필요하다. 이유는 순서를 따져서 모든 순열을 찾아야하기 때문이다. 문제는 이렇게 하면 메모리 초과가 뜨게 된다. 그래서 내린 결론은 inplace 알고리즘을 짜던가 아니면 최소한 O(n)을 카피하는 것이 아닌 일부만 카피하는 알고리즘을 짜야한다는 것이었다. 약 30분 동안 머리를 싸맨 결과 답을 못 찾아서 구글링을 했는데 이 블로그를 참고해서 풀었다. import sysdef solution():    n = int(sys.stdin.readline())    arr = list(map(int, sys.stdin.readline().split()))        k = -1    # k 최대값 구하기    for i in range(n-1):        if arr[i] &lt; arr[i+1]:            k = i        if k == -1:        print(-1)    else:        # m 최대값 구하기        for j in range(k+1, n):            if arr[k] &lt; arr[j]:                m = j                # k, m swap        arr[k], arr[m] = arr[m], arr[k]        # k 이후 sort        temp = arr[k+1:]        temp.sort()        answer = arr[:k+1] + temp            print(\" \".join(map(str, answer)))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10972%EB%B2%88/"
      },{
        "title": "백준 1260번",
        "excerpt":"DFS/BFS만 구현하면 풀린다 import sysdef dfs(graph, start, nodes):    visited = [False] * (nodes+1)    queue = [start]    traversed = []    while queue:        node = queue.pop()        if not visited[node]:            visited[node] = True            traversed.append(node)            queue.extend(sorted(graph[node], reverse=True))    return traverseddef bfs(graph, start, nodes):    visited = [False] * (nodes+1)    queue = [start]    traversed = []    while queue:        node = queue.pop(0)        if not visited[node]:            visited[node] = True            traversed.append(node)            queue.extend(sorted(graph[node]))    return traverseddef solution():    nodes, edges, start = map(int, sys.stdin.readline().split())    graph = [[] for _ in range(nodes+1)]    for _ in range(1, edges+1):        frm, to = map(int, sys.stdin.readline().split())        graph[to].append(frm)        graph[frm].append(to)        print(*dfs(graph, start, nodes))    print(*bfs(graph, start, nodes))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1260%EB%B2%88/"
      },{
        "title": "백준 13913번",
        "excerpt":"1697번의 응용 문제다. 깊이 뿐만 아니라 탐색 경로도 구해야하는 문제였는데 생각보다 어려웠다. 결국 구글링을 통해서 풀었다. 코드를 이해하니까 visited 배열은 필요가 없다는 것을 깨달았다. import sysfrom collections import dequedef bfs(start, end, matrix):    queue = deque([start])    # 시작점은 0의 깊이를 가진다    matrix[start][0] = 0    while queue:        item = queue.popleft()        if item == end:            return matrix[end][0]                for i in (item*2, item+1, item-1):            if 0 &lt;= i &lt; 100001:                if matrix[i][0] == -1:                    matrix[i][0] = matrix[item][0] + 1                    matrix[i][1] = item                    queue.append(i)def solution():    n, k = map(int, sys.stdin.readline().split())    matrix = [[-1, -1] for _ in range(100002)]     # matrix[i][0]: 해당 지점까지 걸린시간 (깊이)    # matrix[i][1]: 바로 전 노드    print(bfs(n, k, matrix)) # 깊이    path = deque([k])    # 이동경로 추적    while True:        if matrix[k][1] != -1:            path.appendleft(matrix[k][1])            k = matrix[k][1]        else:            break        print(\" \".join(map(str, path)))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-13913%EB%B2%88/"
      },{
        "title": "백준 16926번",
        "excerpt":"보기에는 쉬워 보였다. 그랬다. 정해놓은 시간안에 배열을 돌려놓을 방법을 구현해내지 못해서 구글링을 했다. 어떻게 이런 생각을 할 수 있는거지… 참고한 블로그 import sysfrom collections import dequefrom pprint import pprintdef rotation(n, m, r, matrix):    for k in range(0, min(n,m)//2):        queue = deque([])        sx, sy = k, k        cnt = 0        val = sy + (m-(k*2))        for j in range(sy, val):            queue.append(matrix[sx][j])            cnt += 1                val = sx + 1 + (n-2) - (k*2)        for i in range(sx+1, val):            queue.append(matrix[i][m-1-k])            cnt += 1                val = sy + (m-(k*2)) - 1        for j in range(val, sy-1, -1):            queue.append(matrix[n-k-1][j])            cnt += 1                val = sx + (n-2) - k*2        for i in range(val, sx, -1):            queue.append(matrix[i][sy])            cnt += 1                for i in range(r%cnt):            val = queue.popleft()            queue.append(val)                val = sy + (m - (k*2))        for j in range(sy, val):            matrix[sx][j] = queue.popleft()                val = sx + 1 + (n-2) - k*2        for i in range(sx+1, val):            matrix[i][m-1-k] = queue.popleft()                val = sy + (m-(k*2)) - 1        for j in range(val, sy-1, -1):            matrix[n-k-1][j] = queue.popleft()                val = sx + (n-2) - k*2        for i in range(val, sx, -1):            matrix[i][sy] = queue.popleft()def solution():    n, m, r = map(int, sys.stdin.readline().split())    matrix = []    for _ in range(n):        row = list(map(int, sys.stdin.readline().split()))        matrix.append(row)    rotation(n, m, r, matrix)    for row in matrix:        print(*row)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-16926%EB%B2%88/"
      },{
        "title": "백준 10973번",
        "excerpt":"전에 풀었던 “다음 순열 구하기 (10972번)” 문제와 알고리즘은 같다. 다만 비교하는 부등호를 바꿔주고 마지막에 temp 배열을 거꾸로 정렬해주면 된다. import sysdef solution():    n = int(sys.stdin.readline())    arr = list(map(int, sys.stdin.readline().split()))        k = -1    # k 최대값 구하기    for i in range(n-1):        if arr[i] &gt; arr[i+1]:            k = i        if k == -1:        print(-1)    else:        # m 최대값 구하기        for j in range(k+1, n):            if arr[k] &gt; arr[j]:                m = j                # k, m swap        arr[k], arr[m] = arr[m], arr[k]        # k 이후 sort        temp = arr[k+1:]        temp.sort(reverse=True)        answer = arr[:k+1] + temp            print(\" \".join(map(str, answer)))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10973%EB%B2%88/"
      },{
        "title": "백준 11052번",
        "excerpt":"문제는 이해를 했는데 DP로 짜는 방법을 몰라서 결국 구글링했다.참고 블로그 import sys    def solution():    n = int(sys.stdin.readline())    dp = [0] * (n+1)    packs = [0] + list(map(int, sys.stdin.readline().split()))    dp[1] = packs[1]    for i in range(2, n+1):        for j in range(1, i+1):            if dp[i] &lt; dp[i-j] + packs[j]:                dp[i] = dp[i-j] + packs[j]        print(dp[n])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-11052%EB%B2%88/"
      },{
        "title": "백준 11724번",
        "excerpt":"dfs를 써서 모든 노드를 탐색하면 된다. 단, 탐색할때 노드는 방문 된 적이 없어야 한다. 이렇게 하면 전체 연결된 노드를 찾을 수 있다. import sysdef dfs(graph, start, visited, temp):    q = [start]    while q:        node = q.pop()        if not visited[node]:            visited[node] = True            temp.append(node)            q.extend(graph[node])        return tempdef solution():    n, m = map(int, sys.stdin.readline().split())    graph = [[] for _ in range(n+1)]    # [[]] * (n+1) 로는 안된다. 안에 있는 \"[]\"가 중복됨.    # 이유는 안쪽의 []가 soft copy 되는 것으로 추정됨    visited = [False] * (n+1)    for _ in range(m):        frm, to = map(int, sys.stdin.readline().split())        graph[frm].append(to)        graph[to].append(frm)        connected = []    for node in range(1, n+1):        if not visited[node]:            temp = []            connected.append(dfs(graph, node, visited, temp))        print(len(connected))if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-11724%EB%B2%88/"
      },{
        "title": "백준 10974번",
        "excerpt":"10972번에서 풀었던 다음 순열 찾기 알고리즘을 반복문을 통해 사용해봤다. import sysdef get_next_perm(arr, n):    k = -1    # k 최대값 구하기    for i in range(n-1):        if arr[i] &lt; arr[i+1]:            k = i        if k == -1:        return -1    else:        # m 최대값 구하기        for j in range(k+1, n):            if arr[k] &lt; arr[j]:                m = j                # k, m swap        arr[k], arr[m] = arr[m], arr[k]        # k 이후 sort        temp = arr[k+1:]        temp.sort()        answer = arr[:k+1] + temp            return answerdef solution():    n = int(sys.stdin.readline())    arr = [i for i in range(1, n+1)]    while True:        print(\" \".join(map(str, arr)))        arr = get_next_perm(arr, n)        if arr == -1:            breakif __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10974%EB%B2%88/"
      },{
        "title": "백준 14499번",
        "excerpt":"처음엔 class를 만들어서 구현했는데 direction에 따라 주사위의 위, 아래, 좌, 우 변경 로직을 까먹고 구현을 안해서 시간내에 못 풀었다. 결국 구글링의 도움을 받았다. 참고한 블로그 import sysdef roll(direction):    # 방향에 따른 주사위 값의 위치 변경    if direction == 1:        dice[1], dice[3], dice[4], dice[6] = dice[3], dice[6], dice[1], dice[4]        elif direction == 2:        dice[1], dice[3], dice[4], dice[6] = dice[4], dice[1], dice[6], dice[3]        elif direction == 3:        dice[1], dice[2], dice[5], dice[6] = dice[2], dice[6], dice[1], dice[5]        elif direction == 4:        dice[1], dice[2], dice[5], dice[6] = dice[5], dice[1], dice[6], dice[2]def get_direction(direction):    if direction == 1: # east        return 0, 1    if direction == 2: # west        return 0, -1    if direction == 3: # north        return -1, 0    if direction == 4: # south        return 1, 0def solution():    global dice    n, m, x, y, k = map(int, sys.stdin.readline().split())    board = [[] for _ in range(n)]    for i in range(n):        row = list(map(int, sys.stdin.readline().split()))        board[i].extend(row)        commands = list(map(int, sys.stdin.readline().split()))        dice = [0, 0, 0, 0, 0, 0, 0]    for c in commands:        dx, dy = get_direction(c)        if 0 &lt;= x+dx &lt; n and 0 &lt;= y+dy &lt; m:            x += dx            y += dy                        roll(c)            if board[x][y] != 0:                dice[1] = board[x][y]                board[x][y] = 0            else:                board[x][y] = dice[1]            print(dice[6])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14499%EB%B2%88/"
      },{
        "title": "백준 16194번",
        "excerpt":"11052번과 알고리즘은 같다. 점화식에서 최소값을 계산하면 된다. import sys    def solution():    n = int(sys.stdin.readline())    dp = [0] + [sys.maxsize] * (n)    packs = [0] + list(map(int, sys.stdin.readline().split()))    for i in range(1, n+1):        for j in range(1, i+1):            dp[i] = min(dp[i], dp[i-j] + packs[j])        print(dp[n])if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-16194%EB%B2%88/"
      },{
        "title": "백준 16927번",
        "excerpt":"16926번이랑 똑같다. 뭐가 다른가 했더니 인풋값의 R의 최대값이 변한 것 말고는 없었다. import sysfrom collections import dequefrom pprint import pprintdef rotation(n, m, r, matrix):    for k in range(0, min(n,m)//2):        queue = deque([])        sx, sy = k, k        cnt = 0        val = sy + (m-(k*2))        for j in range(sy, val):            queue.append(matrix[sx][j])            cnt += 1                val = sx + 1 + (n-2) - (k*2)        for i in range(sx+1, val):            queue.append(matrix[i][m-1-k])            cnt += 1                val = sy + (m-(k*2)) - 1        for j in range(val, sy-1, -1):            queue.append(matrix[n-k-1][j])            cnt += 1                val = sx + (n-2) - k*2        for i in range(val, sx, -1):            queue.append(matrix[i][sy])            cnt += 1                for i in range(r%cnt):            val = queue.popleft()            queue.append(val)                val = sy + (m - (k*2))        for j in range(sy, val):            matrix[sx][j] = queue.popleft()                val = sx + 1 + (n-2) - k*2        for i in range(sx+1, val):            matrix[i][m-1-k] = queue.popleft()                val = sy + (m-(k*2)) - 1        for j in range(val, sy-1, -1):            matrix[n-k-1][j] = queue.popleft()                val = sx + (n-2) - k*2        for i in range(val, sx, -1):            matrix[i][sy] = queue.popleft()def solution():    n, m, r = map(int, sys.stdin.readline().split())    matrix = []    for _ in range(n):        row = list(map(int, sys.stdin.readline().split()))        matrix.append(row)    rotation(n, m, r, matrix)    for row in matrix:        print(*row)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-16927%EB%B2%88/"
      },{
        "title": "Microsoft Mesh",
        "excerpt":"어릴적 스타워즈를 통해 Sci-Fi 에 입문을 했다. 광선검, 포스, R2D2, 홀로그램, 우주 탐험 등 너무 흥미로운 요소들이 많아서 맨날 비디오를 돌려봤던 기억이있다. 이후 15년 정도가 흘러서 스티븐 스필버그 아저씨의 Ready Player One을 보고 스타워즈를 돌려보던 7살 무렵의 기억이 떠올랐다. 그리고 궁금해졌다. AR/VR 기술이 나온지는 10년도 넘었는데 아이언맨의 자비스, 스타워즈의 홀로그램, Ready Player One 속 가상 세계는 어디까지 개발이 됐을까. 이때 검색을 열심히 한 결과 Facebook, Google, Microsoft, Samsung 같은 대기업들이 Meta-verse와 MR/VR/AR 기술에 투자를 한다는 것 정도는 알아낼 수 있었다. 그리고 추후에 창업(?) 비스무리 한 것을 한다면 메타버스 분야도 괜찮겠다라는 생각을 했다. 사실 이 포스트를 쓰게 된 것은 오늘 뜬 기사 때문이다. 오늘 마이크로소프트가 Microsoft Mesh를 발표했다. Microsoft Mesh는 개발자들을 위한 툴이다. Mixed reality 앱을 만들 수 있게 해주는 플랫폼이라고 보면 된다. Mesh를 사용하면 화상 미팅을 3D로 할 수 있다. 심지어 상대방이 홀로그램이고 작업도 같이 할 수 있다. Microsoft Mesh 소개 영상   나는 개발자니까 조금 더 테크니컬 한 것을 알고 싶어서 관련 기사를 찾다가 마소 테크 블로그에 잘 정리된 글을 봤다. 참고. 이 포스트의 나머지는 이 테크 블로그를 의역한 것에 불과하다. 기사를 간단히 요약하자면, 마소는 MR의 도약을 주의깊게 봤고 투자할 가치가 있다고 판단을 했다. 이후 MR의 기술적 한계를 보고 이를 극복하기 위해 Mesh를 개발했다는 것을 알 수 있다. 여기서 중요한 것은 마소가 Mesh를 활용해 새로운 MR 소프트웨어를 만들어 낸 것이 아니라 하나의 서비스로 Azure 기반 앱/웹에서 쓸 수 있도록 오픈 했다는 것이다. 마소가 Mesh를 통해 이루고자 하는 것은 MR 개발자들을 Azure로 끌어오기 위한 것임을 알 수 있다. (물론 다른 클라우드 업체에서 비슷한 플랫폼을 추후에 지원할 것으로 보인다) 확실히 마소가 최근 들어서 개발자들을 위한 움직임을 많이 보여주고 있다. 마소가 생각한 멀티 유저 환경에서 MR의 문제점은 크게 4가지였다.   사람을 MR 환경에서 “사람답게” 구현하려면 상당한 시간과 자원이 든다  서로 다른 기기에서 공유된 MR 시공간에 홀로그램을 안정적으로 표현하는 것은 기술적으로 상당히 어렵다  현재 개발자들이 사용하는 포맷을 고퀄리티 3D MR 공간으로 불러오기 힘들다  사람의 행동이나 표현을 MR 공간에서 동기화 하는 것은 어렵다일단 마소의 Mesh는 이 문제점들을 해결하는데 포커스를 맞췄다. Mesh는 크게 3가지 기능으로 구성됐다.   Multi-device를 지원한다.  개발자 플랫폼을 지원한다  Mesh-enabled Apps를 지원한다.Multi-device 지원 HoloLens, Oculus 부터 시작해서 스마트폰과 PC까지 지원을 한다. 개발자 플랫폼 지원 개발자 플랫폼은 Azure를 기반으로 작동하며 유저 인증/인가는 Azure Active Directory 와 Microsoft Accounts 등을 통해서 할 수 있다. 개발자로서 개발에만 집중 할 수 있도록 core infra의 billing이나 오디오/비디오 처리, 또는 live-state 관리를 신경쓰지 않아도 된다고 한다. 이 같은 코어 인프라 외에도 앞서 말한 멀티 유저 환경에서 MR의 문제점을 해결하기 위한 기능들도 있다.       Immersive presence: 멀티 유저 시나리오에서 가장 중요한 기능인 “사람을 어떻게 표현하는가?” 를 담당한다고 볼 수 있다. 기본적으로 3D 아바타가 있고 사용하는 기기에 따라서 photorealistic holoportation을 사용할 수도 있다. Photorealistic holoportation은 외부 센서를 사용해서 구현이 되며 MR 공간에 사용자를 홀로그램 형식으로 표현할 수 있다.         Spatial maps:  Mesh 이전에 공유된 MR 공간에 특정 홀로그램 물체를 표현하려면 연결된 각 기기의 로컬 MR 환경에 맞게 구현이 됐어야 했다. 그리고 구현된 물체는 사용하는 기기와 주변 환경에 따라 일정하지 않을 때가 많았다.  하지만 Mesh를 사용하면 각 기기의 로컬 환경을 읽고 캐시해서 모든 기기가 같은 MR 공간을 사용하도록 한다고 한다. 장점은 홀로그램 물체를 좀 더 명확하게 위치 시킬 수 있고 모두가 똑같은 MR 환경에 있기 때문에 각 기기에서 표현되는 차이가 없다고 봐도 되는 것 같다. 천…천재들이네          Holographic rendering: Mesh의 가장 큰 장점 중 하나는 렌더링 시 로컬 stand-alone을 할지 아니면 마소의 클라우드 인프라를 사용할지 정할 수 있다는 것이다. 이는 개발자에게 Latency (속도) vs Fidelity (퀄리티)의 자유를 준다. (MR 개발자가 아니라 정확히는 모르지만 로컬 stand-alone 렌더링 기법은 Mesh 앱을 구동하는 기기의 컴퓨팅 파워를 사용해서 렌더하는 것 같다)또한 이미 사용되고 있는 대부분의 3D 파일 포맷을 지원한다고 한다. 즉, 현재 개발자들이 가지고 있는 3D 데이터를 Mesh의 MR 환경에 홀로그램으로 구현이 가능하다.         Multi user sync: MR의 핵심은 물리적으로 떨어져 있어도 같은 시공간에 있다는 경험을 하는 것이다. Mesh는 Multi user sync를 통해 유저가 세계 어느 곳에 있든 &lt;= 100ms 의 latency를 자랑한다고 한다.   또한 Mesh는 cross-platform SDK를 지원한다. 현재는 Unity와 C++, C#을 지원하고 추후에 Unreal, Babylon, React Native도 지원할 것이라고 한다. Mesh-enabled App 이미 Mesh를 활용한 몇개의 앱들이 마켓플레이스에 있다. 앞으로 파트너들과 협력해 더 많은 앱들을 개발할 예정이라고 한다. 결론 Mesh는 MR 개발을 쉽게 해주는 플랫폼이고 MR, VR, AR, Metaverse 에 관심이 있는 개발자라면 한 번 시도해볼만 하다고 생각한다. 나중에 취업을 하고 사이드 프로젝트로 이쪽 분야를 공부해도 괜찮겠다고 생각한다. ","categories": [],
        "tags": ["MR"],
        "url": "https://json9512.github.io/blog/Microsoft-Mesh/"
      },{
        "title": "백준 14226번",
        "excerpt":"처음 접해보는 유형의 문제여서 구글링을 해봤다. BFS와 DP를 동시에 사용하는 식으로 풀어야한다. 참고 import sysfrom collections import dequefrom pprint import pprintdef solution():    n = int(sys.stdin.readline())    # visited를 2d 배열로 dp와 같이 사용    visited = [[False]*(n+1) for _ in range(n+1)]        q = deque()    q.append([1, 0])    visited[1][0] = 0    while q:        screen, clipboard = q.popleft()        if not visited[screen][screen]: # 1번 task            visited[screen][screen] = visited[screen][clipboard] + 1            q.append([screen, screen])        if screen+clipboard &lt;= n and not visited[screen+clipboard][clipboard]: # 2번            visited[screen+clipboard][clipboard] = visited[screen][clipboard] + 1            q.append([screen+clipboard, clipboard])        if screen-1 &gt;= 0 and not visited[screen-1][clipboard]:            visited[screen-1][clipboard] = visited[screen][clipboard] + 1            q.append([screen-1, clipboard])    result = visited[n][1]    for i in range(1, n):        if visited[n][i]:            result = min(result, visited[n][i])    print(result)    if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14226%EB%B2%88/"
      },{
        "title": "백준 15662번",
        "excerpt":"분명 아이디어는 쉬운데 for의 조건을 잘 처리하지 않으면 풀리지 않는다. 생각보다 시간을 많이 소요한 문제. 추상적으로 생각만하고 풀지 말고 종이랑 연필을 활용하자. import sysfrom collections import deque# 2 왼, 6 오른def rotate_gear(value, direction):    if direction == 1:        last_item = value.pop()        value.appendleft(last_item)    elif direction == -1:        first_item = value.popleft()        value.append(first_item)    return valuedef solution():    # 재귀가 안됨    n = int(sys.stdin.readline())    gears = []    for i in range(1, n+1):        # n = 0, s = 1        val = deque(list(sys.stdin.readline().strip()))        gears.append(val)    commands = int(sys.stdin.readline())    for _ in range(commands):        gear_id, direction = map(int, sys.stdin.readline().split())        rotations = [0] * n        rotations[gear_id-1] = direction        for i in range(gear_id-1, n-1):            if gears[i][2] != gears[i+1][6]:                rotations[i+1] = -rotations[i]            else:                break # 조건이 맞지 않으면 더이상 다음 기어를 돌릴 필요가 없다                for i in range(gear_id-1, 0, -1):            if gears[i][6] != gears[i-1][2]:                rotations[i-1] = -rotations[i]            else:                break                for i in range(n):            if rotations[i]:                gears[i] = rotate_gear(gears[i], rotations[i])            cnt = 0    for gear in gears:        if gear[0] == \"1\":            cnt += 1            print(cnt)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15662%EB%B2%88/"
      },{
        "title": "백준 14503번",
        "excerpt":"문제의 조건을 잘 확인해보면 왼쪽으로 탐색한다가 있다. 하지만 잘 생각해보면 상하좌우를 탐색할때 빈 공간이 있으면 로봇은 움직이거나 방향을 수정하기 때문에 왼쪽 탐색을 위한 처리는 생략해도 된다. 분명 구현을 했는데 로봇이 같은 자리를 계속 돌길래 결국 구글링을 했다.참고 import sysdef solution():    n, m = map(int, sys.stdin.readline().split())    y, x, d = map(int, sys.stdin.readline().split())    direction = [[0, -1], [-1, 0], [0, 1], [1, 0]]    matrix = []    for _ in range(n):        row = list(map(int, sys.stdin.readline().split()))        matrix.append(row)    break_free = False    while not break_free:        matrix[y][x] = 2 # 방문 처리        while True:            nothing_to_clean = True            for i in range(4): # 4 방면 체크                nx = x + direction[d][1]                ny = y + direction[d][0]                d = d-1 if d != 0 else 3                if matrix[ny][nx] == 0: # 미방문 노드가 있다                    x, y = nx, ny                    nothing_to_clean = False                    break            if nothing_to_clean: # 사면에 미방문 노드가 없다                if d == 0:                    rx, ry = x, y+1                if d == 1:                    rx, ry = x-1, y                if d == 2:                    rx, ry = x, y-1                if d == 3:                    rx, ry = x+1, y                                if matrix[ry][rx] == 1: # 뒤로 움직일 수 없다                    break_free = True                    break                else:                    x, y = rx, ry            else:                break    cnt = 0    for i in matrix:        cnt += i.count(2)    print(cnt)    if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-14503%EB%B2%88/"
      },{
        "title": "백준 10819번",
        "excerpt":"itertools.permutations를 사용해서 모든 조합을 구한 다음, 주어진 공식대로 각 배열의 값을 구하고, 마지막으로 배열의 값들 중 최대값을 출력하면 된다. import sysfrom itertools import permutationsdef calc_arr(arr):    summed = 0    for i in range(1, len(arr)):        summed += abs(arr[i]-arr[i-1])    return summeddef solution():    n = int(sys.stdin.readline())    arr = list(map(int, sys.stdin.readline().split()))        perms = permutations(arr)    max_val = 0    for p in perms:        temp = calc_arr(p)        if max_val &lt; temp:            max_val = temp    print(max_val)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-10819%EB%B2%88/"
      },{
        "title": "백준 13549번",
        "excerpt":"BFS를 사용하는데 queue를 heapq로 구성했다. min-heap을 사용해서 특정 노드까지 가는 거리가 가장 적은 값을 기준으로 우선순위 큐를 사용하면 풀린다. import sysimport heapqdef bfs(start, end):    queue = []    heapq.heappush(queue, [0, start])    visited = [False] * (100002)    visited[start] = True    while queue:        item, position = heapq.heappop(queue)        if position == end:            return item                if 0 &lt;= position*2 &lt; 100001 and  not visited[position*2]:            visited[position*2] = True            heapq.heappush(queue, [item, position*2])                if 0 &lt;= position+1 &lt; 100001 and not visited[position+1]:            visited[position+1] = True            heapq.heappush(queue, [item+1, position+1])                if 0 &lt;= position-1 &lt; 100001 and not visited[position-1]:            visited[position-1] = True            heapq.heappush(queue, [item+1, position-1])def solution():    n, k = map(int, sys.stdin.readline().split())    depth = bfs(n, k) # 깊이    print(depth)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-13549%EB%B2%88/"
      },{
        "title": "백준 15990번",
        "excerpt":"DP가 아직 익숙하지 않아서 구글링을 했다. 참고 import sysdef solution():    tc = int(sys.stdin.readline())    dp = [[0]*4 for _ in range(100001)]    # dp[0] = [0, 0, 0, 0]    #             1  2  3 사용 했을 때 값    # 점화식:    # dp[n][1] = dp[n-1][2] + dp[n-1][3] % mod    # dp[n][2] = dp[n-2][1] + dp[n-2][3] % mod    # dp[n][3] = dp[n-3][1] + dp[n-3][2] % mod    dp[0] = [0, 0, 0, 0]    dp[1] = [0, 1, 0, 0]    dp[2] = [0, 0, 1, 0]    dp[3] = [0, 1, 1, 1]    for i in range(4, 100001):        dp[i][1] = (dp[i-1][2] + dp[i-1][3]) % 1000000009        dp[i][2] = (dp[i-2][1] + dp[i-2][3]) % 1000000009        dp[i][3] = (dp[i-3][1] + dp[i-3][2]) % 1000000009    for _ in range(tc):        n = int(sys.stdin.readline())            print(sum(dp[n]) % 1000000009)if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15990%EB%B2%88/"
      },{
        "title": "백준 1707번",
        "excerpt":"BFS와 bipartite graph 감지 알고리즘을 사용해서 풀었다. bfs의 각 level을 하나의 색으로 칠하고 현재 탐색하는 노드와 연결된 다른 노드가 같은 색이 아닌 경우에만 True를 반환하는 방식이다. import sysfrom collections import dequedef is_bipartite(graph, start):    global flag    q = deque([start])    visited[start] = 1    color[start] = 1    while q:        node = q.popleft()        # 현재 노드와 연결된 다음 노드들을 탐색        for next_node in graph[node]:            if not visited[next_node]:                visited[next_node] = True                color[next_node] = color[node] + 1                q.append(next_node)                        if visited[next_node] and color[node] == color[next_node]:                flag += 1                return False    return Truedef solution():    global visited, color, flag    tc = int(sys.stdin.readline())        for _ in range(tc):        v, e = map(int, sys.stdin.readline().split())        graph = [[] for _ in range(v+1)]        visited = [False for _ in range(v+1)]        color = [0 for _ in range(v+1)]        flag = 0        for _ in range(e):            frm, to = map(int, sys.stdin.readline().split())            graph[frm].append(to)            graph[to].append(frm)                is_bipartite(graph, 1)        # 방문이 안된 노드들을 다시 확인        for i in range(len(visited)):            if not visited[i]:                is_bipartite(graph, i)                if flag &gt;= 1:            print(\"NO\")        else:            print(\"YES\")if __name__ == \"__main__\":    solution()","categories": [],
        "tags": ["백준"],
        "url": "https://json9512.github.io/blog/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-1707%EB%B2%88/"
      }]
